webpackJsonp([0],[
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ALL_BODIES = exports.AU = undefined;\n\nvar _three = __webpack_require__(1);\n\n/**\n * Kepler elements taken from http://ssd.jpl.nasa.gov/txt/aprx_pos_planets.pdf\n * Planetary constants taken from http://www.braeunig.us/space/constant.htm\n *\n * All distances are scaled down by the AU to reduce the size of the numbers\n * throughout the simulation.\n */\n\nvar AU = exports.AU = 149.59787e9;\n\nvar body_data = {\n  \"sun\": {\n    constants: {\n      u: 1.32712438e20 / Math.pow(AU, 3),\n      radius: 696e6 / AU\n    },\n    kepler_elements: {\n      a: [0, 0],\n      e: [0, 0],\n      I: [0, 0],\n      L: [0, 0],\n      w: [0, 0],\n      omega: [0, 0]\n    }\n  },\n  \"mercury\": {\n    primary: \"sun\",\n    constants: {\n      u: 0.02203e15 / Math.pow(AU, 3),\n      radius: 2.4397e6 / AU,\n      rotation_period: 58.646, // days\n      axial_tilt: 0.034 },\n    kepler_elements: {\n      a: [0.38709843, 0.0],\n      e: [0.20563661, 0.00002123],\n      I: [7.00559432, -0.00590158],\n      L: [252.25166724, 149472.67486623],\n      w: [77.45771895, 0.15940013],\n      omega: [48.33961819, -0.12214182]\n    }\n  },\n  \"venus\": {\n    primary: \"sun\",\n    constants: {\n      u: 0.3249e15 / Math.pow(AU, 3),\n      radius: 6.0518e6 / AU,\n      rotation_period: -243.025, // days (negative == retrograde)\n      axial_tilt: 177.36 },\n    kepler_elements: {\n      a: [0.72332102, -0.00000026],\n      e: [0.00676399, -0.00005107],\n      I: [3.39777545, 0.00043494],\n      L: [181.97970850, 58517.81560260],\n      w: [131.76755713, 0.05679648],\n      omega: [76.67261496, -0.27274174]\n    }\n  },\n\n  \"moon\": {\n    primary: \"earth\",\n    constants: {\n      u: 4.902794e12 / Math.pow(AU, 3),\n      radius: 1738e3 / AU,\n      rotation_period: 27.321661,\n      axial_tilt: 6.687\n    },\n    kepler_elements: {\n      a: [0.00257, 0],\n      e: [0.0549, 0],\n      I: [5.145, 0],\n      // mean longitude,\n      L: [0, 500000],\n      // longitude of perihelion\n      w: [0, 0],\n      // longitude of the ascending node\n      omega: [0, 0]\n    }\n  },\n  \"earth\": {\n    primary: \"sun\",\n    constants: {\n      u: 0.3986e15 / Math.pow(AU, 3),\n      radius: 6.3781e6 / AU,\n      rotation_period: 0.99726968,\n      axial_tilt: 23.4392811\n    },\n    kepler_elements: {\n      a: [1.00000018, -0.00000003],\n      e: [0.01673163, -0.00003661],\n      I: [-0.00054346, -0.01337178],\n      L: [100.46691572, 35999.37306329],\n      w: [102.93005885, 0.31795260],\n      omega: [-5.11260389, -0.24123856]\n    }\n  },\n  \"firefly\": {\n    primary: \"earth\",\n    constants: {\n      radius: 100 / AU\n    },\n    kepler_elements: {\n      a: [(400e3 + 6.3781e6) / AU, 0],\n      e: [0, 0],\n      I: [10, 0],\n      L: [0, 0],\n      w: [0, 0],\n      omega: [0, 0]\n    }\n  },\n  \"mars\": {\n    primary: \"sun\",\n    constants: {\n      u: 0.04283e15 / Math.pow(AU, 3),\n      radius: 3.397e6 / AU,\n      rotation_period: 1.025957, // days\n      axial_tilt: 25.19 },\n    kepler_elements: {\n      a: [1.52371243, 0.00000097],\n      e: [0.09336511, 0.00009149],\n      I: [1.85181869, -0.00724757],\n      L: [-4.56813164, 19140.29934243],\n      w: [-23.91744784, 0.45223625],\n      omega: [49.71320984, -0.26852431]\n    }\n  },\n  \"jupiter\": {\n    primary: \"sun\",\n    constants: {\n      u: 126.686e15 / Math.pow(AU, 3),\n      radius: 7.1492e7 / AU,\n      rotation_period: 0.413542, // days\n      axial_tilt: 3.13 },\n    kepler_elements: {\n      a: [5.20248019, -0.00002864],\n      e: [0.04853590, 0.00018026],\n      I: [1.29861416, -0.00322699],\n      L: [34.33479152, 3034.90371757],\n      w: [14.27495244, 0.18199196],\n      omega: [100.29282654, 0.13024619],\n      perturbations: {\n        b: -0.00012452,\n        c: 0.6064060,\n        s: -0.35635438,\n        f: 38.35125000\n      }\n    }\n  },\n  \"saturn\": {\n    primary: \"sun\",\n    constants: {\n      u: 37.391e15 / Math.pow(AU, 3),\n      radius: 6.0268e7 / AU,\n      rotation_period: 0.439583, // days\n      axial_tilt: 26.73 },\n    kepler_elements: {\n      a: [9.54149883, -0.00003065],\n      e: [0.05550825, -0.00032044],\n      I: [2.49424102, 0.00451969],\n      L: [50.07571329, 1222.11494724],\n      w: [92.86136063, 0.54179478],\n      omega: [113.63998702, -0.25015002],\n      perturbations: {\n        b: 0.00025899,\n        c: -0.13434469,\n        s: 0.87320147,\n        f: 38.35125000\n      }\n    }\n  },\n  \"uranus\": {\n    primary: \"sun\",\n    constants: {\n      u: 5.794e15 / Math.pow(AU, 3),\n      radius: 2.5559e7 / AU,\n      rotation_period: 0.71833, // days (negative == retrograde)\n      axial_tilt: 97.77 },\n    kepler_elements: {\n      a: [19.18797948, -0.00020455],\n      e: [0.04685740, -0.00001550],\n      I: [0.77298127, -0.00180155],\n      L: [314.20276625, 428.49512595],\n      w: [172.43404441, 0.09266985],\n      omega: [73.96250215, 0.05739699],\n      perturbations: {\n        b: 0.00058331,\n        c: -0.97731848,\n        s: 0.17689245,\n        f: 7.67025000\n      }\n    }\n  },\n  \"neptune\": {\n    primary: \"sun\",\n    constants: {\n      u: 6.835e15 / Math.pow(AU, 3),\n      radius: 2.4764e7 / AU,\n      rotation_period: 0.6713, // days (negative == retrograde)\n      axial_tilt: 28.32 // relative to orbit\n    },\n    kepler_elements: {\n      a: [30.06952752, 0.00006447],\n      e: [0.00895439, 0.00000818],\n      I: [1.77005520, 0.00022400],\n      L: [304.22289287, 218.46515314],\n      w: [46.68158724, 0.01009938],\n      omega: [131.78635853, -0.00606302],\n      perturbations: {\n        b: -0.00041348,\n        c: 0.68346318,\n        s: -0.10162547,\n        f: 7.67025000\n      }\n    }\n  },\n  \"pluto\": {\n    primary: \"sun\",\n    constants: {\n      u: 0.00083e15 / Math.pow(AU, 3),\n      radius: 1.195e6 / AU,\n      rotation_period: 6.387230, // days\n      axial_tilt: 122.53 },\n    kepler_elements: {\n      a: [39.48686035, 0.00449751],\n      e: [0.24885238, 0.00006016],\n      I: [17.14104260, 0.00000501],\n      L: [238.96535011, 145.18042903],\n      w: [224.09702598, -0.00968827],\n      omega: [110.30167986, -0.00809981],\n      perturbations: {\n        b: -0.01262724,\n        c: 0,\n        s: 0,\n        f: 0\n      }\n    }\n  }\n};\n\n// Initialize map\nvar bodyMap = new Map(Object.keys(body_data).map(function (name) {\n  var body = body_data[name];\n  body.name = name;\n  body.derived = {};\n\n  if (name === 'sun') {\n    body.derived = {\n      position: new _three.Vector3(0, 0, 0),\n      velocity: new _three.Vector3(0, 0, 0),\n      apoapsis: new _three.Vector3(0, 0, 0),\n      periapsis: new _three.Vector3(0, 0, 0),\n      center: new _three.Vector3(0, 0, 0)\n    };\n  }\n\n  return [name, body];\n}));\n\n// Set back-references on body graph\nArray.from(bodyMap.values()).forEach(function (body) {\n\n  // Set primary\n  if (body.primary) {\n    body.primary = bodyMap.get(body.primary);\n\n    // Add self to primary's secondaries property\n    if (!body.primary.secondaries) body.primary.secondaries = [];\n\n    body.primary.secondaries.push(body);\n  }\n});\n\n// Flatten the dependency graph to ensure that primary bodies are always\n// evaluated before their secondaries (satellites)\n\nfunction flatten(body) {\n  if (!body) {\n    return [];\n  }\n\n  return (body.secondaries || []).reduce(function (bodies, b) {\n    return bodies.concat(flatten(b));\n  }, [body]);\n}\n\nvar ALL_BODIES = exports.ALL_BODIES = flatten(bodyMap.get('sun'));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwL0JvZGllcy5qcz85NWE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIEtlcGxlciBlbGVtZW50cyB0YWtlbiBmcm9tIGh0dHA6Ly9zc2QuanBsLm5hc2EuZ292L3R4dC9hcHJ4X3Bvc19wbGFuZXRzLnBkZlxuICogUGxhbmV0YXJ5IGNvbnN0YW50cyB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuYnJhZXVuaWcudXMvc3BhY2UvY29uc3RhbnQuaHRtXG4gKlxuICogQWxsIGRpc3RhbmNlcyBhcmUgc2NhbGVkIGRvd24gYnkgdGhlIEFVIHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGUgbnVtYmVyc1xuICogdGhyb3VnaG91dCB0aGUgc2ltdWxhdGlvbi5cbiAqL1xuXG5leHBvcnQgY29uc3QgQVUgPSAxNDkuNTk3ODdlOTtcblxuY29uc3QgYm9keV9kYXRhID0ge1xuICBcInN1blwiOiB7XG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiAxLjMyNzEyNDM4ZTIwIC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiA2OTZlNiAvIEFVLFxuICAgIH0sXG4gICAga2VwbGVyX2VsZW1lbnRzOiB7XG4gICAgICBhOiBbMCwgMF0sXG4gICAgICBlOiBbMCwgMF0sXG4gICAgICBJOiBbMCwgMF0sXG4gICAgICBMOiBbMCwgMF0sXG4gICAgICB3OiBbMCwgMF0sXG4gICAgICBvbWVnYTogWzAsIDBdLFxuICAgIH1cbiAgfSxcbiAgXCJtZXJjdXJ5XCI6IHtcbiAgICBwcmltYXJ5OiBcInN1blwiLFxuICAgIGNvbnN0YW50czoge1xuICAgICAgdTogMC4wMjIwM2UxNSAvIE1hdGgucG93KEFVLCAzKSxcbiAgICAgIHJhZGl1czogMi40Mzk3ZTYgLyBBVSxcbiAgICAgIHJvdGF0aW9uX3BlcmlvZDogNTguNjQ2LCAvLyBkYXlzXG4gICAgICBheGlhbF90aWx0OiAwLjAzNCwgLy8gcmVsYXRpdmUgdG8gb3JiaXRcbiAgICB9LFxuICAgIGtlcGxlcl9lbGVtZW50czoge1xuICAgICAgYTogWzAuMzg3MDk4NDMsIDAuMF0sXG4gICAgICBlOiBbMC4yMDU2MzY2MSwgMC4wMDAwMjEyM10sXG4gICAgICBJOiBbNy4wMDU1OTQzMiwgLTAuMDA1OTAxNThdLFxuICAgICAgTDogWzI1Mi4yNTE2NjcyNCwgMTQ5NDcyLjY3NDg2NjIzXSxcbiAgICAgIHc6IFs3Ny40NTc3MTg5NSwgMC4xNTk0MDAxM10sXG4gICAgICBvbWVnYTogWzQ4LjMzOTYxODE5LCAtMC4xMjIxNDE4Ml0sXG4gICAgfVxuICB9LFxuICBcInZlbnVzXCI6IHtcbiAgICBwcmltYXJ5OiBcInN1blwiLFxuICAgIGNvbnN0YW50czoge1xuICAgICAgdTogMC4zMjQ5ZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiA2LjA1MThlNiAvIEFVLFxuICAgICAgcm90YXRpb25fcGVyaW9kOiAtMjQzLjAyNSwgLy8gZGF5cyAobmVnYXRpdmUgPT0gcmV0cm9ncmFkZSlcbiAgICAgIGF4aWFsX3RpbHQ6IDE3Ny4zNiwgLy8gcmVsYXRpdmUgdG8gb3JiaXRcbiAgICB9LFxuICAgIGtlcGxlcl9lbGVtZW50czoge1xuICAgICAgYTogWzAuNzIzMzIxMDIsIC0wLjAwMDAwMDI2XSxcbiAgICAgIGU6IFswLjAwNjc2Mzk5LCAtMC4wMDAwNTEwN10sXG4gICAgICBJOiBbMy4zOTc3NzU0NSwgMC4wMDA0MzQ5NF0sXG4gICAgICBMOiBbMTgxLjk3OTcwODUwLCA1ODUxNy44MTU2MDI2MF0sXG4gICAgICB3OiBbMTMxLjc2NzU1NzEzLCAwLjA1Njc5NjQ4XSxcbiAgICAgIG9tZWdhOiBbNzYuNjcyNjE0OTYsIC0wLjI3Mjc0MTc0XSxcbiAgICB9XG4gIH0sXG5cbiAgXCJtb29uXCI6IHtcbiAgICBwcmltYXJ5OiBcImVhcnRoXCIsXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiA0LjkwMjc5NGUxMiAvIE1hdGgucG93KEFVLCAzKSxcbiAgICAgIHJhZGl1czogMTczOGUzIC8gQVUsXG4gICAgICByb3RhdGlvbl9wZXJpb2Q6IDI3LjMyMTY2MSxcbiAgICAgIGF4aWFsX3RpbHQ6IDYuNjg3XG4gICAgfSxcbiAgICBrZXBsZXJfZWxlbWVudHM6IHtcbiAgICAgIGE6IFswLjAwMjU3LCAwXSxcbiAgICAgIGU6IFswLjA1NDksIDBdLFxuICAgICAgSTogWzUuMTQ1LCAwXSxcbiAgICAgIC8vIG1lYW4gbG9uZ2l0dWRlLFxuICAgICAgTDogWzAsIDUwMDAwMF0sXG4gICAgICAvLyBsb25naXR1ZGUgb2YgcGVyaWhlbGlvblxuICAgICAgdzogWzAsIDBdLFxuICAgICAgLy8gbG9uZ2l0dWRlIG9mIHRoZSBhc2NlbmRpbmcgbm9kZVxuICAgICAgb21lZ2E6IFswLCAwXSxcbiAgICB9XG4gIH0sXG4gIFwiZWFydGhcIjoge1xuICAgIHByaW1hcnk6IFwic3VuXCIsXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiAwLjM5ODZlMTUgLyBNYXRoLnBvdyhBVSwgMyksXG4gICAgICByYWRpdXM6IDYuMzc4MWU2IC8gQVUsXG4gICAgICByb3RhdGlvbl9wZXJpb2Q6IDAuOTk3MjY5NjgsXG4gICAgICBheGlhbF90aWx0OiAyMy40MzkyODExLFxuICAgIH0sXG4gICAga2VwbGVyX2VsZW1lbnRzOiB7XG4gICAgICBhOiBbMS4wMDAwMDAxOCwgLTAuMDAwMDAwMDNdLFxuICAgICAgZTogWzAuMDE2NzMxNjMsIC0wLjAwMDAzNjYxXSxcbiAgICAgIEk6IFstMC4wMDA1NDM0NiwgLTAuMDEzMzcxNzhdLFxuICAgICAgTDogWzEwMC40NjY5MTU3MiwgMzU5OTkuMzczMDYzMjldLFxuICAgICAgdzogWzEwMi45MzAwNTg4NSwgMC4zMTc5NTI2MF0sXG4gICAgICBvbWVnYTogWy01LjExMjYwMzg5LCAtMC4yNDEyMzg1Nl0sXG4gICAgfVxuICB9LFxuICBcImZpcmVmbHlcIjoge1xuICAgIHByaW1hcnk6IFwiZWFydGhcIixcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIHJhZGl1czogMTAwIC8gQVUsXG4gICAgfSxcbiAgICBrZXBsZXJfZWxlbWVudHM6IHtcbiAgICAgIGE6IFsoNDAwZTMgKyA2LjM3ODFlNikgLyBBVSwgMF0sXG4gICAgICBlOiBbMCwgMF0sXG4gICAgICBJOiBbMTAsIDBdLFxuICAgICAgTDogWzAsIDBdLFxuICAgICAgdzogWzAsIDBdLFxuICAgICAgb21lZ2E6IFswLCAwXSxcbiAgICB9LFxuICB9LFxuICBcIm1hcnNcIjoge1xuICAgIHByaW1hcnk6IFwic3VuXCIsXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiAwLjA0MjgzZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiAzLjM5N2U2IC8gQVUsXG4gICAgICByb3RhdGlvbl9wZXJpb2Q6IDEuMDI1OTU3LCAvLyBkYXlzXG4gICAgICBheGlhbF90aWx0OiAyNS4xOSwgLy8gcmVsYXRpdmUgdG8gb3JiaXRcbiAgICB9LFxuICAgIGtlcGxlcl9lbGVtZW50czoge1xuICAgICAgYTogWzEuNTIzNzEyNDMsIDAuMDAwMDAwOTddLFxuICAgICAgZTogWzAuMDkzMzY1MTEsIDAuMDAwMDkxNDldLFxuICAgICAgSTogWzEuODUxODE4NjksIC0wLjAwNzI0NzU3XSxcbiAgICAgIEw6IFstNC41NjgxMzE2NCwgMTkxNDAuMjk5MzQyNDNdLFxuICAgICAgdzogWy0yMy45MTc0NDc4NCwgMC40NTIyMzYyNV0sXG4gICAgICBvbWVnYTogWzQ5LjcxMzIwOTg0LCAtMC4yNjg1MjQzMV0sXG4gICAgfVxuICB9LFxuICBcImp1cGl0ZXJcIjoge1xuICAgIHByaW1hcnk6IFwic3VuXCIsXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiAxMjYuNjg2ZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiA3LjE0OTJlNyAvIEFVLFxuICAgICAgcm90YXRpb25fcGVyaW9kOiAwLjQxMzU0MiwgLy8gZGF5c1xuICAgICAgYXhpYWxfdGlsdDogMy4xMywgLy8gcmVsYXRpdmUgdG8gb3JiaXRcbiAgICB9LFxuICAgIGtlcGxlcl9lbGVtZW50czoge1xuICAgICAgYTogWzUuMjAyNDgwMTksIC0wLjAwMDAyODY0XSxcbiAgICAgIGU6IFswLjA0ODUzNTkwLCAwLjAwMDE4MDI2XSxcbiAgICAgIEk6IFsxLjI5ODYxNDE2LCAtMC4wMDMyMjY5OV0sXG4gICAgICBMOiBbMzQuMzM0NzkxNTIsIDMwMzQuOTAzNzE3NTddLFxuICAgICAgdzogWzE0LjI3NDk1MjQ0LCAwLjE4MTk5MTk2XSxcbiAgICAgIG9tZWdhOiBbMTAwLjI5MjgyNjU0LCAwLjEzMDI0NjE5XSxcbiAgICAgIHBlcnR1cmJhdGlvbnM6IHtcbiAgICAgICAgYjogLTAuMDAwMTI0NTIsXG4gICAgICAgIGM6IDAuNjA2NDA2MCxcbiAgICAgICAgczogLTAuMzU2MzU0MzgsXG4gICAgICAgIGY6IDM4LjM1MTI1MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNhdHVyblwiOiB7XG4gICAgcHJpbWFyeTogXCJzdW5cIixcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIHU6IDM3LjM5MWUxNSAvIE1hdGgucG93KEFVLCAzKSxcbiAgICAgIHJhZGl1czogNi4wMjY4ZTcgLyBBVSxcbiAgICAgIHJvdGF0aW9uX3BlcmlvZDogMC40Mzk1ODMsIC8vIGRheXNcbiAgICAgIGF4aWFsX3RpbHQ6IDI2LjczLCAvLyByZWxhdGl2ZSB0byBvcmJpdFxuICAgIH0sXG4gICAga2VwbGVyX2VsZW1lbnRzOiB7XG4gICAgICBhOiBbOS41NDE0OTg4MywgLTAuMDAwMDMwNjVdLFxuICAgICAgZTogWzAuMDU1NTA4MjUsIC0wLjAwMDMyMDQ0XSxcbiAgICAgIEk6IFsyLjQ5NDI0MTAyLCAwLjAwNDUxOTY5XSxcbiAgICAgIEw6IFs1MC4wNzU3MTMyOSwgMTIyMi4xMTQ5NDcyNF0sXG4gICAgICB3OiBbOTIuODYxMzYwNjMsIDAuNTQxNzk0NzhdLFxuICAgICAgb21lZ2E6IFsxMTMuNjM5OTg3MDIsIC0wLjI1MDE1MDAyXSxcbiAgICAgIHBlcnR1cmJhdGlvbnM6IHtcbiAgICAgICAgYjogMC4wMDAyNTg5OSxcbiAgICAgICAgYzogLTAuMTM0MzQ0NjksXG4gICAgICAgIHM6IDAuODczMjAxNDcsXG4gICAgICAgIGY6IDM4LjM1MTI1MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInVyYW51c1wiOiB7XG4gICAgcHJpbWFyeTogXCJzdW5cIixcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIHU6IDUuNzk0ZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiAyLjU1NTllNyAvIEFVLFxuICAgICAgcm90YXRpb25fcGVyaW9kOiAwLjcxODMzLCAvLyBkYXlzIChuZWdhdGl2ZSA9PSByZXRyb2dyYWRlKVxuICAgICAgYXhpYWxfdGlsdDogOTcuNzcsIC8vIHJlbGF0aXZlIHRvIG9yYml0XG4gICAgfSxcbiAgICBrZXBsZXJfZWxlbWVudHM6IHtcbiAgICAgIGE6IFsxOS4xODc5Nzk0OCwgLTAuMDAwMjA0NTVdLFxuICAgICAgZTogWzAuMDQ2ODU3NDAsIC0wLjAwMDAxNTUwXSxcbiAgICAgIEk6IFswLjc3Mjk4MTI3LCAtMC4wMDE4MDE1NV0sXG4gICAgICBMOiBbMzE0LjIwMjc2NjI1LCA0MjguNDk1MTI1OTVdLFxuICAgICAgdzogWzE3Mi40MzQwNDQ0MSwgMC4wOTI2Njk4NV0sXG4gICAgICBvbWVnYTogWzczLjk2MjUwMjE1LCAwLjA1NzM5Njk5XSxcbiAgICAgIHBlcnR1cmJhdGlvbnM6IHtcbiAgICAgICAgYjogMC4wMDA1ODMzMSxcbiAgICAgICAgYzogLTAuOTc3MzE4NDgsXG4gICAgICAgIHM6IDAuMTc2ODkyNDUsXG4gICAgICAgIGY6IDcuNjcwMjUwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwibmVwdHVuZVwiOiB7XG4gICAgcHJpbWFyeTogXCJzdW5cIixcbiAgICBjb25zdGFudHM6IHtcbiAgICAgIHU6IDYuODM1ZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiAyLjQ3NjRlNyAvIEFVLFxuICAgICAgcm90YXRpb25fcGVyaW9kOiAwLjY3MTMsIC8vIGRheXMgKG5lZ2F0aXZlID09IHJldHJvZ3JhZGUpXG4gICAgICBheGlhbF90aWx0OiAyOC4zMiAvLyByZWxhdGl2ZSB0byBvcmJpdFxuICAgIH0sXG4gICAga2VwbGVyX2VsZW1lbnRzOiB7XG4gICAgICBhOiBbMzAuMDY5NTI3NTIsIDAuMDAwMDY0NDddLFxuICAgICAgZTogWzAuMDA4OTU0MzksIDAuMDAwMDA4MThdLFxuICAgICAgSTogWzEuNzcwMDU1MjAsIDAuMDAwMjI0MDBdLFxuICAgICAgTDogWzMwNC4yMjI4OTI4NywgMjE4LjQ2NTE1MzE0XSxcbiAgICAgIHc6IFs0Ni42ODE1ODcyNCwgMC4wMTAwOTkzOF0sXG4gICAgICBvbWVnYTogWzEzMS43ODYzNTg1MywgLTAuMDA2MDYzMDJdLFxuICAgICAgcGVydHVyYmF0aW9uczoge1xuICAgICAgICBiOiAtMC4wMDA0MTM0OCxcbiAgICAgICAgYzogMC42ODM0NjMxOCxcbiAgICAgICAgczogLTAuMTAxNjI1NDcsXG4gICAgICAgIGY6IDcuNjcwMjUwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwicGx1dG9cIjoge1xuICAgIHByaW1hcnk6IFwic3VuXCIsXG4gICAgY29uc3RhbnRzOiB7XG4gICAgICB1OiAwLjAwMDgzZTE1IC8gTWF0aC5wb3coQVUsIDMpLFxuICAgICAgcmFkaXVzOiAxLjE5NWU2IC8gQVUsXG4gICAgICByb3RhdGlvbl9wZXJpb2Q6IDYuMzg3MjMwLCAvLyBkYXlzXG4gICAgICBheGlhbF90aWx0OiAxMjIuNTMsIC8vIHJlbGF0aXZlIHRvIG9yYml0XG4gICAgfSxcbiAgICBrZXBsZXJfZWxlbWVudHM6IHtcbiAgICAgIGE6IFszOS40ODY4NjAzNSwgMC4wMDQ0OTc1MV0sXG4gICAgICBlOiBbMC4yNDg4NTIzOCwgMC4wMDAwNjAxNl0sXG4gICAgICBJOiBbMTcuMTQxMDQyNjAsIDAuMDAwMDA1MDFdLFxuICAgICAgTDogWzIzOC45NjUzNTAxMSwgMTQ1LjE4MDQyOTAzXSxcbiAgICAgIHc6IFsyMjQuMDk3MDI1OTgsIC0wLjAwOTY4ODI3XSxcbiAgICAgIG9tZWdhOiBbMTEwLjMwMTY3OTg2LCAtMC4wMDgwOTk4MV0sXG4gICAgICBwZXJ0dXJiYXRpb25zOiB7XG4gICAgICAgIGI6IC0wLjAxMjYyNzI0LFxuICAgICAgICBjOiAwLFxuICAgICAgICBzOiAwLFxuICAgICAgICBmOiAwXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBJbml0aWFsaXplIG1hcFxuY29uc3QgYm9keU1hcCA9IG5ldyBNYXAoT2JqZWN0LmtleXMoYm9keV9kYXRhKVxuICAubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbGV0IGJvZHkgPSBib2R5X2RhdGFbbmFtZV07XG4gICAgYm9keS5uYW1lID0gbmFtZTtcbiAgICBib2R5LmRlcml2ZWQgPSB7fTtcblxuICAgIGlmIChuYW1lID09PSAnc3VuJykge1xuICAgICAgYm9keS5kZXJpdmVkID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgICAgIHZlbG9jaXR5OiBuZXcgVmVjdG9yMygwLCAwLCAwKSxcbiAgICAgICAgYXBvYXBzaXM6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICAgICAgICBwZXJpYXBzaXM6IG5ldyBWZWN0b3IzKDAsIDAsIDApLFxuICAgICAgICBjZW50ZXI6IG5ldyBWZWN0b3IzKDAsIDAsIDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBbbmFtZSwgYm9keV07XG4gIH0pKTtcblxuLy8gU2V0IGJhY2stcmVmZXJlbmNlcyBvbiBib2R5IGdyYXBoXG5BcnJheS5mcm9tKGJvZHlNYXAudmFsdWVzKCkpXG4gIC5mb3JFYWNoKChib2R5KSA9PiB7XG5cbiAgICAvLyBTZXQgcHJpbWFyeVxuICAgIGlmIChib2R5LnByaW1hcnkpIHtcbiAgICAgIGJvZHkucHJpbWFyeSA9IGJvZHlNYXAuZ2V0KGJvZHkucHJpbWFyeSk7XG5cbiAgICAgIC8vIEFkZCBzZWxmIHRvIHByaW1hcnkncyBzZWNvbmRhcmllcyBwcm9wZXJ0eVxuICAgICAgaWYgKCFib2R5LnByaW1hcnkuc2Vjb25kYXJpZXMpXG4gICAgICAgIGJvZHkucHJpbWFyeS5zZWNvbmRhcmllcyA9IFtdO1xuXG4gICAgICBib2R5LnByaW1hcnkuc2Vjb25kYXJpZXMucHVzaChib2R5KTtcbiAgICB9XG4gIH0pO1xuXG4vLyBGbGF0dGVuIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHRvIGVuc3VyZSB0aGF0IHByaW1hcnkgYm9kaWVzIGFyZSBhbHdheXNcbi8vIGV2YWx1YXRlZCBiZWZvcmUgdGhlaXIgc2Vjb25kYXJpZXMgKHNhdGVsbGl0ZXMpXG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYm9keSkge1xuICBpZiAoIWJvZHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gKGJvZHkuc2Vjb25kYXJpZXMgfHwgW10pXG4gICAgLnJlZHVjZSgoYm9kaWVzLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYm9kaWVzLmNvbmNhdChmbGF0dGVuKGIpKTtcbiAgICB9LCBbYm9keV0pO1xufVxuXG5leHBvcnQgY29uc3QgQUxMX0JPRElFUyA9IGZsYXR0ZW4oYm9keU1hcC5nZXQoJ3N1bicpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL0JvZGllcy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFHQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUxBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFMQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVJBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFQQTtBQVJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFQQTtBQVJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFQQTtBQVJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVBBO0FBUkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVBBO0FBUkE7QUFsTkE7QUFDQTtBQTBPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */,
/* 4 */
/***/ (function(module, exports) {

eval("module.exports = function( THREE ) {\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls( object, domElement ) {\n\n\t\tthis.object = object;\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function update () {\n\n\t\t\t\tvar position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function() {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tvar spherical = new THREE.Spherical();\n\t\tvar sphericalDelta = new THREE.Spherical();\n\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tvar panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tvar pan = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\treturn function pan ( deltaX, deltaY ) {\n\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\t//console.log( 'handleMouseDownPan' );\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\t//console.log( 'handleMouseMovePan' );\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( event ) {\n\n\t\t\t//console.log( 'handleMouseUp' );\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\t//console.log( 'handleMouseWheel' );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\t//console.log( 'handleKeyDown' );\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\t//console.log( 'handleTouchStartPan' );\n\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\t//console.log( 'handleTouchMovePan' );\n\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchEnd( event ) {\n\n\t\t\t//console.log( 'handleTouchEnd' );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tcenter: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\treturn this.target;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdGhyZWUtb3JiaXQtY29udHJvbHMvaW5kZXguanM/ZjY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBUSFJFRSApIHtcblx0LyoqXG5cdCAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cblx0ICovXG5cbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLlxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cbi8vXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lIGZpbmdlciBtb3ZlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGFycm93IGtleXMgLyB0b3VjaDogdGhyZWUgZmludGVyIHN3aXBlXG5cblx0ZnVuY3Rpb24gT3JiaXRDb250cm9scyggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuXHRcdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuXHRcdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG5cdFx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdFx0dGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcblx0XHR0aGlzLm1pblpvb20gPSAwO1xuXHRcdHRoaXMubWF4Wm9vbSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdFx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG5cdFx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuXHRcdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG5cdFx0Ly8gSWYgc2V0LCBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIHRoZSBpbnRlcnZhbCBbIC0gTWF0aC5QSSwgTWF0aC5QSSBdLlxuXHRcdHRoaXMubWluQXppbXV0aEFuZ2xlID0gLSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXHRcdHRoaXMubWF4QXppbXV0aEFuZ2xlID0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblxuXHRcdC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuXHRcdC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5lbmFibGVEYW1waW5nID0gZmFsc2U7XG5cdFx0dGhpcy5kYW1waW5nRmFjdG9yID0gMC4yNTtcblxuXHRcdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuXHRcdHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XG5cdFx0dGhpcy56b29tU3BlZWQgPSAxLjA7XG5cblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSByb3RhdGluZ1xuXHRcdHRoaXMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcblx0XHR0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcGFubmluZ1xuXHRcdHRoaXMuZW5hYmxlUGFuID0gdHJ1ZTtcblx0XHR0aGlzLmtleVBhblNwZWVkID0gNy4wO1x0Ly8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG5cdFx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0XHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xuXHRcdHRoaXMuZW5hYmxlS2V5cyA9IHRydWU7XG5cblx0XHQvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG5cdFx0dGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuXHRcdC8vIE1vdXNlIGJ1dHRvbnNcblx0XHR0aGlzLm1vdXNlQnV0dG9ucyA9IHsgT1JCSVQ6IFRIUkVFLk1PVVNFLkxFRlQsIFpPT006IFRIUkVFLk1PVVNFLk1JRERMRSwgUEFOOiBUSFJFRS5NT1VTRS5SSUdIVCB9O1xuXG5cdFx0Ly8gZm9yIHJlc2V0XG5cdFx0dGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcblx0XHR0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG5cdFx0dGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG5cblx0XHQvL1xuXHRcdC8vIHB1YmxpYyBtZXRob2RzXG5cdFx0Ly9cblxuXHRcdHRoaXMuZ2V0UG9sYXJBbmdsZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHNwaGVyaWNhbC5waGk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRBemltdXRoYWxBbmdsZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHNwaGVyaWNhbC50aGV0YTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzY29wZS50YXJnZXQuY29weSggc2NvcGUudGFyZ2V0MCApO1xuXHRcdFx0c2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvc2l0aW9uMCApO1xuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcblxuXHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9O1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgZXhwb3NlZCwgYnV0IHBlcmhhcHMgaXQgd291bGQgYmUgYmV0dGVyIGlmIHdlIGNhbiBtYWtlIGl0IHByaXZhdGUuLi5cblx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gc28gY2FtZXJhLnVwIGlzIHRoZSBvcmJpdCBheGlzXG5cdFx0XHR2YXIgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0XHRcdHZhciBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnNlKCk7XG5cblx0XHRcdHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIGxhc3RRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXG5cdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0Ly8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG5cdFx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXQgKTtcblxuXHRcdFx0XHQvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cdFx0XHRcdHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyggb2Zmc2V0ICk7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5hdXRvUm90YXRlICYmIHN0YXRlID09PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdFx0cm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG5cdFx0XHRcdHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuXG5cdFx0XHRcdC8vIHJlc3RyaWN0IHRoZXRhIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gTWF0aC5tYXgoIHNjb3BlLm1pbkF6aW11dGhBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heEF6aW11dGhBbmdsZSwgc3BoZXJpY2FsLnRoZXRhICkgKTtcblxuXHRcdFx0XHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXHRcdFx0XHRzcGhlcmljYWwucGhpID0gTWF0aC5tYXgoIHNjb3BlLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCBzY29wZS5tYXhQb2xhckFuZ2xlLCBzcGhlcmljYWwucGhpICkgKTtcblxuXHRcdFx0XHRzcGhlcmljYWwubWFrZVNhZmUoKTtcblxuXG5cdFx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgKj0gc2NhbGU7XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdFx0c3BoZXJpY2FsLnJhZGl1cyA9IE1hdGgubWF4KCBzY29wZS5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHNjb3BlLm1heERpc3RhbmNlLCBzcGhlcmljYWwucmFkaXVzICkgKTtcblxuXHRcdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblx0XHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0XHRcdFx0b2Zmc2V0LnNldEZyb21TcGhlcmljYWwoIHNwaGVyaWNhbCApO1xuXG5cdFx0XHRcdC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuXHRcdFx0XHRvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0SW52ZXJzZSApO1xuXG5cdFx0XHRcdHBvc2l0aW9uLmNvcHkoIHNjb3BlLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRcdFx0c2NvcGUub2JqZWN0Lmxvb2tBdCggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVEYW1waW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXHRcdFx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNwaGVyaWNhbERlbHRhLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY2FsZSA9IDE7XG5cdFx0XHRcdHBhbk9mZnNldC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgY29uZGl0aW9uIGlzOlxuXHRcdFx0XHQvLyBtaW4oY2FtZXJhIGRpc3BsYWNlbWVudCwgY2FtZXJhIHJvdGF0aW9uIGluIHJhZGlhbnMpXjIgPiBFUFNcblx0XHRcdFx0Ly8gdXNpbmcgc21hbGwtYW5nbGUgYXBwcm94aW1hdGlvbiBjb3MoeC8yKSA9IDEgLSB4XjIgLyA4XG5cblx0XHRcdFx0aWYgKCB6b29tQ2hhbmdlZCB8fFxuXHRcdFx0XHRcdGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgfHxcblx0XHRcdFx0XHQ4ICogKCAxIC0gbGFzdFF1YXRlcm5pb24uZG90KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApICkgPiBFUFMgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBjaGFuZ2VFdmVudCApO1xuXG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdGxhc3RRdWF0ZXJuaW9uLmNvcHkoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0em9vbUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTtcblxuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXG5cdFx0XHQvL3Njb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cblxuXHRcdH07XG5cblx0XHQvL1xuXHRcdC8vIGludGVybmFsc1xuXHRcdC8vXG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGNoYW5nZUV2ZW50ID0geyB0eXBlOiAnY2hhbmdlJyB9O1xuXHRcdHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnIH07XG5cdFx0dmFyIGVuZEV2ZW50ID0geyB0eXBlOiAnZW5kJyB9O1xuXG5cdFx0dmFyIFNUQVRFID0geyBOT05FIDogLSAxLCBST1RBVEUgOiAwLCBET0xMWSA6IDEsIFBBTiA6IDIsIFRPVUNIX1JPVEFURSA6IDMsIFRPVUNIX0RPTExZIDogNCwgVE9VQ0hfUEFOIDogNSB9O1xuXG5cdFx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG5cdFx0dmFyIHNwaGVyaWNhbCA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcblx0XHR2YXIgc3BoZXJpY2FsRGVsdGEgPSBuZXcgVEhSRUUuU3BoZXJpY2FsKCk7XG5cblx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdHZhciBwYW5PZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0dmFyIHJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHR2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0dmFyIHBhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHR2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHR2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0dmFyIGRvbGx5U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHZhciBkb2xseUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0dmFyIGRvbGx5RGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG5cblx0XHRcdHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByb3RhdGVMZWZ0KCBhbmdsZSApIHtcblxuXHRcdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgLT0gYW5nbGU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByb3RhdGVVcCggYW5nbGUgKSB7XG5cblx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcblxuXHRcdH1cblxuXHRcdHZhciBwYW5MZWZ0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDAgKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0dmFyIHBhblVwID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhblVwKCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xuXG5cdFx0XHRcdHYuc2V0RnJvbU1hdHJpeENvbHVtbiggb2JqZWN0TWF0cml4LCAxICk7IC8vIGdldCBZIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcblx0XHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHQvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0XHR2YXIgcGFuID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuICggZGVsdGFYLCBkZWx0YVkgKSB7XG5cblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHRcdC8vIHBlcnNwZWN0aXZlXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0dmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG5cdFx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdFx0Ly8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuXHRcdFx0XHRcdHBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdFx0cGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0Ly8gb3J0aG9ncmFwaGljXG5cdFx0XHRcdFx0cGFuTGVmdCggZGVsdGFYICogKCBzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCApIC8gc2NvcGUub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudFdpZHRoLCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdFx0cGFuVXAoIGRlbHRhWSAqICggc2NvcGUub2JqZWN0LnRvcCAtIHNjb3BlLm9iamVjdC5ib3R0b20gKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG5vciBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHBhbiBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdFx0c2NvcGUuZW5hYmxlUGFuID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0ZnVuY3Rpb24gZG9sbHlJbiggZG9sbHlTY2FsZSApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tICogZG9sbHlTY2FsZSApICk7XG5cdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicgKTtcblx0XHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb2xseU91dCggZG9sbHlTY2FsZSApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApIHtcblxuXHRcdFx0XHRzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gZG9sbHlTY2FsZSApICk7XG5cdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLicgKTtcblx0XHRcdFx0c2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXHRcdC8vIGV2ZW50IGNhbGxiYWNrcyAtIHVwZGF0ZSB0aGUgb2JqZWN0IHN0YXRlXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Sb3RhdGUnICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duRG9sbHknICk7XG5cblx0XHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUGFuJyApO1xuXG5cdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVNb3VzZU1vdmVSb3RhdGUnICk7XG5cblx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcblx0XHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZURvbGx5JyApO1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG5cdFx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcblxuXHRcdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVBhbicgKTtcblxuXHRcdFx0cGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cblx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlVXAnICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlV2hlZWwnICk7XG5cblx0XHRcdGlmICggZXZlbnQuZGVsdGFZIDwgMCApIHtcblxuXHRcdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQuZGVsdGFZID4gMCApIHtcblxuXHRcdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlS2V5RG93biggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVLZXlEb3duJyApO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXG5cdFx0XHRcdGNhc2Ugc2NvcGUua2V5cy5VUDpcblx0XHRcdFx0XHRwYW4oIDAsIHNjb3BlLmtleVBhblNwZWVkICk7XG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcblx0XHRcdFx0XHRwYW4oIDAsIC0gc2NvcGUua2V5UGFuU3BlZWQgKTtcblx0XHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuTEVGVDpcblx0XHRcdFx0XHRwYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXHRcdFx0XHRcdHBhbiggLSBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRSb3RhdGUnICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0RG9sbHknICk7XG5cblx0XHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcblx0XHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFBhbicgKTtcblxuXHRcdFx0cGFuU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVJvdGF0ZScgKTtcblxuXHRcdFx0cm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcblx0XHRcdHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuXHRcdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cblx0XHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcblx0XHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHQvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcblx0XHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZURvbGx5JyApO1xuXG5cdFx0XHR2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG5cdFx0XHR2YXIgZHkgPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVk7XG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcblxuXHRcdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuXG5cdFx0XHRkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cblx0XHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuXHRcdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcblxuXHRcdFx0XHRkb2xseUluKCBnZXRab29tU2NhbGUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hNb3ZlUGFuJyApO1xuXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuXG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG5cblx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHRcdC8vY29uc29sZS5sb2coICdoYW5kbGVUb3VjaEVuZCcgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cdFx0Ly8gZXZlbnQgaGFuZGxlcnMgLSBGU006IGxpc3RlbiBmb3IgZXZlbnRzIGFuZCByZXNldCBzdGF0ZVxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlRG93biggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdGlmICggZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuT1JCSVQgKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSBzY29wZS5tb3VzZUJ1dHRvbnMuWk9PTSApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gc2NvcGUubW91c2VCdXR0b25zLlBBTiApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcblxuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5ET0xMWSApIHtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuUEFOICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VVcCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGhhbmRsZU1vdXNlVXAoIGV2ZW50ICk7XG5cblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlIHx8ICggc3RhdGUgIT09IFNUQVRFLk5PTkUgJiYgc3RhdGUgIT09IFNUQVRFLlJPVEFURSApICkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICk7XG5cblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTsgLy8gbm90IHN1cmUgd2h5IHRoZXNlIGFyZSBoZXJlLi4uXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVLZXlzID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Y2FzZSAxOlx0Ly8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMjpcdC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Y2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1JPVEFURSApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6IC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGhhbmRsZVRvdWNoRW5kKCBldmVudCApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkNvbnRleHRNZW51KCBldmVudCApIHtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlICk7XG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UgKTtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlICk7XG5cdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSApO1xuXG5cdFx0Ly8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblx0T3JiaXRDb250cm9scy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5cdE9yYml0Q29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JiaXRDb250cm9scztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggT3JiaXRDb250cm9scy5wcm90b3R5cGUsIHtcblxuXHRcdGNlbnRlcjoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuY2VudGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnRhcmdldCcgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGFyZ2V0O1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5cdFx0bm9ab29tOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVpvb207XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5lbmFibGVab29tID0gISB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG5vUm90YXRlOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVSb3RhdGU7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHRoaXMuZW5hYmxlUm90YXRlID0gISB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG5vUGFuOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVQYW47XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9QYW4gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVQYW4gaW5zdGVhZC4nICk7XG5cdFx0XHRcdHRoaXMuZW5hYmxlUGFuID0gISB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG5vS2V5czoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVLZXlzO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vS2V5cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZUtleXMgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHRoaXMuZW5hYmxlS2V5cyA9ICEgdmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRzdGF0aWNNb3ZpbmcgOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZURhbXBpbmc7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5lbmFibGVEYW1waW5nID0gISB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGR5bmFtaWNEYW1waW5nRmFjdG9yIDoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYW1waW5nRmFjdG9yO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLmR5bmFtaWNEYW1waW5nRmFjdG9yIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSAuZGFtcGluZ0ZhY3RvciBpbnN0ZWFkLicgKTtcblx0XHRcdFx0dGhpcy5kYW1waW5nRmFjdG9yID0gdmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9ICk7XG5cblx0cmV0dXJuIE9yYml0Q29udHJvbHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RocmVlLW9yYml0LWNvbnRyb2xzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = BaseRenderer;\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Textures\nvar TEXTURES = {\n  'moon': __webpack_require__(133),\n  'earth': __webpack_require__(127),\n  'earthspec': __webpack_require__(128),\n  'earthbump': __webpack_require__(126),\n  'jupiter': __webpack_require__(129),\n  'saturn': __webpack_require__(136),\n  'mercury': __webpack_require__(132),\n  'venus': __webpack_require__(138),\n  'mars': __webpack_require__(131),\n  'pluto': __webpack_require__(135),\n  'neptune': __webpack_require__(134),\n  'uranus': __webpack_require__(137),\n  'lensflare': __webpack_require__(130),\n  'rock1': __webpack_require__(125)\n};\n\nvar MODELS = {\n  'rock1': __webpack_require__(139)\n};\n\nfunction BaseRenderer(textureLoader, modelLoader, state) {\n  this.textureLoader = textureLoader;\n  this.modelLoader = modelLoader;\n  this.state = state;\n};\n\n// Allow renderers to act on changes to the user interface\nObject.assign(BaseRenderer.prototype, THREE.EventDispatcher.prototype);\n\n/**\n *\n */\nBaseRenderer.prototype._onWindowResize = function (originalHeight, originalFov) {\n  var _this = this;\n\n  var tanFOV = Math.tan(Math.PI / 180 * originalFov / 2);\n  return function (event) {\n    _this.camera.aspect = window.innerWidth / window.innerHeight;\n    _this.camera.fov = 360 / Math.PI * Math.atan(tanFOV * (window.innerHeight / originalHeight));\n\n    _this.camera.updateProjectionMatrix();\n    _this.renderer.setSize(window.innerWidth, window.innerHeight);\n  };\n};\n\nBaseRenderer.prototype._loadTextures = function (textures) {\n  var _this2 = this;\n\n  return Promise.all(textures.filter(function (t) {\n    return TEXTURES.hasOwnProperty(t);\n  }).map(function (key) {\n    return new Promise(function (resolve, reject) {\n      _this2.textureLoader.load(TEXTURES[key], function (texture) {\n        resolve([key, texture]);\n      });\n    });\n  })).then(function (values) {\n    return Promise.resolve(new Map(values));\n  });\n};\n\nBaseRenderer.prototype._loadModels = function () {\n  var _this3 = this;\n\n  return Promise.all(Object.entries(MODELS).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return new Promise(function (resolve, reject) {\n      _this3.modelLoader.load(value, function (model) {\n        resolve([key, model]);\n      });\n    });\n  })).then(function (values) {\n    return Promise.resolve(new Map(values));\n  });\n};\n\nBaseRenderer.prototype._setupLightSources = function () {\n  var ambientLight = new THREE.AmbientLight(0x202020);\n  var directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n\n  directionalLight.castShadow = true;\n  directionalLight.shadow.camera.up = new THREE.Vector3(0, 0, 1);\n\n  this.scene.add(ambientLight);\n  this.scene.add(directionalLight);\n\n  return directionalLight;\n};\n\nBaseRenderer.prototype._createSkyBox = function () {\n\n  //This will add a starfield to the background of a scene\n  var vertices = [];\n\n  for (var i = 0; i < 20000; i++) {\n\n    var r = void 0;\n\n    // Generate stars that are a minimum distance away\n    do {\n      r = new THREE.Vector3(THREE.Math.randFloatSpread(2000), THREE.Math.randFloatSpread(2000), THREE.Math.randFloatSpread(2000));\n    } while (r.lengthSq() < 100);\n\n    vertices.push(r.x, r.y, r.z);\n  }\n\n  var starsGeometry = new THREE.BufferGeometry();\n  starsGeometry.addAttribute('position', new THREE.BufferAttribute(Float32Array.from(vertices), 3));\n\n  var starsMaterial = new THREE.PointsMaterial({\n    color: 0x888888\n  });\n\n  var starField = new THREE.Points(starsGeometry, starsMaterial);\n  starField.matrixAutoUpdate = false;\n\n  return starField;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwL0Jhc2VSZW5kZXJlci5qcz8zMzEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuLy8gVGV4dHVyZXNcbmNvbnN0IFRFWFRVUkVTID0ge1xuICAnbW9vbic6IHJlcXVpcmUoJy4uL2ltZy9tb29ubWFwLmpwZycpLFxuICAnZWFydGgnOiByZXF1aXJlKCcuLi9pbWcvZWFydGhtYXAuanBnJyksXG4gICdlYXJ0aHNwZWMnOiByZXF1aXJlKCcuLi9pbWcvZWFydGhzcGVjLmpwZycpLFxuICAnZWFydGhidW1wJzogcmVxdWlyZSgnLi4vaW1nL2VhcnRoYnVtcC5qcGcnKSxcbiAgJ2p1cGl0ZXInOiByZXF1aXJlKCcuLi9pbWcvanVwaXRlcm1hcC5qcGcnKSxcbiAgJ3NhdHVybic6IHJlcXVpcmUoJy4uL2ltZy9zYXR1cm5tYXAuanBnJyksXG4gICdtZXJjdXJ5JzogcmVxdWlyZSgnLi4vaW1nL21lcmN1cnltYXAuanBnJyksXG4gICd2ZW51cyc6IHJlcXVpcmUoJy4uL2ltZy92ZW51c21hcC5qcGcnKSxcbiAgJ21hcnMnOiByZXF1aXJlKCcuLi9pbWcvbWFyc21hcC5qcGcnKSxcbiAgJ3BsdXRvJzogcmVxdWlyZSgnLi4vaW1nL3BsdXRvbWFwLmpwZycpLFxuICAnbmVwdHVuZSc6IHJlcXVpcmUoJy4uL2ltZy9uZXB0dW5lbWFwLmpwZycpLFxuICAndXJhbnVzJzogcmVxdWlyZSgnLi4vaW1nL3VyYW51c21hcC5qcGcnKSxcbiAgJ2xlbnNmbGFyZSc6IHJlcXVpcmUoJy4uL2ltZy9sZW5zZmxhcmUucG5nJyksXG4gICdyb2NrMSc6IHJlcXVpcmUoJy4uL21vZGVscy9yb2NrMS9Bcm1HcmEwNS5qcGcnKSxcbn07XG5cbmNvbnN0IE1PREVMUyA9IHtcbiAgJ3JvY2sxJzogcmVxdWlyZSgnLi4vbW9kZWxzL3JvY2sxLmRhZScpLFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCYXNlUmVuZGVyZXIodGV4dHVyZUxvYWRlciwgbW9kZWxMb2FkZXIsIHN0YXRlKSB7XG4gIHRoaXMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG4gIHRoaXMubW9kZWxMb2FkZXIgPSBtb2RlbExvYWRlcjtcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xufTtcblxuLy8gQWxsb3cgcmVuZGVyZXJzIHRvIGFjdCBvbiBjaGFuZ2VzIHRvIHRoZSB1c2VyIGludGVyZmFjZVxuT2JqZWN0LmFzc2lnbihCYXNlUmVuZGVyZXIucHJvdG90eXBlLCBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKlxuICovXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLl9vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIChvcmlnaW5hbEhlaWdodCwgb3JpZ2luYWxGb3YpIHtcbiAgY29uc3QgdGFuRk9WID0gTWF0aC50YW4oKChNYXRoLlBJIC8gMTgwKSAqIG9yaWdpbmFsRm92IC8gMikpO1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuZm92ID0gKDM2MCAvIE1hdGguUEkpICogTWF0aC5hdGFuKHRhbkZPViAqICh3aW5kb3cuaW5uZXJIZWlnaHQgLyBvcmlnaW5hbEhlaWdodCkpO1xuXG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgfVxuXG59O1xuXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLl9sb2FkVGV4dHVyZXMgPSBmdW5jdGlvbiAodGV4dHVyZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdGV4dHVyZXMuZmlsdGVyKCh0KSA9PiBURVhUVVJFUy5oYXNPd25Qcm9wZXJ0eSh0KSlcbiAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUxvYWRlci5sb2FkKFRFWFRVUkVTW2tleV0sXG4gICAgICAgICAgICAodGV4dHVyZSkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtrZXksIHRleHR1cmVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKVxuICAgIC50aGVuKHZhbHVlcyA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAodmFsdWVzKSlcbiAgICB9KTtcbn07XG5cbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuX2xvYWRNb2RlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhNT0RFTFMpXG4gICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLm1vZGVsTG9hZGVyLmxvYWQodmFsdWUsXG4gICAgICAgICAgICAobW9kZWwpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShba2V5LCBtb2RlbF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpXG4gICAgLnRoZW4odmFsdWVzID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE1hcCh2YWx1ZXMpKTtcbiAgICB9KTtcbn07XG5cbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuX3NldHVwTGlnaHRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4MjAyMDIwKTtcbiAgY29uc3QgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAxKTtcblxuICBkaXJlY3Rpb25hbExpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlO1xuICBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvdy5jYW1lcmEudXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcblxuICB0aGlzLnNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuICB0aGlzLnNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcblxuICByZXR1cm4gZGlyZWN0aW9uYWxMaWdodDtcbn07XG5cbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuX2NyZWF0ZVNreUJveCA9IGZ1bmN0aW9uICgpIHtcblxuICAvL1RoaXMgd2lsbCBhZGQgYSBzdGFyZmllbGQgdG8gdGhlIGJhY2tncm91bmQgb2YgYSBzY2VuZVxuICBsZXQgdmVydGljZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDIwMDAwOyBpKyspIHtcblxuICAgIGxldCByO1xuXG4gICAgLy8gR2VuZXJhdGUgc3RhcnMgdGhhdCBhcmUgYSBtaW5pbXVtIGRpc3RhbmNlIGF3YXlcbiAgICBkbyB7XG4gICAgICByID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgIFRIUkVFLk1hdGgucmFuZEZsb2F0U3ByZWFkKDIwMDApLFxuICAgICAgICBUSFJFRS5NYXRoLnJhbmRGbG9hdFNwcmVhZCgyMDAwKSxcbiAgICAgICAgVEhSRUUuTWF0aC5yYW5kRmxvYXRTcHJlYWQoMjAwMCkpXG4gICAgfSB3aGlsZSAoci5sZW5ndGhTcSgpIDwgMTAwKVxuXG4gICAgdmVydGljZXMucHVzaChyLngsIHIueSwgci56KTtcbiAgfVxuXG4gIGxldCBzdGFyc0dlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIHN0YXJzR2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsXG4gICAgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZShGbG9hdDMyQXJyYXkuZnJvbSh2ZXJ0aWNlcyksIDMpKTtcblxuICBsZXQgc3RhcnNNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XG4gICAgY29sb3I6IDB4ODg4ODg4XG4gIH0pXG5cbiAgbGV0IHN0YXJGaWVsZCA9IG5ldyBUSFJFRS5Qb2ludHMoc3RhcnNHZW9tZXRyeSwgc3RhcnNNYXRlcmlhbCk7XG4gIHN0YXJGaWVsZC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgcmV0dXJuIHN0YXJGaWVsZDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcC9CYXNlUmVuZGVyZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBd0JBO0FBQ0E7QUF6QkE7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _BaseRenderer = __webpack_require__(5);\n\nvar _BaseRenderer2 = _interopRequireDefault(_BaseRenderer);\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Bodies = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OrbitControls = __webpack_require__(4)(THREE);\n\nfunction CameraViewRenderer(container, textureLoader, modelLoader, commonState) {\n\n  _BaseRenderer2.default.call(this, textureLoader, modelLoader, commonState);\n\n  this.renderer = new THREE.WebGLRenderer({\n    antialias: true,\n    alpha: false\n  });\n  this.renderer.setPixelRatio(window.devicePixelRatio);\n  this.renderer.shadowMap.enabled = true;\n  this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n  this.container = container;\n  container.appendChild(this.renderer.domElement);\n\n  this.bodyCache = new Map();\n};\n\n/**\n * Use this lifeycle method to add event listeners\n */\nCameraViewRenderer.prototype.viewDidLoad = function (solarSystem) {\n  var _this = this;\n\n  // Find the body we are focusing on\n  var focus = solarSystem.find(this.state.focus);\n\n  this.scene = new THREE.Scene();\n  this.scene.background = new THREE.Color('black');\n\n  // Background stars\n  var skybox = this._createSkyBox();\n  this.scene.add(skybox);\n\n  // Setup light\n  this.lightSource = this._setupLightSources();\n\n  var width = window.innerWidth;\n  var height = window.innerHeight;\n\n  // initialize camera and scene\n  this.camera = new THREE.PerspectiveCamera(45, width / height, 1e-10, 2);\n\n  /**\n   * Callback to recenter the camera\n   */\n  var recenter = function recenter() {\n    var focus = solarSystem.find(_this.state.focus);\n\n    if (focus.name === 'sun') {\n      _this.camera.up = new THREE.Vector3(0, 0, 1);\n      _this.camera.position.set(0, -5 * focus.constants.radius, 0);\n      _this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n      return;\n    }\n\n    // Set camera behind in the opposite direction of the velocity vector\n    var camera_position = focus.derived.velocity.clone().normalize().negate().multiplyScalar(5 * focus.constants.radius);\n\n    var primary_position = new THREE.Vector3().sub(_this._adjustCoordinates(focus, focus.primary.derived.position));\n\n    // Base the camera UP direction off of the velocity vector, rotated 90 degrees up.\n    _this.camera.up = new THREE.Vector3().copy(focus.derived.velocity).applyAxisAngle(primary_position.normalize(), Math.PI / 2).normalize();\n\n    _this.camera.position.set(camera_position.x, camera_position.y, camera_position.z);\n    _this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n  };\n\n  /**\n   * Callback for when we change the body focus\n   */\n  var onFocus = function onFocus(focus) {\n    // First dispose of existing orbit controls if they exist.\n    _this.orbitControls && _this.orbitControls.dispose();\n\n    recenter();\n\n    _this.orbitControls = new OrbitControls(_this.camera, _this.renderer.domElement);\n    _this.orbitControls.minDistance = focus.constants.radius * 1.5;\n    _this.orbitControls.maxDistance = focus.constants.radius * 100;\n  };\n\n  this.addEventListener('focus', function (event) {\n    var focus = solarSystem.find(event.focus);\n    onFocus(focus);\n  });\n\n  this.addEventListener('recenter', function (event) {\n    recenter();\n  });\n\n  var onWindowResize = this._onWindowResize(height, this.camera.fov);\n  this.addEventListener('resize', function (event) {\n    onWindowResize();\n  });\n\n  /**\n   * Setup lifecycle methods for registering/deregistering event listeners\n   */\n\n  this.viewWillAppear = function () {\n    var focus = solarSystem.find(_this.state.focus);\n    onFocus(focus);\n    onWindowResize();\n  };\n\n  this.viewWillDisappear = function () {\n    _this.orbitControls.dispose();\n    _this.orbitControls = null;\n  };\n\n  return Promise.resolve();\n};\n\n/**\n * Render the given solar system\n */\nCameraViewRenderer.prototype.render = function (solarSystem) {\n  var _this2 = this;\n\n  // Find the body we are focusing on\n  var focus = solarSystem.find(this.state.focus);\n  var sun = solarSystem.find('sun');\n\n  // Track the light source\n  this._adjustLightSource(focus, sun);\n\n  // Find all of the bodies that are we are concerned about in our render loop\n\n  var _lookupNearbyBodies = this._lookupNearbyBodies(focus, solarSystem.bodies),\n      _lookupNearbyBodies2 = _slicedToArray(_lookupNearbyBodies, 2),\n      neighbours = _lookupNearbyBodies2[0],\n      outliers = _lookupNearbyBodies2[1];\n\n  // Make objects outside of our current sphere invisible (to save resources)\n\n\n  outliers.forEach(function (body) {\n    var cached = _this2.bodyCache.get(body.name);\n    if (cached) cached.visible = false;\n  });\n\n  // Update the positions of all of our bodies\n  neighbours.forEach(function (body) {\n\n    _this2.loadThreeBody(body).then(function (threeBody) {\n\n      threeBody.visible = true;\n\n      var derived = body.derived;\n\n      // Adjust position to re-center the coordinate system on the focus\n      var position = _this2._adjustCoordinates(focus, derived.position);\n      threeBody.position.set(position.x, position.y, position.z);\n\n      // Adjust orbital tilt and rotation.  First, rotate the body using the same\n      // set of transforms we use to transform to ecliptic.  Then, apply the axial tilt,\n      // and the accumulated rotation around the axis ('derived.rotation');\n      threeBody.rotation.set(0, 0, 0);\n      threeBody.rotateZ(derived.omega);\n      threeBody.rotateX(derived.I);\n      threeBody.rotateZ(derived.argumentPerihelion);\n      threeBody.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);\n      threeBody.rotateOnAxis(new THREE.Vector3(1, 0, 0), -(body.constants.axial_tilt || 0) * Math.PI / 180);\n      threeBody.rotateY(derived.rotation);\n    });\n  });\n\n  this.renderer.render(this.scene, this.camera);\n};\n\nCameraViewRenderer.prototype.loadThreeBody = function (body) {\n  var _this3 = this;\n\n  // Cache our bodies\n  var cached = this.bodyCache.get(body.name);\n  if (cached) {\n    return Promise.resolve(cached);\n  }\n\n  var material = void 0;\n  if (body.name === 'sun') {\n    material = new THREE.MeshBasicMaterial({\n      color: 'yellow'\n    });\n  } else {\n    material = new THREE.MeshPhongMaterial();\n  }\n\n  var threeBody = new THREE.Mesh(new THREE.SphereGeometry(body.constants.radius, 128, 128), material);\n\n  threeBody.receiveShadow = true;\n  threeBody.castShadow = true;\n\n  this.scene.add(threeBody);\n  this.bodyCache.set(body.name, threeBody);\n\n  return Promise.race([new Promise(function (resolve, reject) {\n    return resolve(threeBody);\n  }), new Promise(function (resolve, reject) {\n\n    var texturesToLoad = [body.name, body.name + 'bump', body.name + 'spec'];\n    return _this3._loadTextures(texturesToLoad).then(function (textures) {\n\n      if (textures.has(body.name + 'bump')) {\n        material.bumpMap = textures.get(body.name + 'bump');\n        material.bumpScale = 100000 / _Bodies.AU;\n      }\n\n      if (textures.has(body.name + 'spec')) {\n        material.specularMap = textures.get(body.name + 'spec');\n        material.specular = new THREE.Color('grey');\n      }\n\n      if (textures.has(body.name)) {\n        // Reduce harsh glare effect of the light source (default 30 -> 1);\n        material.map = textures.get(body.name);\n        material.shininess = 1;\n      }\n\n      material.needsUpdate = true;\n      return Promise.resolve(threeBody);\n    });\n  })]);\n};\n\nCameraViewRenderer.prototype._adjustLightSource = function (focus, sun) {\n\n  var light = this.lightSource;\n  var lightPosition = this._adjustCoordinates(focus, sun.derived.position);\n\n  light.position.set(lightPosition.x, lightPosition.y, lightPosition.z);\n\n  // Frame the shadow box appropriately\n  if (focus.primary && focus.primary.name !== 'sun') {\n    var lightBoxLength = focus.primary.constants.radius;\n    light.shadow.camera.near = 0.99 * focus.primary.derived.position.length();\n    light.shadow.camera.far = 1.01 * focus.primary.derived.position.length();\n    light.shadow.camera.left = -lightBoxLength;\n    light.shadow.camera.right = lightBoxLength;\n    light.shadow.camera.top = lightBoxLength;\n    light.shadow.camera.bottom = -lightBoxLength;\n  }\n};\n\nCameraViewRenderer.prototype._lookupNearbyBodies = function (focus, bodies) {\n\n  var nearbyThreshold = 0.05;\n  var partitioned = bodies.map(function (body) {\n    var distance = new THREE.Vector3().subVectors(focus.derived.position, body.derived.position);\n    return [body, distance.lengthSq()];\n  }).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        body = _ref2[0],\n        distance = _ref2[1];\n\n    if (distance < nearbyThreshold || body.name === 'sun') {\n      acc[0].push(body);\n    } else {\n      acc[1].push(body);\n    }\n    return acc;\n  }, [[], []]);\n\n  var neighbours = partitioned[0];\n  var outliers = partitioned[1];\n  return [neighbours, outliers];\n};\n\n/**\n * Recenter the coordinate system on the focus being the 'center'.\n */\nCameraViewRenderer.prototype._adjustCoordinates = function (focus, position) {\n\n  if (!focus) return position.clone();\n\n  var coordinates = position.clone().sub(focus.derived.position);\n\n  return coordinates;\n};\n\n// Inherit from BaseRenderer\nObject.assign(CameraViewRenderer.prototype, _BaseRenderer2.default.prototype);\n\nexports.default = CameraViewRenderer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvQ2FtZXJhVmlld1JlbmRlcmVyLmpzP2ZlOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VSZW5kZXJlciBmcm9tICcuL0Jhc2VSZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge1xuICBBVVxufSBmcm9tICcuL0JvZGllcyc7XG5cbmNvbnN0IE9yYml0Q29udHJvbHMgPSByZXF1aXJlKCd0aHJlZS1vcmJpdC1jb250cm9scycpKFRIUkVFKTtcblxuZnVuY3Rpb24gQ2FtZXJhVmlld1JlbmRlcmVyKGNvbnRhaW5lciwgdGV4dHVyZUxvYWRlciwgbW9kZWxMb2FkZXIsIGNvbW1vblN0YXRlKSB7XG5cbiAgQmFzZVJlbmRlcmVyLmNhbGwodGhpcywgdGV4dHVyZUxvYWRlciwgbW9kZWxMb2FkZXIsIGNvbW1vblN0YXRlKTtcblxuICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICBhbHBoYTogZmFsc2VcbiAgfSk7XG4gIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gIHRoaXMuYm9keUNhY2hlID0gbmV3IE1hcCgpO1xufTtcblxuLyoqXG4gKiBVc2UgdGhpcyBsaWZleWNsZSBtZXRob2QgdG8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICovXG5DYW1lcmFWaWV3UmVuZGVyZXIucHJvdG90eXBlLnZpZXdEaWRMb2FkID0gZnVuY3Rpb24gKHNvbGFyU3lzdGVtKSB7XG5cbiAgLy8gRmluZCB0aGUgYm9keSB3ZSBhcmUgZm9jdXNpbmcgb25cbiAgY29uc3QgZm9jdXMgPSBzb2xhclN5c3RlbS5maW5kKHRoaXMuc3RhdGUuZm9jdXMpO1xuXG4gIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKCdibGFjaycpO1xuXG4gIC8vIEJhY2tncm91bmQgc3RhcnNcbiAgY29uc3Qgc2t5Ym94ID0gdGhpcy5fY3JlYXRlU2t5Qm94KCk7XG4gIHRoaXMuc2NlbmUuYWRkKHNreWJveCk7XG5cbiAgLy8gU2V0dXAgbGlnaHRcbiAgdGhpcy5saWdodFNvdXJjZSA9IHRoaXMuX3NldHVwTGlnaHRTb3VyY2VzKCk7XG5cbiAgbGV0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIGxldCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgLy8gaW5pdGlhbGl6ZSBjYW1lcmEgYW5kIHNjZW5lXG4gIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aWR0aCAvIGhlaWdodCwgMWUtMTAsIDIpO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWNlbnRlciB0aGUgY2FtZXJhXG4gICAqL1xuICBjb25zdCByZWNlbnRlciA9ICgpID0+IHtcbiAgICBsZXQgZm9jdXMgPSBzb2xhclN5c3RlbS5maW5kKHRoaXMuc3RhdGUuZm9jdXMpO1xuXG4gICAgaWYgKGZvY3VzLm5hbWUgPT09ICdzdW4nKSB7XG4gICAgICB0aGlzLmNhbWVyYS51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KDAsIC01ICogZm9jdXMuY29uc3RhbnRzLnJhZGl1cywgMCk7XG4gICAgICB0aGlzLmNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCBjYW1lcmEgYmVoaW5kIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2YgdGhlIHZlbG9jaXR5IHZlY3RvclxuICAgIGxldCBjYW1lcmFfcG9zaXRpb24gPSBmb2N1cy5kZXJpdmVkLnZlbG9jaXR5LmNsb25lKClcbiAgICAgIC5ub3JtYWxpemUoKVxuICAgICAgLm5lZ2F0ZSgpXG4gICAgICAubXVsdGlwbHlTY2FsYXIoNSAqIGZvY3VzLmNvbnN0YW50cy5yYWRpdXMpO1xuXG4gICAgbGV0IHByaW1hcnlfcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAuc3ViKHRoaXMuX2FkanVzdENvb3JkaW5hdGVzKGZvY3VzLCBmb2N1cy5wcmltYXJ5LmRlcml2ZWQucG9zaXRpb24pKTtcblxuICAgIC8vIEJhc2UgdGhlIGNhbWVyYSBVUCBkaXJlY3Rpb24gb2ZmIG9mIHRoZSB2ZWxvY2l0eSB2ZWN0b3IsIHJvdGF0ZWQgOTAgZGVncmVlcyB1cC5cbiAgICB0aGlzLmNhbWVyYS51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgIC5jb3B5KGZvY3VzLmRlcml2ZWQudmVsb2NpdHkpXG4gICAgICAuYXBwbHlBeGlzQW5nbGUocHJpbWFyeV9wb3NpdGlvbi5ub3JtYWxpemUoKSwgTWF0aC5QSSAvIDIpXG4gICAgICAubm9ybWFsaXplKCk7XG5cbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoY2FtZXJhX3Bvc2l0aW9uLngsIGNhbWVyYV9wb3NpdGlvbi55LCBjYW1lcmFfcG9zaXRpb24ueik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHdoZW4gd2UgY2hhbmdlIHRoZSBib2R5IGZvY3VzXG4gICAqL1xuICBjb25zdCBvbkZvY3VzID0gKGZvY3VzKSA9PiB7XG4gICAgLy8gRmlyc3QgZGlzcG9zZSBvZiBleGlzdGluZyBvcmJpdCBjb250cm9scyBpZiB0aGV5IGV4aXN0LlxuICAgIHRoaXMub3JiaXRDb250cm9scyAmJiB0aGlzLm9yYml0Q29udHJvbHMuZGlzcG9zZSgpO1xuXG4gICAgcmVjZW50ZXIoKTtcblxuICAgIHRoaXMub3JiaXRDb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMub3JiaXRDb250cm9scy5taW5EaXN0YW5jZSA9IGZvY3VzLmNvbnN0YW50cy5yYWRpdXMgKiAxLjU7XG4gICAgdGhpcy5vcmJpdENvbnRyb2xzLm1heERpc3RhbmNlID0gZm9jdXMuY29uc3RhbnRzLnJhZGl1cyAqIDEwMDtcbiAgfTtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKGV2ZW50KSA9PiB7XG4gICAgbGV0IGZvY3VzID0gc29sYXJTeXN0ZW0uZmluZChldmVudC5mb2N1cyk7XG4gICAgb25Gb2N1cyhmb2N1cyk7XG4gIH0pO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncmVjZW50ZXInLCAoZXZlbnQpID0+IHtcbiAgICByZWNlbnRlcigpO1xuICB9KVxuXG4gIGNvbnN0IG9uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUoaGVpZ2h0LCB0aGlzLmNhbWVyYS5mb3YpO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChldmVudCkgPT4ge1xuICAgIG9uV2luZG93UmVzaXplKCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBTZXR1cCBsaWZlY3ljbGUgbWV0aG9kcyBmb3IgcmVnaXN0ZXJpbmcvZGVyZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG5cbiAgdGhpcy52aWV3V2lsbEFwcGVhciA9ICgpID0+IHtcbiAgICBjb25zdCBmb2N1cyA9IHNvbGFyU3lzdGVtLmZpbmQodGhpcy5zdGF0ZS5mb2N1cyk7XG4gICAgb25Gb2N1cyhmb2N1cyk7XG4gICAgb25XaW5kb3dSZXNpemUoKTtcbiAgfTtcblxuICB0aGlzLnZpZXdXaWxsRGlzYXBwZWFyID0gKCkgPT4ge1xuICAgIHRoaXMub3JiaXRDb250cm9scy5kaXNwb3NlKCk7XG4gICAgdGhpcy5vcmJpdENvbnRyb2xzID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gc29sYXIgc3lzdGVtXG4gKi9cbkNhbWVyYVZpZXdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNvbGFyU3lzdGVtKSB7XG5cbiAgLy8gRmluZCB0aGUgYm9keSB3ZSBhcmUgZm9jdXNpbmcgb25cbiAgY29uc3QgZm9jdXMgPSBzb2xhclN5c3RlbS5maW5kKHRoaXMuc3RhdGUuZm9jdXMpO1xuICBjb25zdCBzdW4gPSBzb2xhclN5c3RlbS5maW5kKCdzdW4nKTtcblxuICAvLyBUcmFjayB0aGUgbGlnaHQgc291cmNlXG4gIHRoaXMuX2FkanVzdExpZ2h0U291cmNlKGZvY3VzLCBzdW4pO1xuXG4gIC8vIEZpbmQgYWxsIG9mIHRoZSBib2RpZXMgdGhhdCBhcmUgd2UgYXJlIGNvbmNlcm5lZCBhYm91dCBpbiBvdXIgcmVuZGVyIGxvb3BcbiAgY29uc3QgW25laWdoYm91cnMsIG91dGxpZXJzXSA9IHRoaXMuX2xvb2t1cE5lYXJieUJvZGllcyhmb2N1cywgc29sYXJTeXN0ZW0uYm9kaWVzKTtcblxuICAvLyBNYWtlIG9iamVjdHMgb3V0c2lkZSBvZiBvdXIgY3VycmVudCBzcGhlcmUgaW52aXNpYmxlICh0byBzYXZlIHJlc291cmNlcylcbiAgb3V0bGllcnMuZm9yRWFjaCgoYm9keSkgPT4ge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuYm9keUNhY2hlLmdldChib2R5Lm5hbWUpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICBjYWNoZWQudmlzaWJsZSA9IGZhbHNlO1xuICB9KTtcblxuICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9ucyBvZiBhbGwgb2Ygb3VyIGJvZGllc1xuICBuZWlnaGJvdXJzLmZvckVhY2goKGJvZHkpID0+IHtcblxuICAgIHRoaXMubG9hZFRocmVlQm9keShib2R5KVxuICAgICAgLnRoZW4oKHRocmVlQm9keSkgPT4ge1xuXG4gICAgICAgIHRocmVlQm9keS52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICBsZXQgZGVyaXZlZCA9IGJvZHkuZGVyaXZlZDtcblxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gdG8gcmUtY2VudGVyIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvbiB0aGUgZm9jdXNcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fYWRqdXN0Q29vcmRpbmF0ZXMoZm9jdXMsIGRlcml2ZWQucG9zaXRpb24pO1xuICAgICAgICB0aHJlZUJvZHkucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXG4gICAgICAgIC8vIEFkanVzdCBvcmJpdGFsIHRpbHQgYW5kIHJvdGF0aW9uLiAgRmlyc3QsIHJvdGF0ZSB0aGUgYm9keSB1c2luZyB0aGUgc2FtZVxuICAgICAgICAvLyBzZXQgb2YgdHJhbnNmb3JtcyB3ZSB1c2UgdG8gdHJhbnNmb3JtIHRvIGVjbGlwdGljLiAgVGhlbiwgYXBwbHkgdGhlIGF4aWFsIHRpbHQsXG4gICAgICAgIC8vIGFuZCB0aGUgYWNjdW11bGF0ZWQgcm90YXRpb24gYXJvdW5kIHRoZSBheGlzICgnZGVyaXZlZC5yb3RhdGlvbicpO1xuICAgICAgICB0aHJlZUJvZHkucm90YXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICB0aHJlZUJvZHkucm90YXRlWihkZXJpdmVkLm9tZWdhKTtcbiAgICAgICAgdGhyZWVCb2R5LnJvdGF0ZVgoZGVyaXZlZC5JKTtcbiAgICAgICAgdGhyZWVCb2R5LnJvdGF0ZVooZGVyaXZlZC5hcmd1bWVudFBlcmloZWxpb24pO1xuICAgICAgICB0aHJlZUJvZHkucm90YXRlT25BeGlzKG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLCBNYXRoLlBJIC8gMik7XG4gICAgICAgIHRocmVlQm9keS5yb3RhdGVPbkF4aXMobmV3IFRIUkVFLlZlY3RvcjMoMSwgMCwgMCksIC0oYm9keS5jb25zdGFudHMuYXhpYWxfdGlsdCB8fCAwKSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICB0aHJlZUJvZHkucm90YXRlWShkZXJpdmVkLnJvdGF0aW9uKTtcbiAgICAgIH0pO1xuICB9KTtcblxuICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG59O1xuXG5DYW1lcmFWaWV3UmVuZGVyZXIucHJvdG90eXBlLmxvYWRUaHJlZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuXG4gIC8vIENhY2hlIG91ciBib2RpZXNcbiAgY29uc3QgY2FjaGVkID0gdGhpcy5ib2R5Q2FjaGUuZ2V0KGJvZHkubmFtZSk7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XG4gIH1cblxuICBsZXQgbWF0ZXJpYWw7XG4gIGlmIChib2R5Lm5hbWUgPT09ICdzdW4nKSB7XG4gICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICd5ZWxsb3cnXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoKTtcbiAgfVxuXG4gIGNvbnN0IHRocmVlQm9keSA9IG5ldyBUSFJFRS5NZXNoKFxuICAgIG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShib2R5LmNvbnN0YW50cy5yYWRpdXMsIDEyOCwgMTI4KSxcbiAgICBtYXRlcmlhbCk7XG5cbiAgdGhyZWVCb2R5LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICB0aHJlZUJvZHkuY2FzdFNoYWRvdyA9IHRydWU7XG5cbiAgdGhpcy5zY2VuZS5hZGQodGhyZWVCb2R5KTtcbiAgdGhpcy5ib2R5Q2FjaGUuc2V0KGJvZHkubmFtZSwgdGhyZWVCb2R5KTtcblxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZXNvbHZlKHRocmVlQm9keSkpLFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgY29uc3QgdGV4dHVyZXNUb0xvYWQgPSBbYm9keS5uYW1lLCBib2R5Lm5hbWUgKyAnYnVtcCcsIGJvZHkubmFtZSArICdzcGVjJ107XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZFRleHR1cmVzKHRleHR1cmVzVG9Mb2FkKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAodGV4dHVyZXMpID0+IHtcblxuICAgICAgICAgICAgaWYgKHRleHR1cmVzLmhhcyhib2R5Lm5hbWUgKyAnYnVtcCcpKSB7XG4gICAgICAgICAgICAgIG1hdGVyaWFsLmJ1bXBNYXAgPSB0ZXh0dXJlcy5nZXQoYm9keS5uYW1lICsgJ2J1bXAnKTtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuYnVtcFNjYWxlID0gMTAwMDAwIC8gQVU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0dXJlcy5oYXMoYm9keS5uYW1lICsgJ3NwZWMnKSkge1xuICAgICAgICAgICAgICBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRleHR1cmVzLmdldChib2R5Lm5hbWUgKyAnc3BlYycpO1xuICAgICAgICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciA9IG5ldyBUSFJFRS5Db2xvcignZ3JleScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dHVyZXMuaGFzKGJvZHkubmFtZSkpIHtcbiAgICAgICAgICAgICAgLy8gUmVkdWNlIGhhcnNoIGdsYXJlIGVmZmVjdCBvZiB0aGUgbGlnaHQgc291cmNlIChkZWZhdWx0IDMwIC0+IDEpO1xuICAgICAgICAgICAgICBtYXRlcmlhbC5tYXAgPSB0ZXh0dXJlcy5nZXQoYm9keS5uYW1lKTtcbiAgICAgICAgICAgICAgbWF0ZXJpYWwuc2hpbmluZXNzID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aHJlZUJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KVxuICBdKTtcblxufTtcblxuQ2FtZXJhVmlld1JlbmRlcmVyLnByb3RvdHlwZS5fYWRqdXN0TGlnaHRTb3VyY2UgPSBmdW5jdGlvbiAoZm9jdXMsIHN1bikge1xuXG4gIGNvbnN0IGxpZ2h0ID0gdGhpcy5saWdodFNvdXJjZTtcbiAgY29uc3QgbGlnaHRQb3NpdGlvbiA9IHRoaXMuX2FkanVzdENvb3JkaW5hdGVzKGZvY3VzLCBzdW4uZGVyaXZlZC5wb3NpdGlvbik7XG5cbiAgbGlnaHQucG9zaXRpb24uc2V0KGxpZ2h0UG9zaXRpb24ueCwgbGlnaHRQb3NpdGlvbi55LCBsaWdodFBvc2l0aW9uLnopO1xuXG4gIC8vIEZyYW1lIHRoZSBzaGFkb3cgYm94IGFwcHJvcHJpYXRlbHlcbiAgaWYgKGZvY3VzLnByaW1hcnkgJiYgZm9jdXMucHJpbWFyeS5uYW1lICE9PSAnc3VuJykge1xuICAgIGxldCBsaWdodEJveExlbmd0aCA9IGZvY3VzLnByaW1hcnkuY29uc3RhbnRzLnJhZGl1cztcbiAgICBsaWdodC5zaGFkb3cuY2FtZXJhLm5lYXIgPSAwLjk5ICogZm9jdXMucHJpbWFyeS5kZXJpdmVkLnBvc2l0aW9uLmxlbmd0aCgpO1xuICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEuZmFyID0gMS4wMSAqIGZvY3VzLnByaW1hcnkuZGVyaXZlZC5wb3NpdGlvbi5sZW5ndGgoKTtcbiAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmxlZnQgPSAtbGlnaHRCb3hMZW5ndGg7XG4gICAgbGlnaHQuc2hhZG93LmNhbWVyYS5yaWdodCA9IGxpZ2h0Qm94TGVuZ3RoO1xuICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEudG9wID0gbGlnaHRCb3hMZW5ndGg7XG4gICAgbGlnaHQuc2hhZG93LmNhbWVyYS5ib3R0b20gPSAtbGlnaHRCb3hMZW5ndGg7XG4gIH1cbn07XG5cbkNhbWVyYVZpZXdSZW5kZXJlci5wcm90b3R5cGUuX2xvb2t1cE5lYXJieUJvZGllcyA9IGZ1bmN0aW9uIChmb2N1cywgYm9kaWVzKSB7XG5cbiAgY29uc3QgbmVhcmJ5VGhyZXNob2xkID0gMC4wNTtcbiAgY29uc3QgcGFydGl0aW9uZWQgPSBib2RpZXMubWFwKChib2R5KSA9PiB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgLnN1YlZlY3RvcnMoZm9jdXMuZGVyaXZlZC5wb3NpdGlvbiwgYm9keS5kZXJpdmVkLnBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBbYm9keSwgZGlzdGFuY2UubGVuZ3RoU3EoKV07XG4gICAgfSlcbiAgICAucmVkdWNlKChhY2MsIFtib2R5LCBkaXN0YW5jZV0pID0+IHtcbiAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJieVRocmVzaG9sZCB8fCBib2R5Lm5hbWUgPT09ICdzdW4nKSB7XG4gICAgICAgIGFjY1swXS5wdXNoKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjWzFdLnB1c2goYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtcbiAgICAgIFtdLFxuICAgICAgW11cbiAgICBdKTtcblxuICBjb25zdCBuZWlnaGJvdXJzID0gcGFydGl0aW9uZWRbMF07XG4gIGNvbnN0IG91dGxpZXJzID0gcGFydGl0aW9uZWRbMV07XG4gIHJldHVybiBbbmVpZ2hib3Vycywgb3V0bGllcnNdO1xufVxuXG4vKipcbiAqIFJlY2VudGVyIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvbiB0aGUgZm9jdXMgYmVpbmcgdGhlICdjZW50ZXInLlxuICovXG5DYW1lcmFWaWV3UmVuZGVyZXIucHJvdG90eXBlLl9hZGp1c3RDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChmb2N1cywgcG9zaXRpb24pIHtcblxuICBpZiAoIWZvY3VzKVxuICAgIHJldHVybiBwb3NpdGlvbi5jbG9uZSgpO1xuXG4gIGxldCBjb29yZGluYXRlcyA9IHBvc2l0aW9uLmNsb25lKClcbiAgICAuc3ViKGZvY3VzLmRlcml2ZWQucG9zaXRpb24pO1xuXG4gIHJldHVybiBjb29yZGluYXRlcztcbn07XG5cbi8vIEluaGVyaXQgZnJvbSBCYXNlUmVuZGVyZXJcbk9iamVjdC5hc3NpZ24oQ2FtZXJhVmlld1JlbmRlcmVyLnByb3RvdHlwZSwgQmFzZVJlbmRlcmVyLnByb3RvdHlwZSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYVZpZXdSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL0NhbWVyYVZpZXdSZW5kZXJlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEFAULT_FOCUS = 'earth';\n\nvar CommonState = function CommonState() {\n  var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_FOCUS;\n\n  _classCallCheck(this, CommonState);\n\n  this.focus = focus;\n};\n\nexports.default = CommonState;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvQ29tbW9uU3RhdGUuanM/ZWY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBERUZBVUxUX0ZPQ1VTID0gJ2VhcnRoJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tbW9uU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihmb2N1cyA9IERFRkFVTFRfRk9DVVMpIHtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL0NvbW1vblN0YXRlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _BaseRenderer = __webpack_require__(5);\n\nvar _BaseRenderer2 = _interopRequireDefault(_BaseRenderer);\n\nvar _Bodies = __webpack_require__(2);\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OrbitControls = __webpack_require__(4)(THREE);\n\nvar TRAJECTORY_SCALE = 2;\nvar SHOW_VELOCITY_VECTORS = false;\n\nvar PLANET_COLOURS = {\n  \"sun\": \"yellow\",\n  \"mercury\": \"silver\",\n  \"venus\": \"green\",\n  \"earth\": \"skyblue\",\n  \"moon\": \"gray\",\n  \"mars\": \"red\",\n  \"jupiter\": \"orange\",\n  \"saturn\": \"tan\",\n  \"uranus\": \"skyblue\",\n  \"neptune\": \"lightblue\",\n  \"pluto\": \"silver\"\n};\n\nfunction OrbitalMapRenderer(container, textureLoader, modelLoader, commonState) {\n\n  _BaseRenderer2.default.call(this, textureLoader, modelLoader, commonState);\n\n  this.container = container;\n  this.renderer = new THREE.WebGLRenderer();\n  this.renderer.setPixelRatio(window.devicePixelRatio);\n  container.appendChild(this.renderer.domElement);\n\n  this.scene = new THREE.Scene();\n  this.bodyMap = new Map();\n};\n\nOrbitalMapRenderer.prototype.viewDidLoad = function (solarSystem) {\n  var _this = this;\n\n  return Promise.race([Promise.resolve()]).then(function () {\n\n    var width = window.innerWidth;\n    var height = window.innerHeight;\n\n    _this.camera = new THREE.PerspectiveCamera(45, width / height, 1e-10, 2);\n    _this.camera.up = new THREE.Vector3(0, 0, 1);\n\n    var skybox = _this._createSkyBox();\n    _this.scene.add(skybox);\n\n    var recenter = function recenter() {\n      var focus = solarSystem.find(_this.state.focus);\n\n      // For all bodies (except sun), use the size of the orbiting radius for\n      // the camera position.\n      var cameraDistance = void 0;\n      if (focus.name === 'sun') {\n        cameraDistance = 100;\n      } else {\n        var position = focus.derived.position;\n        var primary_position = focus.primary.derived.position;\n        cameraDistance = 10 * primary_position.distanceTo(position);\n      }\n\n      _this.orbitControls.reset();\n      _this.camera.position.set(0, 0, cameraDistance);\n      _this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n    };\n\n    _this.addEventListener('click', function (event) {\n      var location = event.location;\n\n      // Do a hit-test check for all planets\n      var found = Array.from(_this.bodyMap.entries()).map(function (entry) {\n\n        var id = entry[0];\n        var objects = entry[1];\n\n        var position = objects.body.position.clone();\n        var projection = position.project(_this.camera);\n        var body = new THREE.Vector2(projection.x * width, projection.y * height);\n\n        return {\n          id: id,\n          distance: body.distanceTo(location)\n        };\n      }).sort(function (left, right) {\n        return left.distance - right.distance;\n      }).find(function (_ref) {\n        var id = _ref.id,\n            distance = _ref.distance;\n        return distance < 50;\n      });\n\n      // Update the focus to the target planet\n      if (found) {\n        _this.state.focus = found.id;\n      }\n    });\n\n    _this.addEventListener('focus', function (event) {\n      recenter();\n    });\n\n    _this.addEventListener('recenter', function (event) {\n      recenter();\n    });\n\n    var onWindowResize = _this._onWindowResize(height, _this.camera.fov);\n    _this.addEventListener('resize', function (event) {\n      onWindowResize();\n    });\n\n    _this.viewWillAppear = function () {\n      this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.orbitControls.maxDistance = 100 * TRAJECTORY_SCALE;\n      this.orbitControls.dollySpeed = 2.0;\n      onWindowResize();\n      recenter();\n    };\n\n    _this.viewWillDisappear = function () {\n      this.orbitControls.dispose();\n      this.orbitControls = null;\n    };\n\n    // Maintain a mapping from planet -> THREE object representing the planet\n    // This will allow us to update the existing THREE object on each iteration\n    // of the render loop.\n    solarSystem.bodies.forEach(function (body) {\n\n      _this.bodyMap.set(body.name, {});\n\n      var threeBody = new THREE.Mesh(new THREE.SphereGeometry(body.constants.radius, 32, 32), new THREE.MeshBasicMaterial({\n        color: PLANET_COLOURS[body.name] || 'white'\n      }));\n\n      var periapsis = new THREE.Mesh(new THREE.SphereGeometry(0.01, 32, 32), new THREE.MeshBasicMaterial({\n        color: 'purple'\n      }));\n\n      var apoapsis = new THREE.Mesh(new THREE.SphereGeometry(0.01, 32, 32), new THREE.MeshBasicMaterial({\n        color: 'aqua'\n      }));\n\n      _this.scene.add(threeBody);\n      //this.scene.add(periapsis);\n      //this.scene.add(apoapsis);\n\n      if (body.name !== 'sun') {\n\n        var trajectory = new THREE.Line(_this._createTrajectoryGeometry(), new THREE.LineBasicMaterial({\n          color: PLANET_COLOURS[body.name] || 'white'\n        }));\n\n        _this.scene.add(trajectory);\n        _this.bodyMap.get(body.name).trajectory = trajectory;\n        _this.bodyMap.get(body.name).trajectoryVertices = Array.from(trajectory.geometry.attributes.position.array);\n        _this.bodyMap.get(body.name).trajectoryVerticesDirty = [];\n      }\n\n      Object.assign(_this.bodyMap.get(body.name), {\n        body: threeBody,\n        periapsis: periapsis,\n        apoapsis: apoapsis\n      });\n    });\n\n    return Promise.resolve();\n  });\n};\n\nOrbitalMapRenderer.prototype.render = function (solarSystem) {\n  var _this2 = this;\n\n  // Find the current user focus\n  var focus = solarSystem.find(this.state.focus);\n\n  // Locate primary body, sun\n  var sun = solarSystem.find('sun');\n\n  solarSystem.bodies.forEach(function (body) {\n\n    var bodyMap = _this2.bodyMap.get(body.name);\n    var threeBody = bodyMap.body;\n    var threePeriapsis = bodyMap.periapsis;\n    var threeApoapsis = bodyMap.apoapsis;\n    var derived = body.derived;\n\n    // Adjust position to re-center the coordinate system on the focus\n    var position = _this2._adjustCoordinates(focus, derived.position);\n    // let apoapsis = this._adjustCoordinates(focus, derived.apoapsis);\n    // let periapsis = this._adjustCoordinates(focus, derived.periapsis);\n\n    threeBody.position.set(position.x, position.y, position.z);\n\n    if (SHOW_VELOCITY_VECTORS) {\n      bodyMap.arrowHelper && _this2.scene.remove(bodyMap.arrowHelper);\n      var arrowHelper = new THREE.ArrowHelper(derived.velocity.clone().normalize(), position, 1, 0xffff00);\n      _this2.scene.add(arrowHelper);\n      bodyMap.arrowHelper = arrowHelper;\n    }\n\n    // threePeriapsis.position.set(periapsis.x, periapsis.y, periapsis.z);\n    // threeApoapsis.position.set(apoapsis.x, apoapsis.y, apoapsis.z);\n\n    _this2._updateTrajectory(focus, body);\n    _this2._scaleBody(body);\n  });\n\n  this.renderer.render(this.scene, this.camera);\n};\n\n/**\n * Recenter the coordinate system on the focus being the 'center'.\n */\nOrbitalMapRenderer.prototype._adjustCoordinates = function (focus, position) {\n\n  if (!focus) return position.clone();\n\n  var coordinates = position.clone().sub(focus.derived.position).multiplyScalar(TRAJECTORY_SCALE);\n\n  return coordinates;\n};\n\nOrbitalMapRenderer.prototype._scaleBody = function (body) {\n\n  var bodyMap = this.bodyMap.get(body.name);\n  var threeBody = bodyMap.body;\n  var trajectory = bodyMap.trajectory;\n  var cameraDistance = this.camera.position.distanceTo(threeBody.position);\n\n  var scale = Math.max(0.005 * cameraDistance, body.constants.radius) / body.constants.radius;\n  threeBody.scale.set(scale, scale, scale);\n\n  // Allow more 'space' between large bodies and their satellites\n  trajectory && trajectory.scale.set(trajectory.scale.x * TRAJECTORY_SCALE, trajectory.scale.y * TRAJECTORY_SCALE, 1);\n};\n\nOrbitalMapRenderer.prototype._updateTrajectory = function (focus, body) {\n\n  if (body.name === 'sun') return;\n\n  // Redraw the trajectory for this body\n  var bodyMap = this.bodyMap.get(body.name);\n  var trajectory = bodyMap.trajectory;\n  var trajectoryVertices = bodyMap.trajectoryVertices;\n  var trajectoryVerticesDirty = bodyMap.trajectoryVerticesDirty;\n\n  var derived = body.derived;\n  var position_in_plane = body.derived.position_in_plane;\n  var center_in_plane = body.derived.center_in_plane;\n  var semiMajorAxis = derived.semiMajorAxis;\n  var semiMinorAxis = derived.semiMinorAxis;\n  var center = this._adjustCoordinates(focus, derived.center);\n\n  var scaledPosition = new THREE.Vector3().copy(position_in_plane).sub(center_in_plane);\n  scaledPosition.multiply(new THREE.Vector3(1 / semiMajorAxis, 1 / semiMinorAxis, 1));\n\n  // Workaround for natural limitations of drawing arcs using straight line segments;\n  // you inherently cannot track a planet moving in an ellipse between the planet\n  // will always be between two vertices.  This code attempts to manually 'insert'\n  // a vertex that corresponds to the planets location.\n  // This fixes the issue where the trajectory would wobble in and out of the planet\n\n  var geometry = trajectory.geometry;\n  var positions = geometry.attributes.position.array;\n  var range = positions.length / 3;\n  var verticesToChange = 1;\n  var verticesToTest = [];\n\n  for (var i = 0; i < range; i++) {\n    var offset = i * 3;\n    verticesToTest.push(new THREE.Vector3(trajectoryVertices[offset], trajectoryVertices[offset + 1], trajectoryVertices[offset + 2]));\n  };\n\n  // Find the vertex that is closest to the planets position\n  var sorted = verticesToTest.map(function (vertex, idx) {\n    return [vertex.distanceTo(scaledPosition), vertex, idx];\n  }).sort(function (left, right) {\n    return left[0] - right[0];\n  });\n\n  trajectoryVerticesDirty.forEach(function (idx) {\n    var offset = idx * 3;\n    positions[offset] = trajectoryVertices[offset];\n    positions[offset + 1] = trajectoryVertices[offset + 1];\n    positions[offset + 2] = trajectoryVertices[offset + 2];\n  });\n  var updatedDirtyVertices = [];\n\n  // Overwrite the closest vertices with the planets actual position.  This will\n  // ensure that a vertex for our trajectory is always located at the planets\n  // location.\n  sorted.slice(0, verticesToChange).forEach(function (element) {\n    var vertex = element[1];\n    var offset = element[2] * 3;\n    positions[offset] = scaledPosition.x;\n    positions[offset + 1] = scaledPosition.y;\n    positions[offset + 2] = scaledPosition.z;\n\n    updatedDirtyVertices.push(element[2]);\n  });\n\n  // Set new value of dirty vertices;\n  bodyMap.trajectoryVerticesDirty = updatedDirtyVertices;\n\n  // Signal that this geometry needs a redraw\n  geometry.attributes.position.needsUpdate = true;\n\n  // Finally, apply scale/rotation/translation to the trajectory to place it\n  // into the correct orbit\n  trajectory.scale.set(1, 1, 1);\n  trajectory.rotation.set(0, 0, 0);\n  trajectory.position.set(0, 0, 0);\n\n  // Now adjust the trajectory to its actual orientation\n  trajectory.translateX(center.x);\n  trajectory.translateY(center.y);\n  trajectory.translateZ(center.z);\n  trajectory.rotateZ(derived.omega);\n  trajectory.rotateX(derived.I);\n  trajectory.rotateZ(derived.argumentPerihelion);\n  trajectory.scale.set(semiMajorAxis, semiMinorAxis, 1);\n};\n\nOrbitalMapRenderer.prototype._createTrajectoryGeometry = function () {\n\n  var NUM_POINTS = 256;\n\n  // Create the trajectory using a strandard ellipse curve that will\n  // eventually scale/rotate/translate into the correct orbit path during\n  // the render loop.\n  var pointsGeometry = new THREE.Path(new THREE.EllipseCurve(0, 0, // ax, aY\n  1, 1, // xRadius, yRadius\n  0, 2 * Math.PI, // aStartAngle, aEndAngle\n  false, // aClockwise\n  0 // aRotation\n  ).getPoints(NUM_POINTS)).createPointsGeometry(NUM_POINTS);\n  var bufferGeometry = new THREE.BufferGeometry();\n  var vertices = [];\n  for (var i = 0; i < pointsGeometry.vertices.length; i++) {\n    vertices.push(pointsGeometry.vertices[i].x, pointsGeometry.vertices[i].y, pointsGeometry.vertices[i].z);\n  }\n\n  bufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\n  return bufferGeometry;\n};\n\nObject.assign(OrbitalMapRenderer.prototype, _BaseRenderer2.default.prototype);\n\nexports.default = OrbitalMapRenderer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvT3JiaXRhbE1hcFJlbmRlcmVyLmpzPzVmYzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VSZW5kZXJlciBmcm9tICcuL0Jhc2VSZW5kZXJlcic7XG5pbXBvcnQge1xuICBGSVhFRF9UWVBFLFxuICBQSFlTSUNTX1RZUEUsXG4gIEFTVEVST0lEX1RZUEVcbn0gZnJvbSAnLi9Cb2RpZXMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuY29uc3QgT3JiaXRDb250cm9scyA9IHJlcXVpcmUoJ3RocmVlLW9yYml0LWNvbnRyb2xzJykoVEhSRUUpO1xuXG5jb25zdCBUUkFKRUNUT1JZX1NDQUxFID0gMjtcbmNvbnN0IFNIT1dfVkVMT0NJVFlfVkVDVE9SUyA9IGZhbHNlO1xuXG5jb25zdCBQTEFORVRfQ09MT1VSUyA9IHtcbiAgXCJzdW5cIjogXCJ5ZWxsb3dcIixcbiAgXCJtZXJjdXJ5XCI6IFwic2lsdmVyXCIsXG4gIFwidmVudXNcIjogXCJncmVlblwiLFxuICBcImVhcnRoXCI6IFwic2t5Ymx1ZVwiLFxuICBcIm1vb25cIjogXCJncmF5XCIsXG4gIFwibWFyc1wiOiBcInJlZFwiLFxuICBcImp1cGl0ZXJcIjogXCJvcmFuZ2VcIixcbiAgXCJzYXR1cm5cIjogXCJ0YW5cIixcbiAgXCJ1cmFudXNcIjogXCJza3libHVlXCIsXG4gIFwibmVwdHVuZVwiOiBcImxpZ2h0Ymx1ZVwiLFxuICBcInBsdXRvXCI6IFwic2lsdmVyXCJcbn07XG5cbmZ1bmN0aW9uIE9yYml0YWxNYXBSZW5kZXJlcihjb250YWluZXIsIHRleHR1cmVMb2FkZXIsIG1vZGVsTG9hZGVyLCBjb21tb25TdGF0ZSkge1xuXG4gIEJhc2VSZW5kZXJlci5jYWxsKHRoaXMsIHRleHR1cmVMb2FkZXIsIG1vZGVsTG9hZGVyLCBjb21tb25TdGF0ZSk7XG5cbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcblxuICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gIHRoaXMuYm9keU1hcCA9IG5ldyBNYXAoKTtcbn07XG5cbk9yYml0YWxNYXBSZW5kZXJlci5wcm90b3R5cGUudmlld0RpZExvYWQgPSBmdW5jdGlvbiAoc29sYXJTeXN0ZW0pIHtcblxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLFxuICAgIF0pXG4gICAgLnRoZW4oKCkgPT4ge1xuXG4gICAgICBsZXQgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aWR0aCAvIGhlaWdodCwgMWUtMTAsIDIpO1xuICAgICAgdGhpcy5jYW1lcmEudXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcblxuICAgICAgY29uc3Qgc2t5Ym94ID0gdGhpcy5fY3JlYXRlU2t5Qm94KCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChza3lib3gpO1xuXG4gICAgICBjb25zdCByZWNlbnRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzb2xhclN5c3RlbS5maW5kKHRoaXMuc3RhdGUuZm9jdXMpO1xuXG4gICAgICAgIC8vIEZvciBhbGwgYm9kaWVzIChleGNlcHQgc3VuKSwgdXNlIHRoZSBzaXplIG9mIHRoZSBvcmJpdGluZyByYWRpdXMgZm9yXG4gICAgICAgIC8vIHRoZSBjYW1lcmEgcG9zaXRpb24uXG4gICAgICAgIGxldCBjYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgaWYgKGZvY3VzLm5hbWUgPT09ICdzdW4nKSB7XG4gICAgICAgICAgY2FtZXJhRGlzdGFuY2UgPSAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gZm9jdXMuZGVyaXZlZC5wb3NpdGlvbjtcbiAgICAgICAgICBsZXQgcHJpbWFyeV9wb3NpdGlvbiA9IGZvY3VzLnByaW1hcnkuZGVyaXZlZC5wb3NpdGlvbjtcbiAgICAgICAgICBjYW1lcmFEaXN0YW5jZSA9IDEwICogcHJpbWFyeV9wb3NpdGlvbi5kaXN0YW5jZVRvKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3JiaXRDb250cm9scy5yZXNldCgpO1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgY2FtZXJhRGlzdGFuY2UpO1xuICAgICAgICB0aGlzLmNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGV2ZW50LmxvY2F0aW9uO1xuXG4gICAgICAgIC8vIERvIGEgaGl0LXRlc3QgY2hlY2sgZm9yIGFsbCBwbGFuZXRzXG4gICAgICAgIGNvbnN0IGZvdW5kID0gQXJyYXkuZnJvbSh0aGlzLmJvZHlNYXAuZW50cmllcygpKVxuICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnlbMF07XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gZW50cnlbMV07XG5cbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gb2JqZWN0cy5ib2R5LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gcG9zaXRpb24ucHJvamVjdCh0aGlzLmNhbWVyYSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbmV3IFRIUkVFLlZlY3RvcjIocHJvamVjdGlvbi54ICogd2lkdGgsIHByb2plY3Rpb24ueSAqIGhlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZGlzdGFuY2U6IGJvZHkuZGlzdGFuY2VUbyhsb2NhdGlvbilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc29ydCgobGVmdCwgcmlnaHQpID0+IGxlZnQuZGlzdGFuY2UgLSByaWdodC5kaXN0YW5jZSlcbiAgICAgICAgICAuZmluZCgoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH0pID0+IGRpc3RhbmNlIDwgNTApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZm9jdXMgdG8gdGhlIHRhcmdldCBwbGFuZXRcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5mb2N1cyA9IGZvdW5kLmlkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChldmVudCkgPT4ge1xuICAgICAgICByZWNlbnRlcigpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncmVjZW50ZXInLCAoZXZlbnQpID0+IHtcbiAgICAgICAgcmVjZW50ZXIoKTtcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG9uV2luZG93UmVzaXplID0gdGhpcy5fb25XaW5kb3dSZXNpemUoaGVpZ2h0LCB0aGlzLmNhbWVyYS5mb3YpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgb25XaW5kb3dSZXNpemUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnZpZXdXaWxsQXBwZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgdGhpcy5vcmJpdENvbnRyb2xzLm1heERpc3RhbmNlID0gMTAwICogVFJBSkVDVE9SWV9TQ0FMRTtcbiAgICAgICAgdGhpcy5vcmJpdENvbnRyb2xzLmRvbGx5U3BlZWQgPSAyLjA7XG4gICAgICAgIG9uV2luZG93UmVzaXplKCk7XG4gICAgICAgIHJlY2VudGVyKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnZpZXdXaWxsRGlzYXBwZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9yYml0Q29udHJvbHMgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gTWFpbnRhaW4gYSBtYXBwaW5nIGZyb20gcGxhbmV0IC0+IFRIUkVFIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBsYW5ldFxuICAgICAgLy8gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgVEhSRUUgb2JqZWN0IG9uIGVhY2ggaXRlcmF0aW9uXG4gICAgICAvLyBvZiB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICBzb2xhclN5c3RlbS5ib2RpZXMuZm9yRWFjaCgoYm9keSkgPT4ge1xuXG4gICAgICAgIHRoaXMuYm9keU1hcC5zZXQoYm9keS5uYW1lLCB7fSk7XG5cbiAgICAgICAgY29uc3QgdGhyZWVCb2R5ID0gbmV3IFRIUkVFLk1lc2gobmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KGJvZHkuY29uc3RhbnRzLnJhZGl1cywgMzIsIDMyKSxcbiAgICAgICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IFBMQU5FVF9DT0xPVVJTW2JvZHkubmFtZV0gfHwgJ3doaXRlJ1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBwZXJpYXBzaXMgPSBuZXcgVEhSRUUuTWVzaChuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wMSwgMzIsIDMyKSxcbiAgICAgICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6ICdwdXJwbGUnXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IGFwb2Fwc2lzID0gbmV3IFRIUkVFLk1lc2gobmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuMDEsIDMyLCAzMiksXG4gICAgICAgICAgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiAnYXF1YSdcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5zY2VuZS5hZGQodGhyZWVCb2R5KTtcbiAgICAgICAgLy90aGlzLnNjZW5lLmFkZChwZXJpYXBzaXMpO1xuICAgICAgICAvL3RoaXMuc2NlbmUuYWRkKGFwb2Fwc2lzKTtcblxuICAgICAgICBpZiAoYm9keS5uYW1lICE9PSAnc3VuJykge1xuXG4gICAgICAgICAgY29uc3QgdHJhamVjdG9yeSA9IG5ldyBUSFJFRS5MaW5lKFxuICAgICAgICAgICAgdGhpcy5fY3JlYXRlVHJhamVjdG9yeUdlb21ldHJ5KCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICBjb2xvcjogUExBTkVUX0NPTE9VUlNbYm9keS5uYW1lXSB8fCAnd2hpdGUnXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICB0aGlzLnNjZW5lLmFkZCh0cmFqZWN0b3J5KTtcbiAgICAgICAgICB0aGlzLmJvZHlNYXAuZ2V0KGJvZHkubmFtZSlcbiAgICAgICAgICAgIC50cmFqZWN0b3J5ID0gdHJhamVjdG9yeTtcbiAgICAgICAgICB0aGlzLmJvZHlNYXAuZ2V0KGJvZHkubmFtZSlcbiAgICAgICAgICAgIC50cmFqZWN0b3J5VmVydGljZXMgPSBBcnJheS5mcm9tKHRyYWplY3RvcnkuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSk7XG4gICAgICAgICAgdGhpcy5ib2R5TWFwLmdldChib2R5Lm5hbWUpXG4gICAgICAgICAgICAudHJhamVjdG9yeVZlcnRpY2VzRGlydHkgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5ib2R5TWFwLmdldChib2R5Lm5hbWUpLCB7XG4gICAgICAgICAgYm9keTogdGhyZWVCb2R5LFxuICAgICAgICAgIHBlcmlhcHNpczogcGVyaWFwc2lzLFxuICAgICAgICAgIGFwb2Fwc2lzOiBhcG9hcHNpcyxcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSk7XG59O1xuXG5PcmJpdGFsTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzb2xhclN5c3RlbSkge1xuXG4gIC8vIEZpbmQgdGhlIGN1cnJlbnQgdXNlciBmb2N1c1xuICBjb25zdCBmb2N1cyA9IHNvbGFyU3lzdGVtLmZpbmQodGhpcy5zdGF0ZS5mb2N1cyk7XG5cbiAgLy8gTG9jYXRlIHByaW1hcnkgYm9keSwgc3VuXG4gIGNvbnN0IHN1biA9IHNvbGFyU3lzdGVtLmZpbmQoJ3N1bicpO1xuXG4gIHNvbGFyU3lzdGVtLmJvZGllcy5mb3JFYWNoKChib2R5KSA9PiB7XG5cbiAgICBsZXQgYm9keU1hcCA9IHRoaXMuYm9keU1hcC5nZXQoYm9keS5uYW1lKTtcbiAgICBsZXQgdGhyZWVCb2R5ID0gYm9keU1hcC5ib2R5O1xuICAgIGxldCB0aHJlZVBlcmlhcHNpcyA9IGJvZHlNYXAucGVyaWFwc2lzO1xuICAgIGxldCB0aHJlZUFwb2Fwc2lzID0gYm9keU1hcC5hcG9hcHNpcztcbiAgICBsZXQgZGVyaXZlZCA9IGJvZHkuZGVyaXZlZDtcblxuICAgIC8vIEFkanVzdCBwb3NpdGlvbiB0byByZS1jZW50ZXIgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9uIHRoZSBmb2N1c1xuICAgIGxldCBwb3NpdGlvbiA9IHRoaXMuX2FkanVzdENvb3JkaW5hdGVzKGZvY3VzLCBkZXJpdmVkLnBvc2l0aW9uKTtcbiAgICAvLyBsZXQgYXBvYXBzaXMgPSB0aGlzLl9hZGp1c3RDb29yZGluYXRlcyhmb2N1cywgZGVyaXZlZC5hcG9hcHNpcyk7XG4gICAgLy8gbGV0IHBlcmlhcHNpcyA9IHRoaXMuX2FkanVzdENvb3JkaW5hdGVzKGZvY3VzLCBkZXJpdmVkLnBlcmlhcHNpcyk7XG5cbiAgICB0aHJlZUJvZHkucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXG4gICAgaWYgKFNIT1dfVkVMT0NJVFlfVkVDVE9SUykge1xuICAgICAgYm9keU1hcC5hcnJvd0hlbHBlciAmJiB0aGlzLnNjZW5lLnJlbW92ZShib2R5TWFwLmFycm93SGVscGVyKTtcbiAgICAgIGxldCBhcnJvd0hlbHBlciA9IG5ldyBUSFJFRS5BcnJvd0hlbHBlcihkZXJpdmVkLnZlbG9jaXR5LmNsb25lKClcbiAgICAgICAgLm5vcm1hbGl6ZSgpLCBwb3NpdGlvbiwgMSwgMHhmZmZmMDApO1xuICAgICAgdGhpcy5zY2VuZS5hZGQoYXJyb3dIZWxwZXIpO1xuICAgICAgYm9keU1hcC5hcnJvd0hlbHBlciA9IGFycm93SGVscGVyO1xuICAgIH1cblxuICAgIC8vIHRocmVlUGVyaWFwc2lzLnBvc2l0aW9uLnNldChwZXJpYXBzaXMueCwgcGVyaWFwc2lzLnksIHBlcmlhcHNpcy56KTtcbiAgICAvLyB0aHJlZUFwb2Fwc2lzLnBvc2l0aW9uLnNldChhcG9hcHNpcy54LCBhcG9hcHNpcy55LCBhcG9hcHNpcy56KTtcblxuICAgIHRoaXMuX3VwZGF0ZVRyYWplY3RvcnkoZm9jdXMsIGJvZHkpO1xuICAgIHRoaXMuX3NjYWxlQm9keShib2R5KTtcbiAgfSk7XG5cbiAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xufTtcblxuLyoqXG4gKiBSZWNlbnRlciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb24gdGhlIGZvY3VzIGJlaW5nIHRoZSAnY2VudGVyJy5cbiAqL1xuT3JiaXRhbE1hcFJlbmRlcmVyLnByb3RvdHlwZS5fYWRqdXN0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZm9jdXMsIHBvc2l0aW9uKSB7XG5cbiAgaWYgKCFmb2N1cylcbiAgICByZXR1cm4gcG9zaXRpb24uY2xvbmUoKTtcblxuICBsZXQgY29vcmRpbmF0ZXMgPSBwb3NpdGlvbi5jbG9uZSgpXG4gICAgLnN1Yihmb2N1cy5kZXJpdmVkLnBvc2l0aW9uKVxuICAgIC5tdWx0aXBseVNjYWxhcihUUkFKRUNUT1JZX1NDQUxFKTtcblxuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG5PcmJpdGFsTWFwUmVuZGVyZXIucHJvdG90eXBlLl9zY2FsZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuXG4gIGxldCBib2R5TWFwID0gdGhpcy5ib2R5TWFwLmdldChib2R5Lm5hbWUpO1xuICBsZXQgdGhyZWVCb2R5ID0gYm9keU1hcC5ib2R5O1xuICBsZXQgdHJhamVjdG9yeSA9IGJvZHlNYXAudHJhamVjdG9yeTtcbiAgbGV0IGNhbWVyYURpc3RhbmNlID0gdGhpcy5jYW1lcmEucG9zaXRpb24uZGlzdGFuY2VUbyh0aHJlZUJvZHkucG9zaXRpb24pO1xuXG4gIGxldCBzY2FsZSA9IE1hdGgubWF4KDAuMDA1ICogY2FtZXJhRGlzdGFuY2UsIGJvZHkuY29uc3RhbnRzLnJhZGl1cykgLyBib2R5LmNvbnN0YW50cy5yYWRpdXM7XG4gIHRocmVlQm9keS5zY2FsZS5zZXQoc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cbiAgLy8gQWxsb3cgbW9yZSAnc3BhY2UnIGJldHdlZW4gbGFyZ2UgYm9kaWVzIGFuZCB0aGVpciBzYXRlbGxpdGVzXG4gIHRyYWplY3RvcnkgJiYgdHJhamVjdG9yeS5zY2FsZS5zZXQodHJhamVjdG9yeS5zY2FsZS54ICogVFJBSkVDVE9SWV9TQ0FMRSwgdHJhamVjdG9yeS5zY2FsZS55ICogVFJBSkVDVE9SWV9TQ0FMRSwgMSk7XG59O1xuXG5PcmJpdGFsTWFwUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGVUcmFqZWN0b3J5ID0gZnVuY3Rpb24gKGZvY3VzLCBib2R5KSB7XG5cbiAgaWYgKGJvZHkubmFtZSA9PT0gJ3N1bicpXG4gICAgcmV0dXJuO1xuXG4gIC8vIFJlZHJhdyB0aGUgdHJhamVjdG9yeSBmb3IgdGhpcyBib2R5XG4gIGxldCBib2R5TWFwID0gdGhpcy5ib2R5TWFwLmdldChib2R5Lm5hbWUpO1xuICBsZXQgdHJhamVjdG9yeSA9IGJvZHlNYXAudHJhamVjdG9yeTtcbiAgbGV0IHRyYWplY3RvcnlWZXJ0aWNlcyA9IGJvZHlNYXAudHJhamVjdG9yeVZlcnRpY2VzO1xuICBsZXQgdHJhamVjdG9yeVZlcnRpY2VzRGlydHkgPSBib2R5TWFwLnRyYWplY3RvcnlWZXJ0aWNlc0RpcnR5O1xuXG4gIGxldCBkZXJpdmVkID0gYm9keS5kZXJpdmVkO1xuICBsZXQgcG9zaXRpb25faW5fcGxhbmUgPSBib2R5LmRlcml2ZWQucG9zaXRpb25faW5fcGxhbmU7XG4gIGxldCBjZW50ZXJfaW5fcGxhbmUgPSBib2R5LmRlcml2ZWQuY2VudGVyX2luX3BsYW5lO1xuICBsZXQgc2VtaU1ham9yQXhpcyA9IGRlcml2ZWQuc2VtaU1ham9yQXhpcztcbiAgbGV0IHNlbWlNaW5vckF4aXMgPSBkZXJpdmVkLnNlbWlNaW5vckF4aXM7XG4gIGxldCBjZW50ZXIgPSB0aGlzLl9hZGp1c3RDb29yZGluYXRlcyhmb2N1cywgZGVyaXZlZC5jZW50ZXIpO1xuXG4gIGxldCBzY2FsZWRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAuY29weShwb3NpdGlvbl9pbl9wbGFuZSlcbiAgICAuc3ViKGNlbnRlcl9pbl9wbGFuZSk7XG4gIHNjYWxlZFBvc2l0aW9uLm11bHRpcGx5KG5ldyBUSFJFRS5WZWN0b3IzKDEgLyBzZW1pTWFqb3JBeGlzLCAxIC8gc2VtaU1pbm9yQXhpcywgMSkpO1xuXG4gIC8vIFdvcmthcm91bmQgZm9yIG5hdHVyYWwgbGltaXRhdGlvbnMgb2YgZHJhd2luZyBhcmNzIHVzaW5nIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHM7XG4gIC8vIHlvdSBpbmhlcmVudGx5IGNhbm5vdCB0cmFjayBhIHBsYW5ldCBtb3ZpbmcgaW4gYW4gZWxsaXBzZSBiZXR3ZWVuIHRoZSBwbGFuZXRcbiAgLy8gd2lsbCBhbHdheXMgYmUgYmV0d2VlbiB0d28gdmVydGljZXMuICBUaGlzIGNvZGUgYXR0ZW1wdHMgdG8gbWFudWFsbHkgJ2luc2VydCdcbiAgLy8gYSB2ZXJ0ZXggdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGxhbmV0cyBsb2NhdGlvbi5cbiAgLy8gVGhpcyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgdGhlIHRyYWplY3Rvcnkgd291bGQgd29iYmxlIGluIGFuZCBvdXQgb2YgdGhlIHBsYW5ldFxuXG4gIGNvbnN0IGdlb21ldHJ5ID0gdHJhamVjdG9yeS5nZW9tZXRyeTtcbiAgY29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgY29uc3QgcmFuZ2UgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcbiAgY29uc3QgdmVydGljZXNUb0NoYW5nZSA9IDE7XG4gIGNvbnN0IHZlcnRpY2VzVG9UZXN0ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZTsgaSsrKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDM7XG4gICAgdmVydGljZXNUb1Rlc3QucHVzaChuZXcgVEhSRUUuVmVjdG9yMyh0cmFqZWN0b3J5VmVydGljZXNbb2Zmc2V0XSxcbiAgICAgIHRyYWplY3RvcnlWZXJ0aWNlc1tvZmZzZXQgKyAxXSwgdHJhamVjdG9yeVZlcnRpY2VzW29mZnNldCArIDJdKSk7XG4gIH07XG5cbiAgLy8gRmluZCB0aGUgdmVydGV4IHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcGxhbmV0cyBwb3NpdGlvblxuICBjb25zdCBzb3J0ZWQgPSB2ZXJ0aWNlc1RvVGVzdC5tYXAoKHZlcnRleCwgaWR4KSA9PiBbdmVydGV4LmRpc3RhbmNlVG8oc2NhbGVkUG9zaXRpb24pLCB2ZXJ0ZXgsIGlkeF0pXG4gICAgLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICByZXR1cm4gbGVmdFswXSAtIHJpZ2h0WzBdO1xuICAgIH0pO1xuXG4gIHRyYWplY3RvcnlWZXJ0aWNlc0RpcnR5LmZvckVhY2goKGlkeCkgPT4ge1xuICAgIGxldCBvZmZzZXQgPSBpZHggKiAzO1xuICAgIHBvc2l0aW9uc1tvZmZzZXRdID0gdHJhamVjdG9yeVZlcnRpY2VzW29mZnNldF07XG4gICAgcG9zaXRpb25zW29mZnNldCArIDFdID0gdHJhamVjdG9yeVZlcnRpY2VzW29mZnNldCArIDFdO1xuICAgIHBvc2l0aW9uc1tvZmZzZXQgKyAyXSA9IHRyYWplY3RvcnlWZXJ0aWNlc1tvZmZzZXQgKyAyXTtcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZWREaXJ0eVZlcnRpY2VzID0gW107XG5cbiAgLy8gT3ZlcndyaXRlIHRoZSBjbG9zZXN0IHZlcnRpY2VzIHdpdGggdGhlIHBsYW5ldHMgYWN0dWFsIHBvc2l0aW9uLiAgVGhpcyB3aWxsXG4gIC8vIGVuc3VyZSB0aGF0IGEgdmVydGV4IGZvciBvdXIgdHJhamVjdG9yeSBpcyBhbHdheXMgbG9jYXRlZCBhdCB0aGUgcGxhbmV0c1xuICAvLyBsb2NhdGlvbi5cbiAgc29ydGVkLnNsaWNlKDAsIHZlcnRpY2VzVG9DaGFuZ2UpXG4gICAgLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCB2ZXJ0ZXggPSBlbGVtZW50WzFdO1xuICAgICAgbGV0IG9mZnNldCA9IGVsZW1lbnRbMl0gKiAzO1xuICAgICAgcG9zaXRpb25zW29mZnNldF0gPSBzY2FsZWRQb3NpdGlvbi54O1xuICAgICAgcG9zaXRpb25zW29mZnNldCArIDFdID0gc2NhbGVkUG9zaXRpb24ueVxuICAgICAgcG9zaXRpb25zW29mZnNldCArIDJdID0gc2NhbGVkUG9zaXRpb24uejtcblxuICAgICAgdXBkYXRlZERpcnR5VmVydGljZXMucHVzaChlbGVtZW50WzJdKTtcbiAgICB9KTtcblxuICAvLyBTZXQgbmV3IHZhbHVlIG9mIGRpcnR5IHZlcnRpY2VzO1xuICBib2R5TWFwLnRyYWplY3RvcnlWZXJ0aWNlc0RpcnR5ID0gdXBkYXRlZERpcnR5VmVydGljZXM7XG5cbiAgLy8gU2lnbmFsIHRoYXQgdGhpcyBnZW9tZXRyeSBuZWVkcyBhIHJlZHJhd1xuICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBGaW5hbGx5LCBhcHBseSBzY2FsZS9yb3RhdGlvbi90cmFuc2xhdGlvbiB0byB0aGUgdHJhamVjdG9yeSB0byBwbGFjZSBpdFxuICAvLyBpbnRvIHRoZSBjb3JyZWN0IG9yYml0XG4gIHRyYWplY3Rvcnkuc2NhbGUuc2V0KDEsIDEsIDEpO1xuICB0cmFqZWN0b3J5LnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgdHJhamVjdG9yeS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG5cbiAgLy8gTm93IGFkanVzdCB0aGUgdHJhamVjdG9yeSB0byBpdHMgYWN0dWFsIG9yaWVudGF0aW9uXG4gIHRyYWplY3RvcnkudHJhbnNsYXRlWChjZW50ZXIueCk7XG4gIHRyYWplY3RvcnkudHJhbnNsYXRlWShjZW50ZXIueSk7XG4gIHRyYWplY3RvcnkudHJhbnNsYXRlWihjZW50ZXIueik7XG4gIHRyYWplY3Rvcnkucm90YXRlWihkZXJpdmVkLm9tZWdhKTtcbiAgdHJhamVjdG9yeS5yb3RhdGVYKGRlcml2ZWQuSSk7XG4gIHRyYWplY3Rvcnkucm90YXRlWihkZXJpdmVkLmFyZ3VtZW50UGVyaWhlbGlvbik7XG4gIHRyYWplY3Rvcnkuc2NhbGUuc2V0KHNlbWlNYWpvckF4aXMsIHNlbWlNaW5vckF4aXMsIDEpO1xufTtcblxuT3JiaXRhbE1hcFJlbmRlcmVyLnByb3RvdHlwZS5fY3JlYXRlVHJhamVjdG9yeUdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG4gIGNvbnN0IE5VTV9QT0lOVFMgPSAyNTY7XG5cbiAgLy8gQ3JlYXRlIHRoZSB0cmFqZWN0b3J5IHVzaW5nIGEgc3RyYW5kYXJkIGVsbGlwc2UgY3VydmUgdGhhdCB3aWxsXG4gIC8vIGV2ZW50dWFsbHkgc2NhbGUvcm90YXRlL3RyYW5zbGF0ZSBpbnRvIHRoZSBjb3JyZWN0IG9yYml0IHBhdGggZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgbG9vcC5cbiAgY29uc3QgcG9pbnRzR2VvbWV0cnkgPSBuZXcgVEhSRUUuUGF0aChuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKFxuICAgICAgICAwLCAwLCAvLyBheCwgYVlcbiAgICAgICAgMSwgMSwgLy8geFJhZGl1cywgeVJhZGl1c1xuICAgICAgICAwLCAyICogTWF0aC5QSSwgLy8gYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZVxuICAgICAgICBmYWxzZSwgLy8gYUNsb2Nrd2lzZVxuICAgICAgICAwIC8vIGFSb3RhdGlvblxuICAgICAgKVxuICAgICAgLmdldFBvaW50cyhOVU1fUE9JTlRTKSlcbiAgICAuY3JlYXRlUG9pbnRzR2VvbWV0cnkoTlVNX1BPSU5UUyk7XG4gIGNvbnN0IGJ1ZmZlckdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gIGNvbnN0IHZlcnRpY2VzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzR2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgcG9pbnRzR2VvbWV0cnkudmVydGljZXNbaV0ueCxcbiAgICAgIHBvaW50c0dlb21ldHJ5LnZlcnRpY2VzW2ldLnksXG4gICAgICBwb2ludHNHZW9tZXRyeS52ZXJ0aWNlc1tpXS56XG4gICAgKTtcbiAgfVxuXG4gIGJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgncG9zaXRpb24nLFxuICAgIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyksIDMpKTtcblxuICByZXR1cm4gYnVmZmVyR2VvbWV0cnk7XG59O1xuXG5PYmplY3QuYXNzaWduKE9yYml0YWxNYXBSZW5kZXJlci5wcm90b3R5cGUsIEJhc2VSZW5kZXJlci5wcm90b3R5cGUpO1xuXG5leHBvcnQgZGVmYXVsdCBPcmJpdGFsTWFwUmVuZGVyZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcC9PcmJpdGFsTWFwUmVuZGVyZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBREE7QUFDQTtBQUdBO0FBRUE7QUFEQTtBQUNBO0FBR0E7QUFFQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _moment = __webpack_require__(0);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Bodies = __webpack_require__(2);\n\nvar _StringExtensions = __webpack_require__(122);\n\nvar _StringExtensions2 = _interopRequireDefault(_StringExtensions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar numToRun = 10000;\n\nfunction Simulation(solarSystem, renderers, state, stats) {\n  var _this = this;\n\n  this.solarSystem = solarSystem;\n  this.renderers = renderers;\n  this.rendererIdx = 0;\n  this.renderer = renderers[this.rendererIdx];\n  this.loaded = new Set();\n  this.state = state;\n  this.stats = stats;\n  this.isStopped = true;\n  this.time = Date.now();\n  this.startingTime = this.time;\n  this.timeWarpValues = [1, 5, 10, 50, 100, 10e2, 10e3, 10e4, 10e5, 10e6];\n  this.timeWarpIdx = 0;\n\n  this.timeCounter = document.getElementById('time');\n  this.warpValues = document.getElementById('warp-values');\n  this.timeWarpValues.forEach(function (value, idx) {\n    var arrow = document.createElement('div');\n    _this.warpValues.appendChild(arrow);\n  });\n\n  /**\n   * Handle window event listeners\n   */\n  var keypresses = function keypresses(event) {\n    var keyCodes = {\n      32: _this.toggleRun,\n      44: _this.slowDown,\n      46: _this.speedUp,\n      99: _this.recenter,\n      91: _this.toggleFocus,\n      93: _this.toggleFocus,\n      122: _this.toggleView\n    };\n\n    if (event.type === \"keypress\" && keyCodes.hasOwnProperty(event.keyCode)) {\n      keyCodes[event.keyCode].call(_this, event);\n      event.preventDefault();\n    }\n  };\n\n  window.addEventListener(\"keypress\", keypresses, false);\n  window.addEventListener(\"resize\", function (event) {\n    _this.renderer.dispatchEvent({\n      type: \"resize\"\n    });\n  }, true);\n\n  window.addEventListener(\"mousedown\", function (event) {\n    var width = window.innerWidth;\n    var height = window.innerHeight;\n    var pixelMultiplier = window.devicePixelRatio;\n\n    var target = new THREE.Vector2((event.clientX - width / 2) * pixelMultiplier, (height / 2 - event.clientY) * pixelMultiplier);\n\n    _this.renderer.dispatchEvent({\n      type: 'click',\n      location: target\n    });\n  }, true);\n};\n\nSimulation.prototype.speedUp = function () {\n  if (!this.isRunning()) {\n    return;\n  }\n\n  this.timeWarpIdx = Math.min(this.timeWarpValues.length - 1, this.timeWarpIdx + 1);\n};\n\nSimulation.prototype.slowDown = function () {\n  if (!this.isRunning()) {\n    return;\n  }\n\n  this.timeWarpIdx = Math.max(0, this.timeWarpIdx - 1);\n};\n\nSimulation.prototype.pause = function () {\n  this.isStopped = true;\n};\n\nSimulation.prototype.isRunning = function () {\n  return !this.isStopped;\n};\n\nSimulation.prototype.toggleRun = function () {\n  if (this.isRunning()) {\n    this.pause();\n  } else {\n    this.run();\n  }\n};\n\nSimulation.prototype.recenter = function () {\n  if (!this.isRunning()) {\n    return;\n  }\n\n  this.renderer.dispatchEvent({\n    type: 'recenter'\n  });\n};\n\nSimulation.prototype.toggleFocus = function (event) {\n  var _this2 = this;\n\n  var solarSystem = this.solarSystem;\n  var focusIdx = solarSystem.bodies.findIndex(function (p) {\n    return p.name === _this2.state.focus;\n  });\n\n  if (event.keyCode === 91) {\n    focusIdx--;\n    if (focusIdx < 0) focusIdx = solarSystem.bodies.length - 1;\n  } else {\n    focusIdx = (focusIdx + 1) % solarSystem.bodies.length;\n  }\n\n  this.state.focus = solarSystem.bodies[focusIdx].name;\n  this.renderer.dispatchEvent({\n    type: 'focus',\n    focus: this.state.focus\n  });\n};\n\nSimulation.prototype.initialize = function () {\n  var _this3 = this;\n\n  // Ensure the solar system is fully 'seeded' before we attempt to render\n  this.solarSystem.update(this.time, 0);\n\n  this.renderers.forEach(function (renderer) {\n    renderer.container.style = 'display: none;';\n  });\n\n  // Bring up the appropriate view and hide the others\n  console.log('Loading ' + this.renderer.constructor.name);\n  return this.renderer.viewDidLoad(this.solarSystem).then(function () {\n    // Once the views are loaded, we can be prepare to surface this view\n    _this3.renderer.viewWillAppear();\n    _this3.renderer.container.style = '';\n    _this3.loaded.add(_this3.renderer);\n    return Promise.resolve();\n  });\n};\n\nSimulation.prototype.toggleView = function () {\n  var _this4 = this;\n\n  this.rendererIdx = (this.rendererIdx + 1) % this.renderers.length;\n  var oldRenderer = this.renderer;\n\n  oldRenderer.viewWillDisappear();\n  oldRenderer.container.style = 'display: none;';\n\n  var newRenderer = this.renderers[this.rendererIdx];\n\n  var promise = void 0;\n  if (!this.loaded.has(newRenderer)) {\n    console.log('Loading ' + newRenderer.constructor.name);\n    promise = newRenderer.viewDidLoad(this.solarSystem).then(function () {\n      _this4.loaded.add(newRenderer);\n      return Promise.resolve();\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n\n  promise.then(function () {\n    newRenderer.viewWillAppear();\n    newRenderer.container.style = '';\n    _this4.renderer = newRenderer;\n  });\n};\n\nSimulation.prototype.run = function () {\n\n  if (this.isRunning()) {\n    return;\n  }\n\n  this.isStopped = false;\n  var numTimes = 0;\n  var accumulator = 0.0;\n  var dt = 10; // ms\n\n  runAnimation(function (frameTime) {\n\n    if (this.isStopped) {\n      return false;\n    }\n\n    this.stats.begin();\n\n    accumulator += frameTime;\n\n    while (accumulator >= dt) {\n      var t = this.time;\n      var scaledDt = this.timeWarpValues[this.timeWarpIdx] * dt;\n\n      // Update physics\n      this.solarSystem.update(t, scaledDt);\n\n      accumulator -= dt;\n      this.time += scaledDt;\n    }\n\n    this.renderer.render(this.solarSystem);\n\n    this.updateOrbitalDisplay();\n    this.updateTimeDisplay();\n    this.stats.end();\n\n    numTimes++;\n    if (numTimes >= numToRun) {\n      console.log('All done!');\n      this.isStopped = true;\n      return false;\n    }\n  }.bind(this));\n};\n\nSimulation.prototype.updateOrbitalDisplay = function () {\n\n  var focus = this.solarSystem.find(this.state.focus);\n  var name = focus.name;\n  var velocity = focus.derived.velocity.length() * _Bodies.AU;\n  var eccentricity = focus.derived.e || 0;\n  var semiMajorAxis = focus.derived.semiMajorAxis * _Bodies.AU;\n  var semiMinorAxis = focus.derived.semiMinorAxis * _Bodies.AU;\n  var rotation_period = focus.constants.rotation_period || 0;\n  var axial_tilt = focus.constants.axial_tilt || 0;\n  var orbital_period = (focus.derived.orbital_period || 0) / 86400;\n\n  document.getElementById('orbital-name').innerHTML = name.escapeHtml();\n  document.getElementById('orbital-primary').innerHTML = (focus.primary ? focus.primary.name : '').escapeHtml();\n  document.getElementById('orbital-speed').innerHTML = (velocity.toFixed(2) + ' m/s').escapeHtml();\n  document.getElementById('orbital-eccentricity').innerHTML = ('' + eccentricity.toFixed(4)).escapeHtml();\n  document.getElementById('orbital-semiMajorAxis').innerHTML = (semiMajorAxis.toExponential(4) + ' m').escapeHtml();\n  document.getElementById('orbital-semiMinorAxis').innerHTML = (semiMinorAxis.toExponential(4) + ' m').escapeHtml();\n  document.getElementById('orbital-period').innerHTML = (orbital_period.toFixed(4) + ' days').escapeHtml();\n  document.getElementById('orbital-rotation-period').innerHTML = (rotation_period.toFixed(4) + ' days').escapeHtml();\n  document.getElementById('orbital-axial-tilt').innerHTML = (axial_tilt.toFixed(2) + '\\xB0').escapeHtml();\n};\n\nSimulation.prototype.updateTimeDisplay = function () {\n  var _this5 = this;\n\n  var elapsed = _moment2.default.duration(this.time - this.startingTime);\n  var years = elapsed.years();\n  var months = elapsed.months();\n  var days = elapsed.days() + months * 30;\n  var hours = elapsed.hours();\n  var minutes = elapsed.minutes();\n  var seconds = elapsed.seconds();\n\n  var values = [];\n\n  if (years > 0) values.push(years + 'Y');\n\n  if (days > 0) values.push(days + 'd');\n\n  values.push(hours.toString().paddingLeft('00'), minutes.toString().paddingLeft('00'), seconds.toString().paddingLeft('00'));\n\n  Array.from(this.warpValues.children).forEach(function (value, idx) {\n    if (idx <= _this5.timeWarpIdx) {\n      value.className = 'warp-enabled';\n    } else {\n      value.className = 'warp-disabled';\n    }\n  });\n  this.timeCounter.innerHTML = ('+T ' + values.join(':')).escapeHtml();\n};\n\nfunction runAnimation(frameFunc) {\n  var lastTime = null;\n\n  function frame(time) {\n    var stop = false;\n    if (lastTime != null) {\n      var timeStep = time - lastTime;\n      stop = frameFunc(timeStep) === false;\n    }\n    lastTime = time;\n    if (!stop) requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n};\n\nexports.default = Simulation;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvU2ltdWxhdGlvbi5qcz80ZjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuaW1wb3J0IHtcbiAgQVVcbn0gZnJvbSAnLi9Cb2RpZXMnO1xuaW1wb3J0IFN0cmluZ0V4dGVuc2lvbnMgZnJvbSAnLi91dGlsL1N0cmluZ0V4dGVuc2lvbnMnO1xuXG5jb25zdCBudW1Ub1J1biA9IDEwMDAwO1xuXG5mdW5jdGlvbiBTaW11bGF0aW9uKHNvbGFyU3lzdGVtLCByZW5kZXJlcnMsIHN0YXRlLCBzdGF0cykge1xuICB0aGlzLnNvbGFyU3lzdGVtID0gc29sYXJTeXN0ZW07XG4gIHRoaXMucmVuZGVyZXJzID0gcmVuZGVyZXJzO1xuICB0aGlzLnJlbmRlcmVySWR4ID0gMDtcbiAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyc1t0aGlzLnJlbmRlcmVySWR4XTtcbiAgdGhpcy5sb2FkZWQgPSBuZXcgU2V0KCk7XG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgdGhpcy5zdGF0cyA9IHN0YXRzO1xuICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gIHRoaXMuc3RhcnRpbmdUaW1lID0gdGhpcy50aW1lO1xuICB0aGlzLnRpbWVXYXJwVmFsdWVzID0gWzEsIDUsIDEwLCA1MCwgMTAwLCAxMGUyLCAxMGUzLCAxMGU0LCAxMGU1LCAxMGU2XTtcbiAgdGhpcy50aW1lV2FycElkeCA9IDA7XG5cbiAgdGhpcy50aW1lQ291bnRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lJyk7XG4gIHRoaXMud2FycFZhbHVlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YXJwLXZhbHVlcycpO1xuICB0aGlzLnRpbWVXYXJwVmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IHtcbiAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMud2FycFZhbHVlcy5hcHBlbmRDaGlsZChhcnJvdyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2luZG93IGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgY29uc3Qga2V5cHJlc3NlcyA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGtleUNvZGVzID0ge1xuICAgICAgMzI6IHRoaXMudG9nZ2xlUnVuLFxuICAgICAgNDQ6IHRoaXMuc2xvd0Rvd24sXG4gICAgICA0NjogdGhpcy5zcGVlZFVwLFxuICAgICAgOTk6IHRoaXMucmVjZW50ZXIsXG4gICAgICA5MTogdGhpcy50b2dnbGVGb2N1cyxcbiAgICAgIDkzOiB0aGlzLnRvZ2dsZUZvY3VzLFxuICAgICAgMTIyOiB0aGlzLnRvZ2dsZVZpZXcsXG4gICAgfTtcblxuICAgIGlmIChldmVudC50eXBlID09PSBcImtleXByZXNzXCIgJiYga2V5Q29kZXMuaGFzT3duUHJvcGVydHkoZXZlbnQua2V5Q29kZSkpIHtcbiAgICAgIGtleUNvZGVzW2V2ZW50LmtleUNvZGVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBrZXlwcmVzc2VzLCBmYWxzZSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIChldmVudCkgPT4ge1xuICAgIHRoaXMucmVuZGVyZXIuZGlzcGF0Y2hFdmVudCh7XG4gICAgICB0eXBlOiBcInJlc2l6ZVwiXG4gICAgfSk7XG4gIH0sIHRydWUpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGxldCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGxldCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHBpeGVsTXVsdGlwbGllciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgbGV0IHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IyKFxuICAgICAgKGV2ZW50LmNsaWVudFggLSB3aWR0aCAvIDIpICogcGl4ZWxNdWx0aXBsaWVyLFxuICAgICAgKGhlaWdodCAvIDIgLSBldmVudC5jbGllbnRZKSAqIHBpeGVsTXVsdGlwbGllcik7XG5cbiAgICB0aGlzLnJlbmRlcmVyLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgdHlwZTogJ2NsaWNrJyxcbiAgICAgIGxvY2F0aW9uOiB0YXJnZXRcbiAgICB9KTtcbiAgfSwgdHJ1ZSk7XG59O1xuXG5TaW11bGF0aW9uLnByb3RvdHlwZS5zcGVlZFVwID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnRpbWVXYXJwSWR4ID0gTWF0aC5taW4odGhpcy50aW1lV2FycFZhbHVlcy5sZW5ndGggLSAxLCB0aGlzLnRpbWVXYXJwSWR4ICsgMSk7XG59O1xuXG5TaW11bGF0aW9uLnByb3RvdHlwZS5zbG93RG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmlzUnVubmluZygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy50aW1lV2FycElkeCA9IE1hdGgubWF4KDAsIHRoaXMudGltZVdhcnBJZHggLSAxKTtcbn07XG5cblNpbXVsYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG59O1xuXG5TaW11bGF0aW9uLnByb3RvdHlwZS5pc1J1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5pc1N0b3BwZWQ7XG59O1xuXG5TaW11bGF0aW9uLnByb3RvdHlwZS50b2dnbGVSdW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzUnVubmluZygpKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucnVuKCk7XG4gIH1cbn07XG5cblNpbXVsYXRpb24ucHJvdG90eXBlLnJlY2VudGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnJlbmRlcmVyLmRpc3BhdGNoRXZlbnQoe1xuICAgIHR5cGU6ICdyZWNlbnRlcidcbiAgfSk7XG59O1xuXG5TaW11bGF0aW9uLnByb3RvdHlwZS50b2dnbGVGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gIGxldCBzb2xhclN5c3RlbSA9IHRoaXMuc29sYXJTeXN0ZW07XG4gIGxldCBmb2N1c0lkeCA9IHNvbGFyU3lzdGVtLmJvZGllcy5maW5kSW5kZXgoKHApID0+IHAubmFtZSA9PT0gdGhpcy5zdGF0ZS5mb2N1cyk7XG5cbiAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDkxKSB7XG4gICAgZm9jdXNJZHgtLTtcbiAgICBpZiAoZm9jdXNJZHggPCAwKVxuICAgICAgZm9jdXNJZHggPSBzb2xhclN5c3RlbS5ib2RpZXMubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIHtcbiAgICBmb2N1c0lkeCA9IChmb2N1c0lkeCArIDEpICUgc29sYXJTeXN0ZW0uYm9kaWVzLmxlbmd0aDtcbiAgfVxuXG4gIHRoaXMuc3RhdGUuZm9jdXMgPSBzb2xhclN5c3RlbS5ib2RpZXNbZm9jdXNJZHhdLm5hbWU7XG4gIHRoaXMucmVuZGVyZXIuZGlzcGF0Y2hFdmVudCh7XG4gICAgdHlwZTogJ2ZvY3VzJyxcbiAgICBmb2N1czogdGhpcy5zdGF0ZS5mb2N1c1xuICB9KTtcbn07XG5cblNpbXVsYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gRW5zdXJlIHRoZSBzb2xhciBzeXN0ZW0gaXMgZnVsbHkgJ3NlZWRlZCcgYmVmb3JlIHdlIGF0dGVtcHQgdG8gcmVuZGVyXG4gIHRoaXMuc29sYXJTeXN0ZW0udXBkYXRlKHRoaXMudGltZSwgMCk7XG5cbiAgdGhpcy5yZW5kZXJlcnMuZm9yRWFjaCgocmVuZGVyZXIpID0+IHtcbiAgICByZW5kZXJlci5jb250YWluZXIuc3R5bGUgPSAnZGlzcGxheTogbm9uZTsnO1xuICB9KTtcblxuICAvLyBCcmluZyB1cCB0aGUgYXBwcm9wcmlhdGUgdmlldyBhbmQgaGlkZSB0aGUgb3RoZXJzXG4gIGNvbnNvbGUubG9nKGBMb2FkaW5nICR7dGhpcy5yZW5kZXJlci5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3RGlkTG9hZCh0aGlzLnNvbGFyU3lzdGVtKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIC8vIE9uY2UgdGhlIHZpZXdzIGFyZSBsb2FkZWQsIHdlIGNhbiBiZSBwcmVwYXJlIHRvIHN1cmZhY2UgdGhpcyB2aWV3XG4gICAgICB0aGlzLnJlbmRlcmVyLnZpZXdXaWxsQXBwZWFyKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmNvbnRhaW5lci5zdHlsZSA9ICcnO1xuICAgICAgdGhpcy5sb2FkZWQuYWRkKHRoaXMucmVuZGVyZXIpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0pO1xufTtcblxuU2ltdWxhdGlvbi5wcm90b3R5cGUudG9nZ2xlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZW5kZXJlcklkeCA9ICh0aGlzLnJlbmRlcmVySWR4ICsgMSkgJSB0aGlzLnJlbmRlcmVycy5sZW5ndGg7XG4gIGNvbnN0IG9sZFJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICBvbGRSZW5kZXJlci52aWV3V2lsbERpc2FwcGVhcigpO1xuICBvbGRSZW5kZXJlci5jb250YWluZXIuc3R5bGUgPSAnZGlzcGxheTogbm9uZTsnO1xuXG4gIGNvbnN0IG5ld1JlbmRlcmVyID0gdGhpcy5yZW5kZXJlcnNbdGhpcy5yZW5kZXJlcklkeF07XG5cbiAgbGV0IHByb21pc2U7XG4gIGlmICghdGhpcy5sb2FkZWQuaGFzKG5ld1JlbmRlcmVyKSkge1xuICAgIGNvbnNvbGUubG9nKGBMb2FkaW5nICR7bmV3UmVuZGVyZXIuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICBwcm9taXNlID0gbmV3UmVuZGVyZXIudmlld0RpZExvYWQodGhpcy5zb2xhclN5c3RlbSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2FkZWQuYWRkKG5ld1JlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSlcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgIG5ld1JlbmRlcmVyLnZpZXdXaWxsQXBwZWFyKCk7XG4gICAgbmV3UmVuZGVyZXIuY29udGFpbmVyLnN0eWxlID0gJyc7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ld1JlbmRlcmVyO1xuICB9KTtcbn1cblxuU2ltdWxhdGlvbi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuXG4gIGlmICh0aGlzLmlzUnVubmluZygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgbGV0IG51bVRpbWVzID0gMDtcbiAgbGV0IGFjY3VtdWxhdG9yID0gMC4wO1xuICBsZXQgZHQgPSAxMDsgLy8gbXNcblxuICBydW5BbmltYXRpb24oZnVuY3Rpb24gKGZyYW1lVGltZSkge1xuXG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0cy5iZWdpbigpO1xuXG4gICAgYWNjdW11bGF0b3IgKz0gZnJhbWVUaW1lO1xuXG4gICAgd2hpbGUgKGFjY3VtdWxhdG9yID49IGR0KSB7XG4gICAgICBsZXQgdCA9IHRoaXMudGltZTtcbiAgICAgIGxldCBzY2FsZWREdCA9IHRoaXMudGltZVdhcnBWYWx1ZXNbdGhpcy50aW1lV2FycElkeF0gKiBkdDtcblxuICAgICAgLy8gVXBkYXRlIHBoeXNpY3NcbiAgICAgIHRoaXMuc29sYXJTeXN0ZW0udXBkYXRlKHQsIHNjYWxlZER0KTtcblxuICAgICAgYWNjdW11bGF0b3IgLT0gZHQ7XG4gICAgICB0aGlzLnRpbWUgKz0gc2NhbGVkRHQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zb2xhclN5c3RlbSk7XG5cbiAgICB0aGlzLnVwZGF0ZU9yYml0YWxEaXNwbGF5KCk7XG4gICAgdGhpcy51cGRhdGVUaW1lRGlzcGxheSgpO1xuICAgIHRoaXMuc3RhdHMuZW5kKCk7XG5cbiAgICBudW1UaW1lcysrO1xuICAgIGlmIChudW1UaW1lcyA+PSBudW1Ub1J1bikge1xuICAgICAgY29uc29sZS5sb2coJ0FsbCBkb25lIScpO1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9LmJpbmQodGhpcykpO1xufTtcblxuU2ltdWxhdGlvbi5wcm90b3R5cGUudXBkYXRlT3JiaXRhbERpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgY29uc3QgZm9jdXMgPSB0aGlzLnNvbGFyU3lzdGVtLmZpbmQodGhpcy5zdGF0ZS5mb2N1cyk7XG4gIGNvbnN0IG5hbWUgPSBmb2N1cy5uYW1lO1xuICBjb25zdCB2ZWxvY2l0eSA9IGZvY3VzLmRlcml2ZWQudmVsb2NpdHkubGVuZ3RoKCkgKiBBVTtcbiAgY29uc3QgZWNjZW50cmljaXR5ID0gZm9jdXMuZGVyaXZlZC5lIHx8IDA7XG4gIGNvbnN0IHNlbWlNYWpvckF4aXMgPSBmb2N1cy5kZXJpdmVkLnNlbWlNYWpvckF4aXMgKiBBVTtcbiAgY29uc3Qgc2VtaU1pbm9yQXhpcyA9IGZvY3VzLmRlcml2ZWQuc2VtaU1pbm9yQXhpcyAqIEFVO1xuICBjb25zdCByb3RhdGlvbl9wZXJpb2QgPSBmb2N1cy5jb25zdGFudHMucm90YXRpb25fcGVyaW9kIHx8IDA7XG4gIGNvbnN0IGF4aWFsX3RpbHQgPSBmb2N1cy5jb25zdGFudHMuYXhpYWxfdGlsdCB8fCAwO1xuICBjb25zdCBvcmJpdGFsX3BlcmlvZCA9IChmb2N1cy5kZXJpdmVkLm9yYml0YWxfcGVyaW9kIHx8IDApIC8gODY0MDA7XG5cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yYml0YWwtbmFtZScpXG4gICAgLmlubmVySFRNTCA9IG5hbWUuZXNjYXBlSHRtbCgpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXRhbC1wcmltYXJ5JylcbiAgICAuaW5uZXJIVE1MID0gKGZvY3VzLnByaW1hcnkgPyBmb2N1cy5wcmltYXJ5Lm5hbWUgOiAnJylcbiAgICAuZXNjYXBlSHRtbCgpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXRhbC1zcGVlZCcpXG4gICAgLmlubmVySFRNTCA9IGAke3ZlbG9jaXR5LnRvRml4ZWQoMil9IG0vc2AuZXNjYXBlSHRtbCgpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXRhbC1lY2NlbnRyaWNpdHknKVxuICAgIC5pbm5lckhUTUwgPSBgJHtlY2NlbnRyaWNpdHkudG9GaXhlZCg0KX1gLmVzY2FwZUh0bWwoKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yYml0YWwtc2VtaU1ham9yQXhpcycpXG4gICAgLmlubmVySFRNTCA9IGAke3NlbWlNYWpvckF4aXMudG9FeHBvbmVudGlhbCg0KX0gbWAuZXNjYXBlSHRtbCgpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3JiaXRhbC1zZW1pTWlub3JBeGlzJylcbiAgICAuaW5uZXJIVE1MID0gYCR7c2VtaU1pbm9yQXhpcy50b0V4cG9uZW50aWFsKDQpfSBtYC5lc2NhcGVIdG1sKCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvcmJpdGFsLXBlcmlvZCcpXG4gICAgLmlubmVySFRNTCA9IGAke29yYml0YWxfcGVyaW9kLnRvRml4ZWQoNCl9IGRheXNgLmVzY2FwZUh0bWwoKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yYml0YWwtcm90YXRpb24tcGVyaW9kJylcbiAgICAuaW5uZXJIVE1MID0gYCR7cm90YXRpb25fcGVyaW9kLnRvRml4ZWQoNCl9IGRheXNgLmVzY2FwZUh0bWwoKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29yYml0YWwtYXhpYWwtdGlsdCcpXG4gICAgLmlubmVySFRNTCA9IGAke2F4aWFsX3RpbHQudG9GaXhlZCgyKX3CsGAuZXNjYXBlSHRtbCgpO1xufTtcblxuU2ltdWxhdGlvbi5wcm90b3R5cGUudXBkYXRlVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGVsYXBzZWQgPSBtb21lbnQuZHVyYXRpb24odGhpcy50aW1lIC0gdGhpcy5zdGFydGluZ1RpbWUpO1xuICBjb25zdCB5ZWFycyA9IGVsYXBzZWQueWVhcnMoKTtcbiAgY29uc3QgbW9udGhzID0gZWxhcHNlZC5tb250aHMoKTtcbiAgY29uc3QgZGF5cyA9IGVsYXBzZWQuZGF5cygpICsgbW9udGhzICogMzA7XG4gIGNvbnN0IGhvdXJzID0gZWxhcHNlZC5ob3VycygpO1xuICBjb25zdCBtaW51dGVzID0gZWxhcHNlZC5taW51dGVzKCk7XG4gIGNvbnN0IHNlY29uZHMgPSBlbGFwc2VkLnNlY29uZHMoKTtcblxuICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICBpZiAoeWVhcnMgPiAwKVxuICAgIHZhbHVlcy5wdXNoKGAke3llYXJzfVlgKTtcblxuICBpZiAoZGF5cyA+IDApXG4gICAgdmFsdWVzLnB1c2goYCR7ZGF5c31kYCk7XG5cbiAgdmFsdWVzLnB1c2goXG4gICAgaG91cnMudG9TdHJpbmcoKVxuICAgIC5wYWRkaW5nTGVmdCgnMDAnKSxcbiAgICBtaW51dGVzLnRvU3RyaW5nKClcbiAgICAucGFkZGluZ0xlZnQoJzAwJyksXG4gICAgc2Vjb25kcy50b1N0cmluZygpXG4gICAgLnBhZGRpbmdMZWZ0KCcwMCcpXG4gIClcblxuICBBcnJheS5mcm9tKHRoaXMud2FycFZhbHVlcy5jaGlsZHJlbilcbiAgICAuZm9yRWFjaCgodmFsdWUsIGlkeCkgPT4ge1xuICAgICAgaWYgKGlkeCA8PSB0aGlzLnRpbWVXYXJwSWR4KSB7XG4gICAgICAgIHZhbHVlLmNsYXNzTmFtZSA9ICd3YXJwLWVuYWJsZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUuY2xhc3NOYW1lID0gJ3dhcnAtZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH0pO1xuICB0aGlzLnRpbWVDb3VudGVyLmlubmVySFRNTCA9IGArVCAke3ZhbHVlcy5qb2luKCc6Jyl9YC5lc2NhcGVIdG1sKCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkFuaW1hdGlvbihmcmFtZUZ1bmMpIHtcbiAgdmFyIGxhc3RUaW1lID0gbnVsbDtcblxuICBmdW5jdGlvbiBmcmFtZSh0aW1lKSB7XG4gICAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgICBpZiAobGFzdFRpbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHRpbWVTdGVwID0gKHRpbWUgLSBsYXN0VGltZSk7XG4gICAgICBzdG9wID0gZnJhbWVGdW5jKHRpbWVTdGVwKSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RUaW1lID0gdGltZTtcbiAgICBpZiAoIXN0b3ApXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTaW11bGF0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hcHAvU2ltdWxhdGlvbi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _moment = __webpack_require__(0);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _Bodies = __webpack_require__(2);\n\nvar _three = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar J2000_date = (0, _moment2.default)('2000-01-01T12:00:00Z');\nvar J2000_epoch = 2451545.0;\n\nfunction SolarSystem() {\n  this.bodies = Array.from(_Bodies.ALL_BODIES);\n  this.initialized = false;\n};\n\nSolarSystem.prototype.find = function (bodyId) {\n  return this.bodies.find(function (body) {\n    return body.name == bodyId;\n  });\n};\n\nSolarSystem.prototype.update = function (t, dt) {\n  var _this = this;\n\n  var currentDate = (0, _moment2.default)(t + dt);\n  var T = this._calculateJulianDate(currentDate);\n\n  if (!this.initialized) {\n    /**\n     * Generate a starting position/velocity from the initial kepler\n     * elements\n     */\n    this.bodies.forEach(function (body) {\n      var kepler_elements = _this._calculateInitialKeplerElements(body, T);\n      body.derived = kepler_elements;\n    });\n\n    this.initialized = true;\n  }\n\n  this.bodies.forEach(function (body) {\n\n    var kepler_elements = _this._calculateKeplerElementsAtTime(body, t + dt);\n    var coords = _this._toCartesianCoordinates(body.primary, kepler_elements);\n    var position = coords.position;\n    var velocity = coords.velocity;\n\n    var body_constants = body.constants;\n    var primary = body.primary;\n    var derived = body.derived;\n    var u = body.primary ? primary.constants.u : 0;\n    var offset = body.primary ? primary.derived.position : new _three.Vector3(0, 0, 0);\n    var a = kepler_elements.a,\n        e = kepler_elements.e,\n        I = kepler_elements.I,\n        argumentPerihelion = kepler_elements.argumentPerihelion,\n        omega = kepler_elements.omega,\n        M = kepler_elements.M;\n\n    // Semi-minor axis\n\n    var b = a * Math.sqrt(1 - Math.pow(e, 2));\n\n    // Trajectory Elements\n    var periapsis = new _three.Vector3(a * (1 - e), 0, 0);\n    var apoapsis = new _three.Vector3(-a * (1 + e), 0, 0);\n    var center = new _three.Vector3(periapsis.x - a, 0, 0);\n\n    // Orbital Period and Rotational Period\n    var orbital_period = 2 * Math.PI * Math.sqrt(Math.pow(a, 3) / (u + (body_constants.u || 0)));\n\n    var rotation = (derived.rotation || 0) + 2 * Math.PI * dt / ((body_constants.rotation_period || 1) * 86400e3);\n\n    body.derived = {\n      T: T,\n      a: a,\n      e: e,\n      I: I,\n      omega: omega,\n      argumentPerihelion: argumentPerihelion,\n      M: M,\n      position: position,\n      position_in_plane: coords.position_in_plane,\n      velocity: velocity,\n      semiMajorAxis: a,\n      semiMinorAxis: b,\n      orbital_period: orbital_period,\n      rotation: rotation,\n      center_in_plane: center,\n      center: _this._transformToEcliptic(offset, center, argumentPerihelion, omega, I),\n      periapsis: _this._transformToEcliptic(offset, periapsis, argumentPerihelion, omega, I),\n      apoapsis: _this._transformToEcliptic(offset, apoapsis, argumentPerihelion, omega, I)\n    };\n  });\n\n  this.lastTime = t + dt;\n};\n\nSolarSystem.prototype._calculateInitialKeplerElements = function (body, T) {\n\n  // Planets are fixed on rails; we simply a\n  var kepler_elements = body.kepler_elements;\n  var a = kepler_elements.a[0] + kepler_elements.a[1] * T;\n  var e = kepler_elements.e[0] + kepler_elements.e[1] * T;\n  var I = kepler_elements.I[0] + kepler_elements.I[1] * T;\n  var L = kepler_elements.L[0] + kepler_elements.L[1] * T;\n  var w = kepler_elements.w[0] + kepler_elements.w[1] * T;\n  var omega = kepler_elements.omega[0] + kepler_elements.omega[1] * T;\n  var perturbations = kepler_elements.perturbations;\n  var M = this._calculateMeanAnomaly(L, w, perturbations, T);\n  var argumentPerihelion = w - omega;\n\n  return {\n    a: a,\n    e: e,\n    I: I * Math.PI / 180,\n    omega: omega * Math.PI / 180,\n    argumentPerihelion: argumentPerihelion * Math.PI / 180,\n    M: M * Math.PI / 180\n  };\n};\n\nSolarSystem.prototype._calculateKeplerElementsAtTime = function (body, t) {\n  var _body$derived = body.derived,\n      a = _body$derived.a,\n      e = _body$derived.e,\n      I = _body$derived.I,\n      omega = _body$derived.omega,\n      argumentPerihelion = _body$derived.argumentPerihelion,\n      M = _body$derived.M;\n\n  /**\n   * For elliptical orbits, M - M0 = n(t - t0)\n   */\n\n  var lastTime = this.lastTime || t;\n  var delta = (t - lastTime) / 1000;\n  var u = body.primary ? body.primary.constants.u : 0;\n  var n = Math.sqrt(u / Math.pow(a, 3));\n  M = n * delta + M;\n\n  return {\n    a: a,\n    e: e,\n    I: I,\n    omega: omega,\n    argumentPerihelion: argumentPerihelion,\n    M: M\n  };\n};\n\nSolarSystem.prototype._calculateKeplerElementsFromCartesian = function (body) {\n\n  var primary = body.primary;\n  var position = body.derived.position;\n  var velocity = body.derived.velocity;\n\n  var r = new _three.Vector3().subVectors(position, primary.derived.position);\n  var v = new _three.Vector3().subVectors(velocity, primary.derived.velocity);\n  var u = primary.constants.u;\n\n  var h = new _three.Vector3().crossVectors(r, v);\n\n  if (h.length() <= 0) {\n    console.error(\"angular momentum is zero!\");\n  }\n\n  // Semi-Major Axis\n  var specificEnergy = v.lengthSq() / 2 - u / r.length();\n  var a = -u / (2 * specificEnergy);\n\n  // Eccentricity\n  var e_sub = h.lengthSq() / (u * a);\n  var e = e_sub > 1 ? 0 : Math.sqrt(1 - e_sub);\n\n  // Inclination, Longitude of the ascending node\n  var I = Math.acos(h.z / h.length());\n  var omega = Math.atan2(h.x, -h.y);\n  if (Math.abs(omega) >= Math.PI) {\n    throw new Error('omega jumped');\n  }\n\n  var E = void 0,\n      w = void 0;\n  if (e === 0 && I === 0) {\n    // Circular Orbits with zero inclincation\n\n    var trueLongitude = Math.acos(r.x / r.length());\n    if (v.x > 0) {\n      trueLongitude = 2 * Math.PI - trueLongitude;\n    }\n  } else if (e === 0) {\n    // Circular orbits with a +/- inclincation\n    // True anomaly is undefined for a circular orbit because circular orbits\n    // do not have a uniquely-determined periapsis; Instead, the argument of\n    // latitude is used:\n    var argumentLatitude = Math.atan2(r.z / Math.sin(I), r.x * Math.cos(omega) + r.y * Math.sin(omega));\n    E = 2 * Math.atan(Math.tan(argumentLatitude / 2));\n    w = 0;\n  } else {\n    var v_eccentricity = new _three.Vector3().crossVectors(v, h).multiplyScalar(1 / u).sub(r.clone().multiplyScalar(1 / r.length()));\n\n    var trueAnomaly = Math.acos(v_eccentricity.dot(r) / (v_eccentricity.length() * r.length()));\n    if (r.dot(v) < 0) trueAnomaly = 2 * Math.PI - trueAnomaly;\n\n    var _argumentLatitude = Math.atan2(r.z / Math.sin(I), r.x * Math.cos(omega) + r.y * Math.sin(omega));\n    E = 2 * Math.atan(Math.sqrt((1 - e) / (1 + e)) * Math.tan(trueAnomaly / 2));\n    w = _argumentLatitude - trueAnomaly;\n  }\n\n  var M = E - e * Math.sin(E);\n  var L = M + w;\n\n  var calculated_kepler_elements = {\n    a: a,\n    e: e,\n    I: I * 180 / Math.PI,\n    w: w * 180 / Math.PI,\n    omega: omega * 180 / Math.PI,\n    M: M * 180 / Math.PI,\n    E: E * 180 / Math.PI\n  };\n\n  return calculated_kepler_elements;\n};\n\nSolarSystem.prototype._toCartesianCoordinates = function (primary, kepler_elements) {\n  var a = kepler_elements.a,\n      e = kepler_elements.e,\n      I = kepler_elements.I,\n      argumentPerihelion = kepler_elements.argumentPerihelion,\n      omega = kepler_elements.omega,\n      M = kepler_elements.M;\n\n\n  var u = primary ? primary.constants.u : 0;\n  var offset = primary ? primary.derived.position : new _three.Vector3(0, 0, 0);\n  var E = this._calculateEccentricAnomaly(e, M * 180 / Math.PI) * Math.PI / 180;\n\n  var trueAnomaly = 2 * Math.atan2(Math.sqrt(1 + e) * Math.sin(E / 2), Math.sqrt(1 - e) * Math.cos(E / 2));\n\n  // Calculate heliocentric coordinates in the planets orbital plane\n  var helioCentricPosition = new _three.Vector3(a * (Math.cos(E) - e), a * Math.sqrt(1 - Math.pow(e, 2)) * Math.sin(E), 0);\n\n  // Convert to the ecliptic plane\n  var eclipticPosition = this._transformToEcliptic(offset, helioCentricPosition, argumentPerihelion, omega, I);\n\n  // Calculate the velocity in the planets orbital planet\n  var helioCentricVelocity = new _three.Vector3(-Math.sin(trueAnomaly), e + Math.cos(trueAnomaly), 0).multiplyScalar(Math.sqrt(u / Math.pow(a, 3)) * a / Math.sqrt(1 - Math.pow(e, 2)));\n\n  // Convert to the ecliptic plane\n  var eclipticVelocity = this._transformToEcliptic(new _three.Vector3(0, 0, 0), helioCentricVelocity, argumentPerihelion, omega, I);\n\n  return {\n    meanAnomaly: M,\n    eccentricAnomaly: E,\n    trueAnomaly: trueAnomaly,\n    position: eclipticPosition,\n    position_in_plane: helioCentricPosition,\n    velocity: eclipticVelocity,\n    velocity_in_plane: helioCentricVelocity\n  };\n};\n\nSolarSystem.prototype._calculateJulianDate = function (date) {\n  var Teph = J2000_epoch + date.diff(J2000_date, 'days', true);\n  var T = (Teph - J2000_epoch) / 36525;\n  return T;\n};\n\nSolarSystem.prototype._calculateMeanAnomaly = function (L, w, perturbations, T) {\n\n  var M = L - w;\n  if (perturbations) {\n    M += perturbations.b * Math.pow(T, 2) + perturbations.c * Math.cos(perturbations.f * T) + perturbations.s * Math.sin(perturbations.f * T);\n  }\n\n  M = M % 360;\n  if (M > 180) {\n    M = M - 360;\n  } else if (M < -180) {\n    M = 360 + M;\n  }\n\n  return M;\n};\n\nSolarSystem.prototype._calculateEccentricAnomaly = function (e, M) {\n  // Calculate eccentric anomaly, E\n  // e_star = degrees\n  // e = radians\n  var tol = 10e-6;\n  var e_star = 57.29578 * e;\n  var E = M + e_star * Math.sin(Math.PI / 180 * M);\n  var deltaE = void 0,\n      deltaM = void 0;\n  var numTimes = 0;\n  do {\n    deltaM = M - (E - e_star * Math.sin(Math.PI / 180 * E));\n    deltaE = deltaM / (1 - e * Math.cos(Math.PI / 180 * E));\n    E = E + deltaE;\n    numTimes++;\n  } while (Math.abs(deltaE) > tol && numTimes <= 10);\n\n  if (numTimes === 10) {\n    console.log(\"Didn't iterate on a solution!\");\n  }\n\n  return E;\n};\n\nSolarSystem.prototype._transformToEcliptic = function (offset, position, w, omega, I) {\n\n  var Q1 = new _three.Quaternion().setFromAxisAngle(new _three.Vector3(0, 0, 1), w);\n  var Q2 = new _three.Quaternion().setFromAxisAngle(new _three.Vector3(1, 0, 0), I);\n  var Q3 = new _three.Quaternion().setFromAxisAngle(new _three.Vector3(0, 0, 1), omega);\n\n  var rotation = new _three.Vector3().copy(position).applyQuaternion(Q1).applyQuaternion(Q2).applyQuaternion(Q3);\n\n  return rotation.add(offset);\n};\n\nexports.default = SolarSystem;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvU29sYXJTeXN0ZW0uanM/MGYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge1xuICBBVSxcbiAgQUxMX0JPRElFUyxcbn0gZnJvbSAnLi9Cb2RpZXMnO1xuXG5pbXBvcnQge1xuICBWZWN0b3IzLFxuICBRdWF0ZXJuaW9uLFxuICBNYXRyaXgzLFxuICBFdWxlcixcbn0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBKMjAwMF9kYXRlID0gbW9tZW50KCcyMDAwLTAxLTAxVDEyOjAwOjAwWicpO1xuY29uc3QgSjIwMDBfZXBvY2ggPSAyNDUxNTQ1LjA7XG5cbmZ1bmN0aW9uIFNvbGFyU3lzdGVtKCkge1xuICB0aGlzLmJvZGllcyA9IEFycmF5LmZyb20oQUxMX0JPRElFUyk7XG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cblNvbGFyU3lzdGVtLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGJvZHlJZCkge1xuICByZXR1cm4gdGhpcy5ib2RpZXMuZmluZCgoYm9keSkgPT4gYm9keS5uYW1lID09IGJvZHlJZCk7XG59O1xuXG5Tb2xhclN5c3RlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHQsIGR0KSB7XG5cbiAgbGV0IGN1cnJlbnREYXRlID0gbW9tZW50KHQgKyBkdCk7XG4gIGxldCBUID0gdGhpcy5fY2FsY3VsYXRlSnVsaWFuRGF0ZShjdXJyZW50RGF0ZSk7XG5cbiAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdGFydGluZyBwb3NpdGlvbi92ZWxvY2l0eSBmcm9tIHRoZSBpbml0aWFsIGtlcGxlclxuICAgICAqIGVsZW1lbnRzXG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMuZm9yRWFjaCgoYm9keSkgPT4ge1xuICAgICAgbGV0IGtlcGxlcl9lbGVtZW50cyA9IHRoaXMuX2NhbGN1bGF0ZUluaXRpYWxLZXBsZXJFbGVtZW50cyhib2R5LCBUKTtcbiAgICAgIGJvZHkuZGVyaXZlZCA9IGtlcGxlcl9lbGVtZW50cztcbiAgICB9KTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5ib2RpZXMuZm9yRWFjaCgoYm9keSkgPT4ge1xuXG4gICAgbGV0IGtlcGxlcl9lbGVtZW50cyA9IHRoaXMuX2NhbGN1bGF0ZUtlcGxlckVsZW1lbnRzQXRUaW1lKGJvZHksIHQgKyBkdCk7XG4gICAgbGV0IGNvb3JkcyA9IHRoaXMuX3RvQ2FydGVzaWFuQ29vcmRpbmF0ZXMoYm9keS5wcmltYXJ5LCBrZXBsZXJfZWxlbWVudHMpO1xuICAgIGxldCBwb3NpdGlvbiA9IGNvb3Jkcy5wb3NpdGlvbjtcbiAgICBsZXQgdmVsb2NpdHkgPSBjb29yZHMudmVsb2NpdHk7XG5cbiAgICBsZXQgYm9keV9jb25zdGFudHMgPSBib2R5LmNvbnN0YW50cztcbiAgICBsZXQgcHJpbWFyeSA9IGJvZHkucHJpbWFyeTtcbiAgICBsZXQgZGVyaXZlZCA9IGJvZHkuZGVyaXZlZDtcbiAgICBsZXQgdSA9IGJvZHkucHJpbWFyeSA/IHByaW1hcnkuY29uc3RhbnRzLnUgOiAwO1xuICAgIGxldCBvZmZzZXQgPSBib2R5LnByaW1hcnkgPyBwcmltYXJ5LmRlcml2ZWQucG9zaXRpb24gOiBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBsZXQge1xuICAgICAgYSxcbiAgICAgIGUsXG4gICAgICBJLFxuICAgICAgYXJndW1lbnRQZXJpaGVsaW9uLFxuICAgICAgb21lZ2EsXG4gICAgICBNLFxuICAgIH0gPSBrZXBsZXJfZWxlbWVudHM7XG5cbiAgICAvLyBTZW1pLW1pbm9yIGF4aXNcbiAgICBsZXQgYiA9IGEgKiBNYXRoLnNxcnQoMSAtIE1hdGgucG93KGUsIDIpKTtcblxuICAgIC8vIFRyYWplY3RvcnkgRWxlbWVudHNcbiAgICBsZXQgcGVyaWFwc2lzID0gbmV3IFZlY3RvcjMoYSAqICgxIC0gZSksIDAsIDApO1xuICAgIGxldCBhcG9hcHNpcyA9IG5ldyBWZWN0b3IzKC1hICogKDEgKyBlKSwgMCwgMCk7XG4gICAgbGV0IGNlbnRlciA9IG5ldyBWZWN0b3IzKHBlcmlhcHNpcy54IC0gYSwgMCwgMCk7XG5cbiAgICAvLyBPcmJpdGFsIFBlcmlvZCBhbmQgUm90YXRpb25hbCBQZXJpb2RcbiAgICBsZXQgb3JiaXRhbF9wZXJpb2QgPSAyICogTWF0aC5QSSAqIE1hdGguc3FydChNYXRoLnBvdyhhLCAzKSAvXG4gICAgICAodSArIChib2R5X2NvbnN0YW50cy51IHx8IDApKSk7XG5cbiAgICBsZXQgcm90YXRpb24gPSAoZGVyaXZlZC5yb3RhdGlvbiB8fCAwKSArXG4gICAgICAyICogTWF0aC5QSSAqIGR0IC9cbiAgICAgICgoYm9keV9jb25zdGFudHMucm90YXRpb25fcGVyaW9kIHx8IDEpICogODY0MDBlMyk7XG5cbiAgICBib2R5LmRlcml2ZWQgPSB7XG4gICAgICBUOiBULFxuICAgICAgYTogYSxcbiAgICAgIGU6IGUsXG4gICAgICBJOiBJLFxuICAgICAgb21lZ2E6IG9tZWdhLFxuICAgICAgYXJndW1lbnRQZXJpaGVsaW9uOiBhcmd1bWVudFBlcmloZWxpb24sXG4gICAgICBNOiBNLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgcG9zaXRpb25faW5fcGxhbmU6IGNvb3Jkcy5wb3NpdGlvbl9pbl9wbGFuZSxcbiAgICAgIHZlbG9jaXR5OiB2ZWxvY2l0eSxcbiAgICAgIHNlbWlNYWpvckF4aXM6IGEsXG4gICAgICBzZW1pTWlub3JBeGlzOiBiLFxuICAgICAgb3JiaXRhbF9wZXJpb2Q6IG9yYml0YWxfcGVyaW9kLFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgY2VudGVyX2luX3BsYW5lOiBjZW50ZXIsXG4gICAgICBjZW50ZXI6IHRoaXMuX3RyYW5zZm9ybVRvRWNsaXB0aWMob2Zmc2V0LCBjZW50ZXIsIGFyZ3VtZW50UGVyaWhlbGlvbiwgb21lZ2EsIEkpLFxuICAgICAgcGVyaWFwc2lzOiB0aGlzLl90cmFuc2Zvcm1Ub0VjbGlwdGljKG9mZnNldCwgcGVyaWFwc2lzLCBhcmd1bWVudFBlcmloZWxpb24sIG9tZWdhLCBJKSxcbiAgICAgIGFwb2Fwc2lzOiB0aGlzLl90cmFuc2Zvcm1Ub0VjbGlwdGljKG9mZnNldCwgYXBvYXBzaXMsIGFyZ3VtZW50UGVyaWhlbGlvbiwgb21lZ2EsIEkpLFxuICAgIH1cblxuICB9KTtcblxuICB0aGlzLmxhc3RUaW1lID0gdCArIGR0O1xufTtcblxuU29sYXJTeXN0ZW0ucHJvdG90eXBlLl9jYWxjdWxhdGVJbml0aWFsS2VwbGVyRWxlbWVudHMgPSBmdW5jdGlvbiAoYm9keSwgVCkge1xuXG4gIC8vIFBsYW5ldHMgYXJlIGZpeGVkIG9uIHJhaWxzOyB3ZSBzaW1wbHkgYVxuICBsZXQga2VwbGVyX2VsZW1lbnRzID0gYm9keS5rZXBsZXJfZWxlbWVudHM7XG4gIGxldCBhID0ga2VwbGVyX2VsZW1lbnRzLmFbMF0gKyBrZXBsZXJfZWxlbWVudHMuYVsxXSAqIFQ7XG4gIGxldCBlID0ga2VwbGVyX2VsZW1lbnRzLmVbMF0gKyBrZXBsZXJfZWxlbWVudHMuZVsxXSAqIFQ7XG4gIGxldCBJID0ga2VwbGVyX2VsZW1lbnRzLklbMF0gKyBrZXBsZXJfZWxlbWVudHMuSVsxXSAqIFQ7XG4gIGxldCBMID0ga2VwbGVyX2VsZW1lbnRzLkxbMF0gKyBrZXBsZXJfZWxlbWVudHMuTFsxXSAqIFQ7XG4gIGxldCB3ID0ga2VwbGVyX2VsZW1lbnRzLndbMF0gKyBrZXBsZXJfZWxlbWVudHMud1sxXSAqIFQ7XG4gIGxldCBvbWVnYSA9IGtlcGxlcl9lbGVtZW50cy5vbWVnYVswXSArIGtlcGxlcl9lbGVtZW50cy5vbWVnYVsxXSAqIFQ7XG4gIGxldCBwZXJ0dXJiYXRpb25zID0ga2VwbGVyX2VsZW1lbnRzLnBlcnR1cmJhdGlvbnM7XG4gIGxldCBNID0gdGhpcy5fY2FsY3VsYXRlTWVhbkFub21hbHkoTCwgdywgcGVydHVyYmF0aW9ucywgVCk7XG4gIGxldCBhcmd1bWVudFBlcmloZWxpb24gPSB3IC0gb21lZ2E7XG5cbiAgcmV0dXJuIHtcbiAgICBhOiBhLFxuICAgIGU6IGUsXG4gICAgSTogSSAqIE1hdGguUEkgLyAxODAsXG4gICAgb21lZ2E6IG9tZWdhICogTWF0aC5QSSAvIDE4MCxcbiAgICBhcmd1bWVudFBlcmloZWxpb246IGFyZ3VtZW50UGVyaWhlbGlvbiAqIE1hdGguUEkgLyAxODAsXG4gICAgTTogTSAqIE1hdGguUEkgLyAxODAsXG4gIH07XG59O1xuXG5Tb2xhclN5c3RlbS5wcm90b3R5cGUuX2NhbGN1bGF0ZUtlcGxlckVsZW1lbnRzQXRUaW1lID0gZnVuY3Rpb24gKGJvZHksIHQpIHtcblxuICBsZXQge1xuICAgIGEsXG4gICAgZSxcbiAgICBJLFxuICAgIG9tZWdhLFxuICAgIGFyZ3VtZW50UGVyaWhlbGlvbixcbiAgICBNXG4gIH0gPSBib2R5LmRlcml2ZWQ7XG5cbiAgLyoqXG4gICAqIEZvciBlbGxpcHRpY2FsIG9yYml0cywgTSAtIE0wID0gbih0IC0gdDApXG4gICAqL1xuXG4gIGxldCBsYXN0VGltZSA9IHRoaXMubGFzdFRpbWUgfHwgdDtcbiAgbGV0IGRlbHRhID0gKHQgLSBsYXN0VGltZSkgLyAxMDAwO1xuICBsZXQgdSA9IGJvZHkucHJpbWFyeSA/IGJvZHkucHJpbWFyeS5jb25zdGFudHMudSA6IDA7XG4gIGxldCBuID0gTWF0aC5zcXJ0KHUgLyBNYXRoLnBvdyhhLCAzKSk7XG4gIE0gPSBuICogZGVsdGEgKyBNO1xuXG4gIHJldHVybiB7XG4gICAgYSxcbiAgICBlLFxuICAgIEksXG4gICAgb21lZ2EsXG4gICAgYXJndW1lbnRQZXJpaGVsaW9uLFxuICAgIE1cbiAgfTtcbn07XG5cblNvbGFyU3lzdGVtLnByb3RvdHlwZS5fY2FsY3VsYXRlS2VwbGVyRWxlbWVudHNGcm9tQ2FydGVzaWFuID0gZnVuY3Rpb24gKGJvZHkpIHtcblxuICBsZXQgcHJpbWFyeSA9IGJvZHkucHJpbWFyeTtcbiAgbGV0IHBvc2l0aW9uID0gYm9keS5kZXJpdmVkLnBvc2l0aW9uO1xuICBsZXQgdmVsb2NpdHkgPSBib2R5LmRlcml2ZWQudmVsb2NpdHk7XG5cbiAgbGV0IHIgPSBuZXcgVmVjdG9yMygpXG4gICAgLnN1YlZlY3RvcnMocG9zaXRpb24sIHByaW1hcnkuZGVyaXZlZC5wb3NpdGlvbik7XG4gIGxldCB2ID0gbmV3IFZlY3RvcjMoKVxuICAgIC5zdWJWZWN0b3JzKHZlbG9jaXR5LCBwcmltYXJ5LmRlcml2ZWQudmVsb2NpdHkpO1xuICBsZXQgdSA9IHByaW1hcnkuY29uc3RhbnRzLnU7XG5cbiAgY29uc3QgaCA9IG5ldyBWZWN0b3IzKClcbiAgICAuY3Jvc3NWZWN0b3JzKHIsIHYpO1xuXG4gIGlmIChoLmxlbmd0aCgpIDw9IDApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiYW5ndWxhciBtb21lbnR1bSBpcyB6ZXJvIVwiKTtcbiAgfVxuXG4gIC8vIFNlbWktTWFqb3IgQXhpc1xuICBjb25zdCBzcGVjaWZpY0VuZXJneSA9IHYubGVuZ3RoU3EoKSAvIDIgLSB1IC8gci5sZW5ndGgoKTtcbiAgY29uc3QgYSA9IC11IC8gKDIgKiBzcGVjaWZpY0VuZXJneSk7XG5cbiAgLy8gRWNjZW50cmljaXR5XG4gIGNvbnN0IGVfc3ViID0gaC5sZW5ndGhTcSgpIC8gKHUgKiBhKTtcbiAgY29uc3QgZSA9IGVfc3ViID4gMSA/IDAgOiBNYXRoLnNxcnQoMSAtIGVfc3ViKTtcblxuICAvLyBJbmNsaW5hdGlvbiwgTG9uZ2l0dWRlIG9mIHRoZSBhc2NlbmRpbmcgbm9kZVxuICBjb25zdCBJID0gTWF0aC5hY29zKGgueiAvIGgubGVuZ3RoKCkpO1xuICBjb25zdCBvbWVnYSA9IE1hdGguYXRhbjIoaC54LCAtaC55KTtcbiAgaWYgKE1hdGguYWJzKG9tZWdhKSA+PSBNYXRoLlBJKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvbWVnYSBqdW1wZWQnKTtcbiAgfVxuXG4gIGxldCBFLCB3O1xuICBpZiAoZSA9PT0gMCAmJiBJID09PSAwKSB7XG4gICAgLy8gQ2lyY3VsYXIgT3JiaXRzIHdpdGggemVybyBpbmNsaW5jYXRpb25cblxuICAgIGxldCB0cnVlTG9uZ2l0dWRlID0gTWF0aC5hY29zKHIueCAvIHIubGVuZ3RoKCkpO1xuICAgIGlmICh2LnggPiAwKSB7XG4gICAgICB0cnVlTG9uZ2l0dWRlID0gMiAqIE1hdGguUEkgLSB0cnVlTG9uZ2l0dWRlO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKGUgPT09IDApIHtcbiAgICAvLyBDaXJjdWxhciBvcmJpdHMgd2l0aCBhICsvLSBpbmNsaW5jYXRpb25cbiAgICAvLyBUcnVlIGFub21hbHkgaXMgdW5kZWZpbmVkIGZvciBhIGNpcmN1bGFyIG9yYml0IGJlY2F1c2UgY2lyY3VsYXIgb3JiaXRzXG4gICAgLy8gZG8gbm90IGhhdmUgYSB1bmlxdWVseS1kZXRlcm1pbmVkIHBlcmlhcHNpczsgSW5zdGVhZCwgdGhlIGFyZ3VtZW50IG9mXG4gICAgLy8gbGF0aXR1ZGUgaXMgdXNlZDpcbiAgICBjb25zdCBhcmd1bWVudExhdGl0dWRlID0gTWF0aC5hdGFuMihyLnogLyBNYXRoLnNpbihJKSwgci54ICogTWF0aC5jb3Mob21lZ2EpICsgci55ICogTWF0aC5zaW4ob21lZ2EpKTtcbiAgICBFID0gMiAqIE1hdGguYXRhbihNYXRoLnRhbihhcmd1bWVudExhdGl0dWRlIC8gMikpO1xuICAgIHcgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxldCB2X2VjY2VudHJpY2l0eSA9IG5ldyBWZWN0b3IzKClcbiAgICAgIC5jcm9zc1ZlY3RvcnModiwgaClcbiAgICAgIC5tdWx0aXBseVNjYWxhcigxIC8gdSlcbiAgICAgIC5zdWIoci5jbG9uZSgpXG4gICAgICAgIC5tdWx0aXBseVNjYWxhcigxIC8gci5sZW5ndGgoKSkpXG5cbiAgICBsZXQgdHJ1ZUFub21hbHkgPSBNYXRoLmFjb3Modl9lY2NlbnRyaWNpdHkuZG90KHIpIC8gKHZfZWNjZW50cmljaXR5Lmxlbmd0aCgpICogci5sZW5ndGgoKSkpO1xuICAgIGlmIChyLmRvdCh2KSA8IDApXG4gICAgICB0cnVlQW5vbWFseSA9IDIgKiBNYXRoLlBJIC0gdHJ1ZUFub21hbHk7XG5cbiAgICBsZXQgYXJndW1lbnRMYXRpdHVkZSA9IE1hdGguYXRhbjIoci56IC8gTWF0aC5zaW4oSSksIHIueCAqIE1hdGguY29zKG9tZWdhKSArIHIueSAqIE1hdGguc2luKG9tZWdhKSk7XG4gICAgRSA9IDIgKiBNYXRoLmF0YW4oTWF0aC5zcXJ0KCgxIC0gZSkgLyAoMSArIGUpKSAqIE1hdGgudGFuKHRydWVBbm9tYWx5IC8gMikpO1xuICAgIHcgPSBhcmd1bWVudExhdGl0dWRlIC0gdHJ1ZUFub21hbHk7XG4gIH1cblxuICBjb25zdCBNID0gRSAtIGUgKiBNYXRoLnNpbihFKTtcbiAgY29uc3QgTCA9IE0gKyB3O1xuXG4gIGNvbnN0IGNhbGN1bGF0ZWRfa2VwbGVyX2VsZW1lbnRzID0ge1xuICAgIGE6IGEsXG4gICAgZTogZSxcbiAgICBJOiBJICogMTgwIC8gTWF0aC5QSSxcbiAgICB3OiB3ICogMTgwIC8gTWF0aC5QSSxcbiAgICBvbWVnYTogb21lZ2EgKiAxODAgLyBNYXRoLlBJLFxuICAgIE06IE0gKiAxODAgLyBNYXRoLlBJLFxuICAgIEU6IEUgKiAxODAgLyBNYXRoLlBJLFxuICB9O1xuXG4gIHJldHVybiBjYWxjdWxhdGVkX2tlcGxlcl9lbGVtZW50cztcbn07XG5cblNvbGFyU3lzdGVtLnByb3RvdHlwZS5fdG9DYXJ0ZXNpYW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChwcmltYXJ5LCBrZXBsZXJfZWxlbWVudHMpIHtcblxuICBsZXQge1xuICAgIGEsXG4gICAgZSxcbiAgICBJLFxuICAgIGFyZ3VtZW50UGVyaWhlbGlvbixcbiAgICBvbWVnYSxcbiAgICBNLFxuICB9ID0ga2VwbGVyX2VsZW1lbnRzO1xuXG4gIGxldCB1ID0gcHJpbWFyeSA/IHByaW1hcnkuY29uc3RhbnRzLnUgOiAwO1xuICBsZXQgb2Zmc2V0ID0gcHJpbWFyeSA/IHByaW1hcnkuZGVyaXZlZC5wb3NpdGlvbiA6IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICBsZXQgRSA9IHRoaXMuX2NhbGN1bGF0ZUVjY2VudHJpY0Fub21hbHkoZSwgTSAqIDE4MCAvIE1hdGguUEkpICogTWF0aC5QSSAvIDE4MDtcblxuICBsZXQgdHJ1ZUFub21hbHkgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoMSArIGUpICogTWF0aC5zaW4oRSAvIDIpLFxuICAgIE1hdGguc3FydCgxIC0gZSkgKiBNYXRoLmNvcyhFIC8gMikpO1xuXG4gIC8vIENhbGN1bGF0ZSBoZWxpb2NlbnRyaWMgY29vcmRpbmF0ZXMgaW4gdGhlIHBsYW5ldHMgb3JiaXRhbCBwbGFuZVxuICBsZXQgaGVsaW9DZW50cmljUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhcbiAgICBhICogKE1hdGguY29zKEUpIC0gZSksXG4gICAgYSAqIE1hdGguc3FydCgxIC0gTWF0aC5wb3coZSwgMikpICogTWF0aC5zaW4oRSksXG4gICAgMCk7XG5cbiAgLy8gQ29udmVydCB0byB0aGUgZWNsaXB0aWMgcGxhbmVcbiAgbGV0IGVjbGlwdGljUG9zaXRpb24gPSB0aGlzLl90cmFuc2Zvcm1Ub0VjbGlwdGljKFxuICAgIG9mZnNldCxcbiAgICBoZWxpb0NlbnRyaWNQb3NpdGlvbixcbiAgICBhcmd1bWVudFBlcmloZWxpb24sXG4gICAgb21lZ2EsXG4gICAgSSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBpbiB0aGUgcGxhbmV0cyBvcmJpdGFsIHBsYW5ldFxuICBsZXQgaGVsaW9DZW50cmljVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygtTWF0aC5zaW4odHJ1ZUFub21hbHkpLFxuICAgICAgZSArIE1hdGguY29zKHRydWVBbm9tYWx5KSxcbiAgICAgIDApXG4gICAgLm11bHRpcGx5U2NhbGFyKChNYXRoLnNxcnQodSAvIE1hdGgucG93KGEsIDMpKSAqIGEpIC8gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyhlLCAyKSkpO1xuXG4gIC8vIENvbnZlcnQgdG8gdGhlIGVjbGlwdGljIHBsYW5lXG4gIGxldCBlY2xpcHRpY1ZlbG9jaXR5ID0gdGhpcy5fdHJhbnNmb3JtVG9FY2xpcHRpYyhcbiAgICBuZXcgVmVjdG9yMygwLCAwLCAwKSxcbiAgICBoZWxpb0NlbnRyaWNWZWxvY2l0eSxcbiAgICBhcmd1bWVudFBlcmloZWxpb24sXG4gICAgb21lZ2EsXG4gICAgSSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZWFuQW5vbWFseTogTSxcbiAgICBlY2NlbnRyaWNBbm9tYWx5OiBFLFxuICAgIHRydWVBbm9tYWx5OiB0cnVlQW5vbWFseSxcbiAgICBwb3NpdGlvbjogZWNsaXB0aWNQb3NpdGlvbixcbiAgICBwb3NpdGlvbl9pbl9wbGFuZTogaGVsaW9DZW50cmljUG9zaXRpb24sXG4gICAgdmVsb2NpdHk6IGVjbGlwdGljVmVsb2NpdHksXG4gICAgdmVsb2NpdHlfaW5fcGxhbmU6IGhlbGlvQ2VudHJpY1ZlbG9jaXR5LFxuICB9O1xufTtcblxuU29sYXJTeXN0ZW0ucHJvdG90eXBlLl9jYWxjdWxhdGVKdWxpYW5EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgbGV0IFRlcGggPSBKMjAwMF9lcG9jaCArIGRhdGUuZGlmZihKMjAwMF9kYXRlLCAnZGF5cycsIHRydWUpO1xuICBsZXQgVCA9IChUZXBoIC0gSjIwMDBfZXBvY2gpIC8gMzY1MjU7XG4gIHJldHVybiBUO1xufTtcblxuU29sYXJTeXN0ZW0ucHJvdG90eXBlLl9jYWxjdWxhdGVNZWFuQW5vbWFseSA9IGZ1bmN0aW9uIChMLCB3LCBwZXJ0dXJiYXRpb25zLCBUKSB7XG5cbiAgbGV0IE0gPSBMIC0gdztcbiAgaWYgKHBlcnR1cmJhdGlvbnMpIHtcbiAgICBNICs9IHBlcnR1cmJhdGlvbnMuYiAqIE1hdGgucG93KFQsIDIpICtcbiAgICAgIHBlcnR1cmJhdGlvbnMuYyAqIE1hdGguY29zKHBlcnR1cmJhdGlvbnMuZiAqIFQpICtcbiAgICAgIHBlcnR1cmJhdGlvbnMucyAqIE1hdGguc2luKHBlcnR1cmJhdGlvbnMuZiAqIFQpO1xuICB9XG5cbiAgTSA9IE0gJSAzNjA7XG4gIGlmIChNID4gMTgwKSB7XG4gICAgTSA9IE0gLSAzNjA7XG4gIH0gZWxzZSBpZiAoTSA8IC0xODApIHtcbiAgICBNID0gMzYwICsgTTtcbiAgfVxuXG4gIHJldHVybiBNO1xufTtcblxuU29sYXJTeXN0ZW0ucHJvdG90eXBlLl9jYWxjdWxhdGVFY2NlbnRyaWNBbm9tYWx5ID0gZnVuY3Rpb24gKGUsIE0pIHtcbiAgLy8gQ2FsY3VsYXRlIGVjY2VudHJpYyBhbm9tYWx5LCBFXG4gIC8vIGVfc3RhciA9IGRlZ3JlZXNcbiAgLy8gZSA9IHJhZGlhbnNcbiAgbGV0IHRvbCA9IDEwZS02O1xuICBsZXQgZV9zdGFyID0gNTcuMjk1NzggKiBlO1xuICBsZXQgRSA9IE0gKyBlX3N0YXIgKiBNYXRoLnNpbigoTWF0aC5QSSAvIDE4MCkgKiBNKTtcbiAgbGV0IGRlbHRhRSwgZGVsdGFNO1xuICBsZXQgbnVtVGltZXMgPSAwO1xuICBkbyB7XG4gICAgZGVsdGFNID0gTSAtIChFIC0gZV9zdGFyICogTWF0aC5zaW4oKE1hdGguUEkgLyAxODApICogRSkpO1xuICAgIGRlbHRhRSA9IGRlbHRhTSAvICgxIC0gZSAqIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIEUpKTtcbiAgICBFID0gRSArIGRlbHRhRTtcbiAgICBudW1UaW1lcysrO1xuICB9IHdoaWxlIChNYXRoLmFicyhkZWx0YUUpID4gdG9sICYmIG51bVRpbWVzIDw9IDEwKTtcblxuICBpZiAobnVtVGltZXMgPT09IDEwKSB7XG4gICAgY29uc29sZS5sb2coXCJEaWRuJ3QgaXRlcmF0ZSBvbiBhIHNvbHV0aW9uIVwiKTtcbiAgfVxuXG4gIHJldHVybiBFO1xufTtcblxuU29sYXJTeXN0ZW0ucHJvdG90eXBlLl90cmFuc2Zvcm1Ub0VjbGlwdGljID0gZnVuY3Rpb24gKG9mZnNldCwgcG9zaXRpb24sIHcsIG9tZWdhLCBJKSB7XG5cbiAgbGV0IFExID0gbmV3IFF1YXRlcm5pb24oKVxuICAgIC5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBWZWN0b3IzKDAsIDAsIDEpLCB3KTtcbiAgbGV0IFEyID0gbmV3IFF1YXRlcm5pb24oKVxuICAgIC5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBWZWN0b3IzKDEsIDAsIDApLCBJKTtcbiAgbGV0IFEzID0gbmV3IFF1YXRlcm5pb24oKVxuICAgIC5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBvbWVnYSk7XG5cbiAgY29uc3Qgcm90YXRpb24gPSBuZXcgVmVjdG9yMygpXG4gICAgLmNvcHkocG9zaXRpb24pXG4gICAgLmFwcGx5UXVhdGVybmlvbihRMSlcbiAgICAuYXBwbHlRdWF0ZXJuaW9uKFEyKVxuICAgIC5hcHBseVF1YXRlcm5pb24oUTMpO1xuXG4gIHJldHVybiByb3RhdGlvbi5hZGQob2Zmc2V0KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNvbGFyU3lzdGVtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hcHAvU29sYXJTeXN0ZW0uanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFJQTtBQUNBOzs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar OrbitControls = __webpack_require__(4)(THREE);\n\nvar POINTS = 8;\n\nfunction TestingRenderer(container) {\n\n  this.width = window.innerWidth;\n  this.height = window.innerHeight;\n  this.renderer = new THREE.WebGLRenderer();\n  this.renderer.setSize(this.width, this.height);\n\n  this.container = container;\n  container.appendChild(this.renderer.domElement);\n\n  this.scene = new THREE.Scene();\n};\n\nTestingRenderer.prototype.recenter = function () {};\n\nTestingRenderer.prototype.viewDidLoad = function (solarSystem) {\n\n  // initialize camera and scene\n  this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.01, 1000);\n  this.camera.position.z = 50;\n  this.scene.background = new THREE.Color('gray');\n\n  this.threeBody = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshBasicMaterial({\n    color: 'black'\n  }));\n\n  var curve = new THREE.EllipseCurve(0, 0, // ax, aY\n  1, 1, // xRadius, yRadius\n  0, 2 * Math.PI, // aStartAngle, aEndAngle\n  false, // aClockwise\n  0 // aRotation\n  );\n\n  var pointsGeometry = new THREE.Path(curve.getPoints(POINTS)).createPointsGeometry(POINTS);\n\n  //Create the final object to add to the scene\n  var bufferGeometry = new THREE.BufferGeometry();\n  var vertices = [];\n  for (var i = 0; i < pointsGeometry.vertices.length; i++) {\n    vertices.push(pointsGeometry.vertices[i].x, pointsGeometry.vertices[i].y, pointsGeometry.vertices[i].z);\n  }\n\n  this.originalVertices = Array.from(vertices);\n  bufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\n  var ellipse = new THREE.Line(bufferGeometry, new THREE.LineBasicMaterial({\n    color: 0xff0000\n  }));\n\n  //\n  // const ellipse = new THREE.Line(new THREE.RingGeometry(1, 1, 8),\n  //   new THREE.LineBasicMaterial({\n  //     color: 'red'\n  //   }));\n\n  this.ellipse = ellipse;\n  this.ellipse.scale.set(10, 5, 1);\n  // this.ellipse.matrix.setPosition(new THREE.Vector3(0, 0, 0));\n  // this.ellipse.matrix.scale(new THREE.Vector3(10, 5, 1));\n  // this.ellipse.matrixAutoUpdate = false;\n\n  this.angle = 0;\n\n  this.scene.add(this.threeBody);\n  this.scene.add(this.ellipse);\n  this.renderer.render(this.scene, this.camera);\n  this.orbitControls = new OrbitControls(this.camera, this.scene.domElement);\n\n  return Promise.resolve();\n};\n\nTestingRenderer.prototype.viewWillAppear = function () {};\nTestingRenderer.prototype.viewWillDisappear = function () {};\n\nTestingRenderer.prototype.render = function (solarSystem) {\n  var _this = this;\n\n  var threeBody = this.threeBody;\n  threeBody.position.set(10 * Math.cos(this.angle), 5 * Math.sin(this.angle), 0);\n\n  var scaledPosition = new THREE.Vector3().copy(threeBody.position).multiply(new THREE.Vector3(1 / 10, 1 / 5, 1));\n\n  // let newVertices = [];\n  // let angle = this.angle;\n  // for (let i = 0; i < 9; i++) {\n  //\n  //   let vertex = new THREE.Vector3(10 * Math.cos(angle), 5 * Math.sin(angle), 0);\n  //   newVertices.push(vertex);\n  //   angle += 2 * Math.PI / 8;\n  // }\n  //\n  //\n\n  var geometry = this.ellipse.geometry;\n  var positions = geometry.attributes.position.array;\n  var range = Math.floor(positions.length / 3 / 2);\n  var verticesToTest = [];\n\n  for (var i = 0; i < range; i++) {\n    var offset = (i * 2 + 1) * 3;\n    verticesToTest.push(new THREE.Vector3(this.originalVertices[offset], this.originalVertices[offset + 1], this.originalVertices[offset + 2]));\n  };\n\n  var sorted = verticesToTest.map(function (vertex, idx) {\n    return [vertex.distanceTo(scaledPosition), vertex, idx];\n  }).sort(function (left, right) {\n    return left[0] - right[0];\n  });\n\n  sorted.forEach(function (element, idx) {\n    var vertex = element[1];\n    var offset = (element[2] * 2 + 1) * 3;\n    if (idx == 0) {\n      positions[offset] = scaledPosition.x;\n      positions[offset + 1] = scaledPosition.y;\n      positions[offset + 2] = scaledPosition.z;\n    } else {\n      positions[offset] = _this.originalVertices[offset];\n      positions[offset + 1] = _this.originalVertices[offset + 1];\n      positions[offset + 2] = _this.originalVertices[offset + 2];\n    }\n  });\n\n  geometry.attributes.position.needsUpdate = true;\n\n  //this.ellipse.updateMatrix();\n  //this.ellipse.geometry.setDrawRange(0, vertices.length)\n\n  // const angle = Math.atan2(threeBody.position.y, threeBody.position.x) - Math.atan2(closest.y, closest.x);\n  //this.ringBody.scale.set(10, 5, 1);\n  //this.ringBody.rotation.set(0, 0, 0);\n  //this.ringBody.rotateZ(angle);\n  this.angle += Math.PI / 256;\n  this.renderer.render(this.scene, this.camera);\n};\n\nexports.default = TestingRenderer;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvVGVzdGluZ1JlbmRlcmVyLmpzP2QxNTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuY29uc3QgT3JiaXRDb250cm9scyA9IHJlcXVpcmUoJ3RocmVlLW9yYml0LWNvbnRyb2xzJykoVEhSRUUpO1xuXG5jb25zdCBQT0lOVFMgPSA4O1xuXG5mdW5jdGlvbiBUZXN0aW5nUmVuZGVyZXIoY29udGFpbmVyKSB7XG5cbiAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG4gIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbn07XG5cblRlc3RpbmdSZW5kZXJlci5wcm90b3R5cGUucmVjZW50ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuVGVzdGluZ1JlbmRlcmVyLnByb3RvdHlwZS52aWV3RGlkTG9hZCA9IGZ1bmN0aW9uIChzb2xhclN5c3RlbSkge1xuXG4gIC8vIGluaXRpYWxpemUgY2FtZXJhIGFuZCBzY2VuZVxuICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjAxLCAxMDAwKVxuICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gNTA7XG4gIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG5ldyBUSFJFRS5Db2xvcignZ3JheScpO1xuXG4gIHRoaXMudGhyZWVCb2R5ID0gbmV3IFRIUkVFLk1lc2goXG4gICAgbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNSwgMzIsIDMyKSxcbiAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICdibGFjaydcbiAgICB9KSk7XG5cbiAgY29uc3QgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKFxuICAgIDAsIDAsIC8vIGF4LCBhWVxuICAgIDEsIDEsIC8vIHhSYWRpdXMsIHlSYWRpdXNcbiAgICAwLCAyICogTWF0aC5QSSwgLy8gYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZVxuICAgIGZhbHNlLCAvLyBhQ2xvY2t3aXNlXG4gICAgMCAvLyBhUm90YXRpb25cbiAgKTtcblxuICBjb25zdCBwb2ludHNHZW9tZXRyeSA9IG5ldyBUSFJFRS5QYXRoKGN1cnZlLmdldFBvaW50cyhQT0lOVFMpKVxuICAgIC5jcmVhdGVQb2ludHNHZW9tZXRyeShQT0lOVFMpO1xuXG4gIC8vQ3JlYXRlIHRoZSBmaW5hbCBvYmplY3QgdG8gYWRkIHRvIHRoZSBzY2VuZVxuICBjb25zdCBidWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0dlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmVydGljZXMucHVzaChcbiAgICAgIHBvaW50c0dlb21ldHJ5LnZlcnRpY2VzW2ldLngsXG4gICAgICBwb2ludHNHZW9tZXRyeS52ZXJ0aWNlc1tpXS55LFxuICAgICAgcG9pbnRzR2VvbWV0cnkudmVydGljZXNbaV0uelxuICAgICk7XG4gIH1cblxuICB0aGlzLm9yaWdpbmFsVmVydGljZXMgPSBBcnJheS5mcm9tKHZlcnRpY2VzKTtcbiAgYnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyksIDMpKTtcblxuICBjb25zdCBlbGxpcHNlID0gbmV3IFRIUkVFLkxpbmUoXG4gICAgYnVmZmVyR2VvbWV0cnksXG4gICAgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweGZmMDAwMFxuICAgIH0pKTtcblxuICAvL1xuICAvLyBjb25zdCBlbGxpcHNlID0gbmV3IFRIUkVFLkxpbmUobmV3IFRIUkVFLlJpbmdHZW9tZXRyeSgxLCAxLCA4KSxcbiAgLy8gICBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAvLyAgICAgY29sb3I6ICdyZWQnXG4gIC8vICAgfSkpO1xuXG4gIHRoaXMuZWxsaXBzZSA9IGVsbGlwc2U7XG4gIHRoaXMuZWxsaXBzZS5zY2FsZS5zZXQoMTAsIDUsIDEpO1xuICAvLyB0aGlzLmVsbGlwc2UubWF0cml4LnNldFBvc2l0aW9uKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKTtcbiAgLy8gdGhpcy5lbGxpcHNlLm1hdHJpeC5zY2FsZShuZXcgVEhSRUUuVmVjdG9yMygxMCwgNSwgMSkpO1xuICAvLyB0aGlzLmVsbGlwc2UubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMuYW5nbGUgPSAwO1xuXG4gIHRoaXMuc2NlbmUuYWRkKHRoaXMudGhyZWVCb2R5KTtcbiAgdGhpcy5zY2VuZS5hZGQodGhpcy5lbGxpcHNlKTtcbiAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB0aGlzLm9yYml0Q29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5zY2VuZS5kb21FbGVtZW50KTtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuXG5UZXN0aW5nUmVuZGVyZXIucHJvdG90eXBlLnZpZXdXaWxsQXBwZWFyID0gZnVuY3Rpb24gKCkge307XG5UZXN0aW5nUmVuZGVyZXIucHJvdG90eXBlLnZpZXdXaWxsRGlzYXBwZWFyID0gZnVuY3Rpb24gKCkge307XG5cblRlc3RpbmdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNvbGFyU3lzdGVtKSB7XG5cbiAgbGV0IHRocmVlQm9keSA9IHRoaXMudGhyZWVCb2R5O1xuICB0aHJlZUJvZHkucG9zaXRpb24uc2V0KDEwICogTWF0aC5jb3ModGhpcy5hbmdsZSksIDUgKiBNYXRoLnNpbih0aGlzLmFuZ2xlKSwgMCk7XG5cbiAgbGV0IHNjYWxlZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgIC5jb3B5KHRocmVlQm9keS5wb3NpdGlvbilcbiAgICAubXVsdGlwbHkobmV3IFRIUkVFLlZlY3RvcjMoMSAvIDEwLCAxIC8gNSwgMSkpO1xuXG4gIC8vIGxldCBuZXdWZXJ0aWNlcyA9IFtdO1xuICAvLyBsZXQgYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAvL1xuICAvLyAgIGxldCB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygxMCAqIE1hdGguY29zKGFuZ2xlKSwgNSAqIE1hdGguc2luKGFuZ2xlKSwgMCk7XG4gIC8vICAgbmV3VmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAvLyAgIGFuZ2xlICs9IDIgKiBNYXRoLlBJIC8gODtcbiAgLy8gfVxuICAvL1xuICAvL1xuXG4gIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5lbGxpcHNlLmdlb21ldHJ5O1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICBjb25zdCByYW5nZSA9IE1hdGguZmxvb3IocG9zaXRpb25zLmxlbmd0aCAvIDMgLyAyKTtcbiAgY29uc3QgdmVydGljZXNUb1Rlc3QgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlOyBpKyspIHtcbiAgICBjb25zdCBvZmZzZXQgPSAoaSAqIDIgKyAxKSAqIDM7XG4gICAgdmVydGljZXNUb1Rlc3QucHVzaChuZXcgVEhSRUUuVmVjdG9yMyh0aGlzLm9yaWdpbmFsVmVydGljZXNbb2Zmc2V0XSxcbiAgICAgIHRoaXMub3JpZ2luYWxWZXJ0aWNlc1tvZmZzZXQgKyAxXSwgdGhpcy5vcmlnaW5hbFZlcnRpY2VzW29mZnNldCArIDJdKSk7XG4gIH07XG5cbiAgY29uc3Qgc29ydGVkID0gdmVydGljZXNUb1Rlc3QubWFwKCh2ZXJ0ZXgsIGlkeCkgPT4gW3ZlcnRleC5kaXN0YW5jZVRvKHNjYWxlZFBvc2l0aW9uKSwgdmVydGV4LCBpZHhdKVxuICAgIC5zb3J0KChsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIGxlZnRbMF0gLSByaWdodFswXTtcbiAgICB9KTtcblxuICBzb3J0ZWQuZm9yRWFjaCgoZWxlbWVudCwgaWR4KSA9PiB7XG4gICAgbGV0IHZlcnRleCA9IGVsZW1lbnRbMV07XG4gICAgbGV0IG9mZnNldCA9IChlbGVtZW50WzJdICogMiArIDEpICogMztcbiAgICBpZiAoaWR4ID09IDApIHtcbiAgICAgIHBvc2l0aW9uc1tvZmZzZXRdID0gc2NhbGVkUG9zaXRpb24ueDtcbiAgICAgIHBvc2l0aW9uc1tvZmZzZXQgKyAxXSA9IHNjYWxlZFBvc2l0aW9uLnlcbiAgICAgIHBvc2l0aW9uc1tvZmZzZXQgKyAyXSA9IHNjYWxlZFBvc2l0aW9uLno7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uc1tvZmZzZXRdID0gdGhpcy5vcmlnaW5hbFZlcnRpY2VzW29mZnNldF07XG4gICAgICBwb3NpdGlvbnNbb2Zmc2V0ICsgMV0gPSB0aGlzLm9yaWdpbmFsVmVydGljZXNbb2Zmc2V0ICsgMV07XG4gICAgICBwb3NpdGlvbnNbb2Zmc2V0ICsgMl0gPSB0aGlzLm9yaWdpbmFsVmVydGljZXNbb2Zmc2V0ICsgMl07XG4gICAgfVxuICB9KTtcblxuICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvL3RoaXMuZWxsaXBzZS51cGRhdGVNYXRyaXgoKTtcbiAgLy90aGlzLmVsbGlwc2UuZ2VvbWV0cnkuc2V0RHJhd1JhbmdlKDAsIHZlcnRpY2VzLmxlbmd0aClcblxuICAvLyBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIodGhyZWVCb2R5LnBvc2l0aW9uLnksIHRocmVlQm9keS5wb3NpdGlvbi54KSAtIE1hdGguYXRhbjIoY2xvc2VzdC55LCBjbG9zZXN0LngpO1xuICAvL3RoaXMucmluZ0JvZHkuc2NhbGUuc2V0KDEwLCA1LCAxKTtcbiAgLy90aGlzLnJpbmdCb2R5LnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgLy90aGlzLnJpbmdCb2R5LnJvdGF0ZVooYW5nbGUpO1xuICB0aGlzLmFuZ2xlICs9IE1hdGguUEkgLyAyNTY7XG4gIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlc3RpbmdSZW5kZXJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL1Rlc3RpbmdSZW5kZXJlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(123);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(141)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./styles.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./styles.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy9zdHlsZXMuY3NzPzQyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jc3Mvc3R5bGVzLmNzc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

eval("var THREE = __webpack_require__( 1 );\n\n/**\n* @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com\n* @author Tony Parisi / http://www.tonyparisi.com/\n*/\n\nvar ColladaLoader = function () {\n\n    var COLLADA = null;\n    var scene = null;\n    var visualScene;\n    var kinematicsModel;\n\n    var readyCallbackFunc = null;\n\n    var sources = {};\n    var images = {};\n    var animations = {};\n    var controllers = {};\n    var geometries = {};\n    var materials = {};\n    var effects = {};\n    var cameras = {};\n    var lights = {};\n\n    var animData;\n    var kinematics;\n    var visualScenes;\n    var kinematicsModels;\n    var baseUrl;\n    var morphs;\n    var skins;\n\n    var flip_uv = true;\n    var preferredShading = THREE.SmoothShading;\n\n    var options = {\n        // Force Geometry to always be centered at the local origin of the\n        // containing Mesh.\n        centerGeometry: false,\n\n        // Axis conversion is done for geometries, animations, and controllers.\n        // If we ever pull cameras or lights out of the COLLADA file, they'll\n        // need extra work.\n        convertUpAxis: false,\n\n        subdivideFaces: true,\n\n        upAxis: 'Y',\n\n        // For reflective or refractive materials we'll use this cubemap\n        defaultEnvMap: null\n\n    };\n\n    var colladaUnit = 1.0;\n    var colladaUp = 'Y';\n    var upConversion = null;\n\n    function load ( url, readyCallback, progressCallback, failCallback ) {\n\n        var length = 0;\n\n        if ( document.implementation && document.implementation.createDocument ) {\n\n            var request = new XMLHttpRequest();\n\n            request.onreadystatechange = function() {\n\n                if ( request.readyState === 4 ) {\n\n                    if ( request.status === 0 || request.status === 200 ) {\n\n                        if ( request.response ) {\n\n                            readyCallbackFunc = readyCallback;\n                            parse( request.response, undefined, url );\n\n                        } else {\n\n                            if ( failCallback ) {\n\n                                failCallback();\n\n                            } else {\n\n                                console.error( \"ColladaLoader: Empty or non-existing file (\" + url + \")\" );\n\n                            }\n\n                        }\n\n                    }\n\n                } else if ( request.readyState === 3 ) {\n\n                    if ( progressCallback ) {\n\n                        if ( length === 0 ) {\n\n                            length = request.getResponseHeader( \"Content-Length\" );\n\n                        }\n\n                        progressCallback( { total: length, loaded: request.responseText.length } );\n\n                    }\n\n                }\n\n            };\n\n            request.open( \"GET\", url, true );\n            request.send( null );\n\n        } else {\n\n            alert( \"Don't know how to parse XML!\" );\n\n        }\n\n    }\n\n    function parse( text, callBack, url ) {\n\n        COLLADA = new DOMParser().parseFromString( text, 'text/xml' );\n        callBack = callBack || readyCallbackFunc;\n\n        if ( url !== undefined ) {\n\n            var parts = url.split( '/' );\n            parts.pop();\n            baseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\n\n        }\n\n        parseAsset();\n        setUpConversion();\n        images = parseLib( \"library_images image\", _Image, \"image\" );\n        materials = parseLib( \"library_materials material\", Material, \"material\" );\n        effects = parseLib( \"library_effects effect\", Effect, \"effect\" );\n        geometries = parseLib( \"library_geometries geometry\", Geometry, \"geometry\" );\n        cameras = parseLib( \"library_cameras camera\", Camera, \"camera\" );\n        lights = parseLib( \"library_lights light\", Light, \"light\" );\n        controllers = parseLib( \"library_controllers controller\", Controller, \"controller\" );\n        animations = parseLib( \"library_animations animation\", Animation, \"animation\" );\n        visualScenes = parseLib( \"library_visual_scenes visual_scene\", VisualScene, \"visual_scene\" );\n        kinematicsModels = parseLib( \"library_kinematics_models kinematics_model\", KinematicsModel, \"kinematics_model\" );\n\n        morphs = [];\n        skins = [];\n\n        visualScene = parseScene();\n        scene = new THREE.Group();\n\n        for ( var i = 0; i < visualScene.nodes.length; i ++ ) {\n\n            scene.add( createSceneGraph( visualScene.nodes[ i ] ) );\n\n        }\n\n        // unit conversion\n        scene.scale.multiplyScalar( colladaUnit );\n\n        createAnimations();\n\n        kinematicsModel = parseKinematicsModel();\n        createKinematics();\n\n        var result = {\n\n            scene: scene,\n            morphs: morphs,\n            skins: skins,\n            animations: animData,\n            kinematics: kinematics,\n            dae: {\n                images: images,\n                materials: materials,\n                cameras: cameras,\n                lights: lights,\n                effects: effects,\n                geometries: geometries,\n                controllers: controllers,\n                animations: animations,\n                visualScenes: visualScenes,\n                visualScene: visualScene,\n                scene: visualScene,\n                kinematicsModels: kinematicsModels,\n                kinematicsModel: kinematicsModel\n            }\n\n        };\n\n        if ( callBack ) {\n\n            callBack( result );\n\n        }\n\n        return result;\n\n    }\n\n    function setPreferredShading ( shading ) {\n\n        preferredShading = shading;\n\n    }\n\n    function parseAsset () {\n\n        var elements = COLLADA.querySelectorAll('asset');\n\n        var element = elements[0];\n\n        if ( element && element.childNodes ) {\n\n            for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n                var child = element.childNodes[ i ];\n\n                switch ( child.nodeName ) {\n\n                    case 'unit':\n\n                        var meter = child.getAttribute( 'meter' );\n\n                        if ( meter ) {\n\n                            colladaUnit = parseFloat( meter );\n\n                        }\n\n                        break;\n\n                    case 'up_axis':\n\n                        colladaUp = child.textContent.charAt(0);\n                        break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    function parseLib ( q, classSpec, prefix ) {\n\n        var elements = COLLADA.querySelectorAll(q);\n\n        var lib = {};\n\n        var i = 0;\n\n        var elementsLength = elements.length;\n\n        for ( var j = 0; j < elementsLength; j ++ ) {\n\n            var element = elements[j];\n            var daeElement = ( new classSpec() ).parse( element );\n\n            if ( !daeElement.id || daeElement.id.length === 0 ) daeElement.id = prefix + ( i ++ );\n            lib[ daeElement.id ] = daeElement;\n\n        }\n\n        return lib;\n\n    }\n\n    function parseScene() {\n\n        var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];\n\n        if ( sceneElement ) {\n\n            var url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );\n            return visualScenes[ url.length > 0 ? url : 'visual_scene0' ];\n\n        } else {\n\n            return null;\n\n        }\n\n    }\n\n    function parseKinematicsModel() {\n\n        var kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];\n\n        if ( kinematicsModelElement ) {\n\n            var url = kinematicsModelElement.getAttribute( 'url' ).replace(/^#/, '');\n            return kinematicsModels[ url.length > 0 ? url : 'kinematics_model0' ];\n\n        } else {\n\n            return null;\n\n        }\n\n    }\n\n    function createAnimations() {\n\n        animData = [];\n\n        // fill in the keys\n        recurseHierarchy( scene );\n\n    }\n\n    function recurseHierarchy( node ) {\n\n        var n = visualScene.getChildById( node.colladaId, true ),\n            newData = null;\n\n        if ( n && n.keys ) {\n\n            newData = {\n                fps: 60,\n                hierarchy: [ {\n                    node: n,\n                    keys: n.keys,\n                    sids: n.sids\n                } ],\n                node: node,\n                name: 'animation_' + node.name,\n                length: 0\n            };\n\n            animData.push(newData);\n\n            for ( var i = 0, il = n.keys.length; i < il; i ++ ) {\n\n                newData.length = Math.max( newData.length, n.keys[i].time );\n\n            }\n\n        } else {\n\n            newData = {\n                hierarchy: [ {\n                    keys: [],\n                    sids: []\n                } ]\n            }\n\n        }\n\n        for ( var i = 0, il = node.children.length; i < il; i ++ ) {\n\n            var d = recurseHierarchy( node.children[i] );\n\n            for ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {\n\n                newData.hierarchy.push( {\n                    keys: [],\n                    sids: []\n                } );\n\n            }\n\n        }\n\n        return newData;\n\n    }\n\n    function calcAnimationBounds () {\n\n        var start = 1000000;\n        var end = -start;\n        var frames = 0;\n        var ID;\n        for ( var id in animations ) {\n\n            var animation = animations[ id ];\n            ID = ID || animation.id;\n            for ( var i = 0; i < animation.sampler.length; i ++ ) {\n\n                var sampler = animation.sampler[ i ];\n\n                sampler.create();\n\n                start = Math.min( start, sampler.startTime );\n                end = Math.max( end, sampler.endTime );\n                frames = Math.max( frames, sampler.input.length );\n\n            }\n\n        }\n\n        return { start:start, end:end, frames:frames,ID:ID };\n\n    }\n\n    function createMorph ( geometry, ctrl ) {\n\n        var morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;\n\n        if ( !morphCtrl || !morphCtrl.morph ) {\n\n            console.log(\"could not find morph controller!\");\n            return;\n\n        }\n\n        var morph = morphCtrl.morph;\n\n        for ( var i = 0; i < morph.targets.length; i ++ ) {\n\n            var target_id = morph.targets[ i ];\n            var daeGeometry = geometries[ target_id ];\n\n            if ( !daeGeometry.mesh ||\n                 !daeGeometry.mesh.primitives ||\n                 !daeGeometry.mesh.primitives.length ) {\n                 continue;\n            }\n\n            var target = daeGeometry.mesh.primitives[ 0 ].geometry;\n\n            if ( target.vertices.length === geometry.vertices.length ) {\n\n                geometry.morphTargets.push( { name: \"target_1\", vertices: target.vertices } );\n\n            }\n\n        }\n\n        geometry.morphTargets.push( { name: \"target_Z\", vertices: geometry.vertices } );\n\n    }\n\n    function createSkin ( geometry, ctrl, applyBindShape ) {\n\n        var skinCtrl = controllers[ ctrl.url ];\n\n        if ( !skinCtrl || !skinCtrl.skin ) {\n\n            console.log( \"could not find skin controller!\" );\n            return;\n\n        }\n\n        if ( !ctrl.skeleton || !ctrl.skeleton.length ) {\n\n            console.log( \"could not find the skeleton for the skin!\" );\n            return;\n\n        }\n\n        var skin = skinCtrl.skin;\n        var skeleton = visualScene.getChildById( ctrl.skeleton[ 0 ] );\n        var hierarchy = [];\n\n        applyBindShape = applyBindShape !== undefined ? applyBindShape : true;\n\n        var bones = [];\n        geometry.skinWeights = [];\n        geometry.skinIndices = [];\n\n        //createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );\n        //createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );\n\n        /*\n        geometry.animation = {\n            name: 'take_001',\n            fps: 30,\n            length: 2,\n            JIT: true,\n            hierarchy: hierarchy\n        };\n        */\n\n        if ( applyBindShape ) {\n\n            for ( var i = 0; i < geometry.vertices.length; i ++ ) {\n\n                geometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );\n\n            }\n\n        }\n\n    }\n\n    function setupSkeleton ( node, bones, frame, parent ) {\n\n        node.world = node.world || new THREE.Matrix4();\n        node.localworld = node.localworld || new THREE.Matrix4();\n        node.world.copy( node.matrix );\n        node.localworld.copy( node.matrix );\n\n        if ( node.channels && node.channels.length ) {\n\n            var channel = node.channels[ 0 ];\n            var m = channel.sampler.output[ frame ];\n\n            if ( m instanceof THREE.Matrix4 ) {\n\n                node.world.copy( m );\n                node.localworld.copy(m);\n                if (frame === 0)\n                    node.matrix.copy(m);\n            }\n\n        }\n\n        if ( parent ) {\n\n            node.world.multiplyMatrices( parent, node.world );\n\n        }\n\n        bones.push( node );\n\n        for ( var i = 0; i < node.nodes.length; i ++ ) {\n\n            setupSkeleton( node.nodes[ i ], bones, frame, node.world );\n\n        }\n\n    }\n\n    function setupSkinningMatrices ( bones, skin ) {\n\n        // FIXME: this is dumb...\n\n        for ( var i = 0; i < bones.length; i ++ ) {\n\n            var bone = bones[ i ];\n            var found = -1;\n\n            if ( bone.type != 'JOINT' ) continue;\n\n            for ( var j = 0; j < skin.joints.length; j ++ ) {\n\n                if ( bone.sid === skin.joints[ j ] ) {\n\n                    found = j;\n                    break;\n\n                }\n\n            }\n\n            if ( found >= 0 ) {\n\n                var inv = skin.invBindMatrices[ found ];\n\n                bone.invBindMatrix = inv;\n                bone.skinningMatrix = new THREE.Matrix4();\n                bone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)\n                bone.animatrix = new THREE.Matrix4();\n\n                bone.animatrix.copy(bone.localworld);\n                bone.weights = [];\n\n                for ( var j = 0; j < skin.weights.length; j ++ ) {\n\n                    for (var k = 0; k < skin.weights[ j ].length; k ++ ) {\n\n                        var w = skin.weights[ j ][ k ];\n\n                        if ( w.joint === found ) {\n\n                            bone.weights.push( w );\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                console.warn( \"ColladaLoader: Could not find joint '\" + bone.sid + \"'.\" );\n\n                bone.skinningMatrix = new THREE.Matrix4();\n                bone.weights = [];\n\n            }\n        }\n\n    }\n\n    //Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix\n    function flattenSkeleton(skeleton) {\n\n        var list = [];\n        var walk = function(parentid, node, list) {\n\n            var bone = {};\n            bone.name = node.sid;\n            bone.parent = parentid;\n            bone.matrix = node.matrix;\n            var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];\n            bone.matrix.decompose(data[0], data[1], data[2]);\n\n            bone.pos = [ data[0].x,data[0].y,data[0].z ];\n\n            bone.scl = [ data[2].x,data[2].y,data[2].z ];\n            bone.rotq = [ data[1].x,data[1].y,data[1].z,data[1].w ];\n            list.push(bone);\n\n            for (var i in node.nodes) {\n\n                walk(node.sid, node.nodes[i], list);\n\n            }\n\n        };\n\n        walk(-1, skeleton, list);\n        return list;\n\n    }\n\n    //Move the vertices into the pose that is proper for the start of the animation\n    function skinToBindPose(geometry,skeleton,skinController) {\n\n        var bones = [];\n        setupSkeleton( skeleton, bones, -1 );\n        setupSkinningMatrices( bones, skinController.skin );\n        var v = new THREE.Vector3();\n        var skinned = [];\n\n        for (var i = 0; i < geometry.vertices.length; i ++) {\n\n            skinned.push(new THREE.Vector3());\n\n        }\n\n        for ( i = 0; i < bones.length; i ++ ) {\n\n            if ( bones[ i ].type != 'JOINT' ) continue;\n\n            for ( var j = 0; j < bones[ i ].weights.length; j ++ ) {\n\n                var w = bones[ i ].weights[ j ];\n                var vidx = w.index;\n                var weight = w.weight;\n\n                var o = geometry.vertices[vidx];\n                var s = skinned[vidx];\n\n                v.x = o.x;\n                v.y = o.y;\n                v.z = o.z;\n\n                v.applyMatrix4( bones[i].skinningMatrix );\n\n                s.x += (v.x * weight);\n                s.y += (v.y * weight);\n                s.z += (v.z * weight);\n            }\n\n        }\n\n        for (var i = 0; i < geometry.vertices.length; i ++) {\n\n            geometry.vertices[i] = skinned[i];\n\n        }\n\n    }\n\n    function applySkin ( geometry, instanceCtrl, frame ) {\n\n        var skinController = controllers[ instanceCtrl.url ];\n\n        frame = frame !== undefined ? frame : 40;\n\n        if ( !skinController || !skinController.skin ) {\n\n            console.log( 'ColladaLoader: Could not find skin controller.' );\n            return;\n\n        }\n\n        if ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {\n\n            console.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );\n            return;\n\n        }\n\n        var animationBounds = calcAnimationBounds();\n        var skeleton = visualScene.getChildById( instanceCtrl.skeleton[0], true ) || visualScene.getChildBySid( instanceCtrl.skeleton[0], true );\n\n        //flatten the skeleton into a list of bones\n        var bonelist = flattenSkeleton(skeleton);\n        var joints = skinController.skin.joints;\n\n        //sort that list so that the order reflects the order in the joint list\n        var sortedbones = [];\n        for (var i = 0; i < joints.length; i ++) {\n\n            for (var j = 0; j < bonelist.length; j ++) {\n\n                if (bonelist[j].name === joints[i]) {\n\n                    sortedbones[i] = bonelist[j];\n\n                }\n\n            }\n\n        }\n\n        //hook up the parents by index instead of name\n        for (var i = 0; i < sortedbones.length; i ++) {\n\n            for (var j = 0; j < sortedbones.length; j ++) {\n\n                if (sortedbones[i].parent === sortedbones[j].name) {\n\n                    sortedbones[i].parent = j;\n\n                }\n\n            }\n\n        }\n\n\n        var i, j, w, vidx, weight;\n        var v = new THREE.Vector3(), o, s;\n\n        // move vertices to bind shape\n        for ( i = 0; i < geometry.vertices.length; i ++ ) {\n            geometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );\n        }\n\n        var skinIndices = [];\n        var skinWeights = [];\n        var weights = skinController.skin.weights;\n\n        // hook up the skin weights\n        // TODO - this might be a good place to choose greatest 4 weights\n        for ( var i =0; i < weights.length; i ++ ) {\n\n            var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0,weights[i][1] ? weights[i][1].joint : 0,weights[i][2] ? weights[i][2].joint : 0,weights[i][3] ? weights[i][3].joint : 0);\n            var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0,weights[i][1] ? weights[i][1].weight : 0,weights[i][2] ? weights[i][2].weight : 0,weights[i][3] ? weights[i][3].weight : 0);\n\n            skinIndices.push(indicies);\n            skinWeights.push(weight);\n\n        }\n\n        geometry.skinIndices = skinIndices;\n        geometry.skinWeights = skinWeights;\n        geometry.bones = sortedbones;\n        // process animation, or simply pose the rig if no animation\n\n        //create an animation for the animated bones\n        //NOTE: this has no effect when using morphtargets\n        var animationdata = { \"name\":animationBounds.ID,\"fps\":30,\"length\":animationBounds.frames / 30,\"hierarchy\":[] };\n\n        for (var j = 0; j < sortedbones.length; j ++) {\n\n            animationdata.hierarchy.push({ parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[] });\n\n        }\n\n        console.log( 'ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.' );\n\n\n\n        skinToBindPose(geometry, skeleton, skinController);\n\n\n        for ( frame = 0; frame < animationBounds.frames; frame ++ ) {\n\n            var bones = [];\n            var skinned = [];\n            // process the frame and setup the rig with a fresh\n            // transform, possibly from the bone's animation channel(s)\n\n            setupSkeleton( skeleton, bones, frame );\n            setupSkinningMatrices( bones, skinController.skin );\n\n            for (var i = 0; i < bones.length; i ++) {\n\n                for (var j = 0; j < animationdata.hierarchy.length; j ++) {\n\n                    if (animationdata.hierarchy[j].name === bones[i].sid) {\n\n                        var key = {};\n                        key.time = (frame / 30);\n                        key.matrix = bones[i].animatrix;\n\n                        if (frame === 0)\n                            bones[i].matrix = key.matrix;\n\n                        var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];\n                        key.matrix.decompose(data[0], data[1], data[2]);\n\n                        key.pos = [ data[0].x,data[0].y,data[0].z ];\n\n                        key.scl = [ data[2].x,data[2].y,data[2].z ];\n                        key.rot = data[1];\n\n                        animationdata.hierarchy[j].keys.push(key);\n\n                    }\n\n                }\n\n            }\n\n            geometry.animation = animationdata;\n\n        }\n\n    }\n\n    function createKinematics() {\n\n        if ( kinematicsModel && kinematicsModel.joints.length === 0 ) {\n            kinematics = undefined;\n            return;\n        }\n\n        var jointMap = {};\n\n        var _addToMap = function( jointIndex, parentVisualElement ) {\n\n            var parentVisualElementId = parentVisualElement.getAttribute( 'id' );\n            var colladaNode = visualScene.getChildById( parentVisualElementId, true );\n            var joint = kinematicsModel.joints[ jointIndex ];\n\n            scene.traverse(function( node ) {\n\n                if ( node.colladaId == parentVisualElementId ) {\n\n                    jointMap[ jointIndex ] = {\n                        node: node,\n                        transforms: colladaNode.transforms,\n                        joint: joint,\n                        position: joint.zeroPosition\n                    };\n\n                }\n\n            });\n\n        };\n\n        kinematics = {\n\n            joints: kinematicsModel && kinematicsModel.joints,\n\n            getJointValue: function( jointIndex ) {\n\n                var jointData = jointMap[ jointIndex ];\n\n                if ( jointData ) {\n\n                    return jointData.position;\n\n                } else {\n\n                    console.log( 'getJointValue: joint ' + jointIndex + ' doesn\\'t exist' );\n\n                }\n\n            },\n\n            setJointValue: function( jointIndex, value ) {\n\n                var jointData = jointMap[ jointIndex ];\n\n                if ( jointData ) {\n\n                    var joint = jointData.joint;\n\n                    if ( value > joint.limits.max || value < joint.limits.min ) {\n\n                        console.log( 'setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')' );\n\n                    } else if ( joint.static ) {\n\n                        console.log( 'setJointValue: joint ' + jointIndex + ' is static' );\n\n                    } else {\n\n                        var threejsNode = jointData.node;\n                        var axis = joint.axis;\n                        var transforms = jointData.transforms;\n\n                        var matrix = new THREE.Matrix4();\n\n                        for (i = 0; i < transforms.length; i ++ ) {\n\n                            var transform = transforms[ i ];\n\n                            // kinda ghetto joint detection\n                            if ( transform.sid && transform.sid.indexOf( 'joint' + jointIndex ) !== -1 ) {\n\n                                // apply actual joint value here\n                                switch ( joint.type ) {\n\n                                    case 'revolute':\n\n                                        matrix.multiply( m1.makeRotationAxis( axis, THREE.Math.degToRad(value) ) );\n                                        break;\n\n                                    case 'prismatic':\n\n                                        matrix.multiply( m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value ) );\n                                        break;\n\n                                    default:\n\n                                        console.warn( 'setJointValue: unknown joint type: ' + joint.type );\n                                        break;\n\n                                }\n\n                            } else {\n\n                                var m1 = new THREE.Matrix4();\n\n                                switch ( transform.type ) {\n\n                                    case 'matrix':\n\n                                        matrix.multiply( transform.obj );\n\n                                        break;\n\n                                    case 'translate':\n\n                                        matrix.multiply( m1.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\n                                        break;\n\n                                    case 'rotate':\n\n                                        matrix.multiply( m1.makeRotationAxis( transform.obj, transform.angle ) );\n\n                                        break;\n\n                                }\n                            }\n                        }\n\n                        // apply the matrix to the threejs node\n                        var elementsFloat32Arr = matrix.elements;\n                        var elements = Array.prototype.slice.call( elementsFloat32Arr );\n\n                        var elementsRowMajor = [\n                            elements[ 0 ],\n                            elements[ 4 ],\n                            elements[ 8 ],\n                            elements[ 12 ],\n                            elements[ 1 ],\n                            elements[ 5 ],\n                            elements[ 9 ],\n                            elements[ 13 ],\n                            elements[ 2 ],\n                            elements[ 6 ],\n                            elements[ 10 ],\n                            elements[ 14 ],\n                            elements[ 3 ],\n                            elements[ 7 ],\n                            elements[ 11 ],\n                            elements[ 15 ]\n                        ];\n\n                        threejsNode.matrix.set.apply( threejsNode.matrix, elementsRowMajor );\n                        threejsNode.matrix.decompose( threejsNode.position, threejsNode.quaternion, threejsNode.scale );\n                    }\n\n                } else {\n\n                    console.log( 'setJointValue: joint ' + jointIndex + ' doesn\\'t exist' );\n\n                }\n\n            }\n\n        };\n\n        var element = COLLADA.querySelector('scene instance_kinematics_scene');\n\n        if ( element ) {\n\n            for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n                var child = element.childNodes[ i ];\n\n                if ( child.nodeType != 1 ) continue;\n\n                switch ( child.nodeName ) {\n\n                    case 'bind_joint_axis':\n\n                        var visualTarget = child.getAttribute( 'target' ).split( '/' ).pop();\n                        var axis = child.querySelector('axis param').textContent;\n                        var jointIndex = parseInt( axis.split( 'joint' ).pop().split( '.' )[0] );\n                        var visualTargetElement = COLLADA.querySelector( '[sid=\"' + visualTarget + '\"]' );\n\n                        if ( visualTargetElement ) {\n                            var parentVisualElement = visualTargetElement.parentElement;\n                            _addToMap(jointIndex, parentVisualElement);\n                        }\n\n                        break;\n\n                    default:\n\n                        break;\n\n                }\n\n            }\n        }\n\n    }\n\n    function createSceneGraph ( node, parent ) {\n\n        var obj = new THREE.Object3D();\n        var skinned = false;\n        var skinController;\n        var morphController;\n        var i, j;\n\n        // FIXME: controllers\n\n        for ( i = 0; i < node.controllers.length; i ++ ) {\n\n            var controller = controllers[ node.controllers[ i ].url ];\n\n            switch ( controller.type ) {\n\n                case 'skin':\n\n                    if ( geometries[ controller.skin.source ] ) {\n\n                        var inst_geom = new InstanceGeometry();\n\n                        inst_geom.url = controller.skin.source;\n                        inst_geom.instance_material = node.controllers[ i ].instance_material;\n\n                        node.geometries.push( inst_geom );\n                        skinned = true;\n                        skinController = node.controllers[ i ];\n\n                    } else if ( controllers[ controller.skin.source ] ) {\n\n                        // urgh: controller can be chained\n                        // handle the most basic case...\n\n                        var second = controllers[ controller.skin.source ];\n                        morphController = second;\n                    //\tskinController = node.controllers[i];\n\n                        if ( second.morph && geometries[ second.morph.source ] ) {\n\n                            var inst_geom = new InstanceGeometry();\n\n                            inst_geom.url = second.morph.source;\n                            inst_geom.instance_material = node.controllers[ i ].instance_material;\n\n                            node.geometries.push( inst_geom );\n\n                        }\n\n                    }\n\n                    break;\n\n                case 'morph':\n\n                    if ( geometries[ controller.morph.source ] ) {\n\n                        var inst_geom = new InstanceGeometry();\n\n                        inst_geom.url = controller.morph.source;\n                        inst_geom.instance_material = node.controllers[ i ].instance_material;\n\n                        node.geometries.push( inst_geom );\n                        morphController = node.controllers[ i ];\n\n                    }\n\n                    console.log( 'ColladaLoader: Morph-controller partially supported.' );\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        // geometries\n\n        var double_sided_materials = {};\n\n        for ( i = 0; i < node.geometries.length; i ++ ) {\n\n            var instance_geometry = node.geometries[i];\n            var instance_materials = instance_geometry.instance_material;\n            var geometry = geometries[ instance_geometry.url ];\n            var used_materials = {};\n            var used_materials_array = [];\n            var num_materials = 0;\n            var first_material;\n\n            if ( geometry ) {\n\n                if ( !geometry.mesh || !geometry.mesh.primitives )\n                    continue;\n\n                if ( obj.name.length === 0 ) {\n\n                    obj.name = geometry.id;\n\n                }\n\n                // collect used fx for this geometry-instance\n\n                if ( instance_materials ) {\n\n                    for ( j = 0; j < instance_materials.length; j ++ ) {\n\n                        var instance_material = instance_materials[ j ];\n                        var mat = materials[ instance_material.target ];\n                        var effect_id = mat.instance_effect.url;\n                        var shader = effects[ effect_id ].shader;\n                        var material3js = shader.material;\n\n                        if ( geometry.doubleSided ) {\n\n                            if ( !( instance_material.symbol in double_sided_materials ) ) {\n\n                                var _copied_material = material3js.clone();\n                                _copied_material.side = THREE.DoubleSide;\n                                double_sided_materials[ instance_material.symbol ] = _copied_material;\n\n                            }\n\n                            material3js = double_sided_materials[ instance_material.symbol ];\n\n                        }\n\n                        material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;\n                        used_materials[ instance_material.symbol ] = num_materials;\n                        used_materials_array.push( material3js );\n                        first_material = material3js;\n                        first_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;\n                        num_materials ++;\n\n                    }\n\n                }\n\n                var mesh;\n                var material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );\n                var geom = geometry.mesh.geometry3js;\n\n                if ( num_materials > 1 ) {\n\n                    material = new THREE.MultiMaterial( used_materials_array );\n\n                }\n\n                if ( skinController !== undefined ) {\n\n\n                    applySkin( geom, skinController );\n\n                    if ( geom.morphTargets.length > 0 ) {\n\n                        material.morphTargets = true;\n                        material.skinning = false;\n\n                    } else {\n\n                        material.morphTargets = false;\n                        material.skinning = true;\n\n                    }\n\n\n                    mesh = new THREE.SkinnedMesh( geom, material, false );\n\n\n                    //mesh.skeleton = skinController.skeleton;\n                    //mesh.skinController = controllers[ skinController.url ];\n                    //mesh.skinInstanceController = skinController;\n                    mesh.name = 'skin_' + skins.length;\n\n\n\n                    //mesh.animationHandle.setKey(0);\n                    skins.push( mesh );\n\n                } else if ( morphController !== undefined ) {\n\n                    createMorph( geom, morphController );\n\n                    material.morphTargets = true;\n\n                    mesh = new THREE.Mesh( geom, material );\n                    mesh.name = 'morph_' + morphs.length;\n\n                    morphs.push( mesh );\n\n                } else {\n\n                    if ( geom.isLineStrip === true ) {\n\n                        mesh = new THREE.Line( geom );\n\n                    } else {\n\n                        mesh = new THREE.Mesh( geom, material );\n\n                    }\n\n                }\n\n                obj.add(mesh);\n\n            }\n\n        }\n\n        for ( i = 0; i < node.cameras.length; i ++ ) {\n\n            var instance_camera = node.cameras[i];\n            var cparams = cameras[instance_camera.url];\n\n            var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio),\n                    parseFloat(cparams.znear), parseFloat(cparams.zfar));\n\n            obj.add(cam);\n        }\n\n        for ( i = 0; i < node.lights.length; i ++ ) {\n\n            var light = null;\n            var instance_light = node.lights[i];\n            var lparams = lights[instance_light.url];\n\n            if ( lparams && lparams.technique ) {\n\n                var color = lparams.color.getHex();\n                var intensity = lparams.intensity;\n                var distance = lparams.distance;\n                var angle = lparams.falloff_angle;\n\n                switch ( lparams.technique ) {\n\n                    case 'directional':\n\n                        light = new THREE.DirectionalLight( color, intensity, distance );\n                        light.position.set(0, 0, 1);\n                        break;\n\n                    case 'point':\n\n                        light = new THREE.PointLight( color, intensity, distance );\n                        break;\n\n                    case 'spot':\n\n                        light = new THREE.SpotLight( color, intensity, distance, angle );\n                        light.position.set(0, 0, 1);\n                        break;\n\n                    case 'ambient':\n\n                        light = new THREE.AmbientLight( color );\n                        break;\n\n                }\n\n            }\n\n            if (light) {\n                obj.add(light);\n            }\n        }\n\n        obj.name = node.name || node.id || \"\";\n        obj.colladaId = node.id || \"\";\n        obj.layer = node.layer || \"\";\n        obj.matrix = node.matrix;\n        obj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\n\n        if ( options.centerGeometry && obj.geometry ) {\n\n            var delta = obj.geometry.center();\n            delta.multiply( obj.scale );\n            delta.applyQuaternion( obj.quaternion );\n\n            obj.position.sub( delta );\n\n        }\n\n        for ( i = 0; i < node.nodes.length; i ++ ) {\n\n            obj.add( createSceneGraph( node.nodes[i], node ) );\n\n        }\n\n        return obj;\n\n    }\n\n    function getJointId( skin, id ) {\n\n        for ( var i = 0; i < skin.joints.length; i ++ ) {\n\n            if ( skin.joints[ i ] === id ) {\n\n                return i;\n\n            }\n\n        }\n\n    }\n\n    function getLibraryNode( id ) {\n\n        var nodes = COLLADA.querySelectorAll('library_nodes node');\n\n        for ( var i = 0; i < nodes.length; i++ ) {\n\n            var attObj = nodes[i].attributes.getNamedItem('id');\n\n            if ( attObj && attObj.value === id ) {\n\n                return nodes[i];\n\n            }\n\n        }\n\n        return undefined;\n\n    }\n\n    function getChannelsForNode ( node ) {\n\n        var channels = [];\n        var startTime = 1000000;\n        var endTime = -1000000;\n\n        for ( var id in animations ) {\n\n            var animation = animations[id];\n\n            for ( var i = 0; i < animation.channel.length; i ++ ) {\n\n                var channel = animation.channel[i];\n                var sampler = animation.sampler[i];\n                var id = channel.target.split('/')[0];\n\n                if ( id == node.id ) {\n\n                    sampler.create();\n                    channel.sampler = sampler;\n                    startTime = Math.min(startTime, sampler.startTime);\n                    endTime = Math.max(endTime, sampler.endTime);\n                    channels.push(channel);\n\n                }\n\n            }\n\n        }\n\n        if ( channels.length ) {\n\n            node.startTime = startTime;\n            node.endTime = endTime;\n\n        }\n\n        return channels;\n\n    }\n\n    function calcFrameDuration( node ) {\n\n        var minT = 10000000;\n\n        for ( var i = 0; i < node.channels.length; i ++ ) {\n\n            var sampler = node.channels[i].sampler;\n\n            for ( var j = 0; j < sampler.input.length - 1; j ++ ) {\n\n                var t0 = sampler.input[ j ];\n                var t1 = sampler.input[ j + 1 ];\n                minT = Math.min( minT, t1 - t0 );\n\n            }\n        }\n\n        return minT;\n\n    }\n\n    function calcMatrixAt( node, t ) {\n\n        var animated = {};\n\n        var i, j;\n\n        for ( i = 0; i < node.channels.length; i ++ ) {\n\n            var channel = node.channels[ i ];\n            animated[ channel.sid ] = channel;\n\n        }\n\n        var matrix = new THREE.Matrix4();\n\n        for ( i = 0; i < node.transforms.length; i ++ ) {\n\n            var transform = node.transforms[ i ];\n            var channel = animated[ transform.sid ];\n\n            if ( channel !== undefined ) {\n\n                var sampler = channel.sampler;\n                var value;\n\n                for ( j = 0; j < sampler.input.length - 1; j ++ ) {\n\n                    if ( sampler.input[ j + 1 ] > t ) {\n\n                        value = sampler.output[ j ];\n                        //console.log(value.flatten)\n                        break;\n\n                    }\n\n                }\n\n                if ( value !== undefined ) {\n\n                    if ( value instanceof THREE.Matrix4 ) {\n\n                        matrix.multiplyMatrices( matrix, value );\n\n                    } else {\n\n                        // FIXME: handle other types\n\n                        matrix.multiplyMatrices( matrix, transform.matrix );\n\n                    }\n\n                } else {\n\n                    matrix.multiplyMatrices( matrix, transform.matrix );\n\n                }\n\n            } else {\n\n                matrix.multiplyMatrices( matrix, transform.matrix );\n\n            }\n\n        }\n\n        return matrix;\n\n    }\n\n    function bakeAnimations ( node ) {\n\n        if ( node.channels && node.channels.length ) {\n\n            var keys = [],\n                sids = [];\n\n            for ( var i = 0, il = node.channels.length; i < il; i ++ ) {\n\n                var channel = node.channels[i],\n                    fullSid = channel.fullSid,\n                    sampler = channel.sampler,\n                    input = sampler.input,\n                    transform = node.getTransformBySid( channel.sid ),\n                    member;\n\n                if ( channel.arrIndices ) {\n\n                    member = [];\n\n                    for ( var j = 0, jl = channel.arrIndices.length; j < jl; j ++ ) {\n\n                        member[ j ] = getConvertedIndex( channel.arrIndices[ j ] );\n\n                    }\n\n                } else {\n\n                    member = getConvertedMember( channel.member );\n\n                }\n\n                if ( transform ) {\n\n                    if ( sids.indexOf( fullSid ) === -1 ) {\n\n                        sids.push( fullSid );\n\n                    }\n\n                    for ( var j = 0, jl = input.length; j < jl; j ++ ) {\n\n                        var time = input[j],\n                            data = sampler.getData( transform.type, j, member ),\n                            key = findKey( keys, time );\n\n                        if ( !key ) {\n\n                            key = new Key( time );\n                            var timeNdx = findTimeNdx( keys, time );\n                            keys.splice( timeNdx === -1 ? keys.length : timeNdx, 0, key );\n\n                        }\n\n                        key.addTarget( fullSid, transform, member, data );\n\n                    }\n\n                } else {\n\n                    console.log( 'Could not find transform \"' + channel.sid + '\" in node ' + node.id );\n\n                }\n\n            }\n\n            // post process\n            for ( var i = 0; i < sids.length; i ++ ) {\n\n                var sid = sids[ i ];\n\n                for ( var j = 0; j < keys.length; j ++ ) {\n\n                    var key = keys[ j ];\n\n                    if ( !key.hasTarget( sid ) ) {\n\n                        interpolateKeys( keys, key, j, sid );\n\n                    }\n\n                }\n\n            }\n\n            node.keys = keys;\n            node.sids = sids;\n\n        }\n\n    }\n\n    function findKey ( keys, time) {\n\n        var retVal = null;\n\n        for ( var i = 0, il = keys.length; i < il && retVal === null; i ++ ) {\n\n            var key = keys[i];\n\n            if ( key.time === time ) {\n\n                retVal = key;\n\n            } else if ( key.time > time ) {\n\n                break;\n\n            }\n\n        }\n\n        return retVal;\n\n    }\n\n    function findTimeNdx ( keys, time) {\n\n        var ndx = -1;\n\n        for ( var i = 0, il = keys.length; i < il && ndx === -1; i ++ ) {\n\n            var key = keys[i];\n\n            if ( key.time >= time ) {\n\n                ndx = i;\n\n            }\n\n        }\n\n        return ndx;\n\n    }\n\n    function interpolateKeys ( keys, key, ndx, fullSid ) {\n\n        var prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx - 1 : 0 ),\n            nextKey = getNextKeyWith( keys, fullSid, ndx + 1 );\n\n        if ( prevKey && nextKey ) {\n\n            var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),\n                prevTarget = prevKey.getTarget( fullSid ),\n                nextData = nextKey.getTarget( fullSid ).data,\n                prevData = prevTarget.data,\n                data;\n\n            if ( prevTarget.type === 'matrix' ) {\n\n                data = prevData;\n\n            } else if ( prevData.length ) {\n\n                data = [];\n\n                for ( var i = 0; i < prevData.length; ++ i ) {\n\n                    data[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;\n\n                }\n\n            } else {\n\n                data = prevData + ( nextData - prevData ) * scale;\n\n            }\n\n            key.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );\n\n        }\n\n    }\n\n    // Get next key with given sid\n\n    function getNextKeyWith( keys, fullSid, ndx ) {\n\n        for ( ; ndx < keys.length; ndx ++ ) {\n\n            var key = keys[ ndx ];\n\n            if ( key.hasTarget( fullSid ) ) {\n\n                return key;\n\n            }\n\n        }\n\n        return null;\n\n    }\n\n    // Get previous key with given sid\n\n    function getPrevKeyWith( keys, fullSid, ndx ) {\n\n        ndx = ndx >= 0 ? ndx : ndx + keys.length;\n\n        for ( ; ndx >= 0; ndx -- ) {\n\n            var key = keys[ ndx ];\n\n            if ( key.hasTarget( fullSid ) ) {\n\n                return key;\n\n            }\n\n        }\n\n        return null;\n\n    }\n\n    function _Image() {\n\n        this.id = \"\";\n        this.init_from = \"\";\n\n    }\n\n    _Image.prototype.parse = function(element) {\n\n        this.id = element.getAttribute('id');\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            if ( child.nodeName === 'init_from' ) {\n\n                this.init_from = child.textContent;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Controller() {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.type = \"\";\n        this.skin = null;\n        this.morph = null;\n\n    }\n\n    Controller.prototype.parse = function( element ) {\n\n        this.id = element.getAttribute('id');\n        this.name = element.getAttribute('name');\n        this.type = \"none\";\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            switch ( child.nodeName ) {\n\n                case 'skin':\n\n                    this.skin = (new Skin()).parse(child);\n                    this.type = child.nodeName;\n                    break;\n\n                case 'morph':\n\n                    this.morph = (new Morph()).parse(child);\n                    this.type = child.nodeName;\n                    break;\n\n                default:\n                    break;\n\n            }\n        }\n\n        return this;\n\n    };\n\n    function Morph() {\n\n        this.method = null;\n        this.source = null;\n        this.targets = null;\n        this.weights = null;\n\n    }\n\n    Morph.prototype.parse = function( element ) {\n\n        var sources = {};\n        var inputs = [];\n        var i;\n\n        this.method = element.getAttribute( 'method' );\n        this.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n\n        for ( i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'source':\n\n                    var source = ( new Source() ).parse( child );\n                    sources[ source.id ] = source;\n                    break;\n\n                case 'targets':\n\n                    inputs = this.parseInputs( child );\n                    break;\n\n                default:\n\n                    console.log( child.nodeName );\n                    break;\n\n            }\n\n        }\n\n        for ( i = 0; i < inputs.length; i ++ ) {\n\n            var input = inputs[ i ];\n            var source = sources[ input.source ];\n\n            switch ( input.semantic ) {\n\n                case 'MORPH_TARGET':\n\n                    this.targets = source.read();\n                    break;\n\n                case 'MORPH_WEIGHT':\n\n                    this.weights = source.read();\n                    break;\n\n                default:\n                    break;\n\n            }\n        }\n\n        return this;\n\n    };\n\n    Morph.prototype.parseInputs = function(element) {\n\n        var inputs = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'input':\n\n                    inputs.push( (new Input()).parse(child) );\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        return inputs;\n\n    };\n\n    function Skin() {\n\n        this.source = \"\";\n        this.bindShapeMatrix = null;\n        this.invBindMatrices = [];\n        this.joints = [];\n        this.weights = [];\n\n    }\n\n    Skin.prototype.parse = function( element ) {\n\n        var sources = {};\n        var joints, weights;\n\n        this.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n        this.invBindMatrices = [];\n        this.joints = [];\n        this.weights = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'bind_shape_matrix':\n\n                    var f = _floats(child.textContent);\n                    this.bindShapeMatrix = getConvertedMat4( f );\n                    break;\n\n                case 'source':\n\n                    var src = new Source().parse(child);\n                    sources[ src.id ] = src;\n                    break;\n\n                case 'joints':\n\n                    joints = child;\n                    break;\n\n                case 'vertex_weights':\n\n                    weights = child;\n                    break;\n\n                default:\n\n                    console.log( child.nodeName );\n                    break;\n\n            }\n        }\n\n        this.parseJoints( joints, sources );\n        this.parseWeights( weights, sources );\n\n        return this;\n\n    };\n\n    Skin.prototype.parseJoints = function ( element, sources ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'input':\n\n                    var input = ( new Input() ).parse( child );\n                    var source = sources[ input.source ];\n\n                    if ( input.semantic === 'JOINT' ) {\n\n                        this.joints = source.read();\n\n                    } else if ( input.semantic === 'INV_BIND_MATRIX' ) {\n\n                        this.invBindMatrices = source.read();\n\n                    }\n\n                    break;\n\n                default:\n                    break;\n            }\n\n        }\n\n    };\n\n    Skin.prototype.parseWeights = function ( element, sources ) {\n\n        var v, vcount, inputs = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'input':\n\n                    inputs.push( ( new Input() ).parse( child ) );\n                    break;\n\n                case 'v':\n\n                    v = _ints( child.textContent );\n                    break;\n\n                case 'vcount':\n\n                    vcount = _ints( child.textContent );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        var index = 0;\n\n        for ( var i = 0; i < vcount.length; i ++ ) {\n\n            var numBones = vcount[i];\n            var vertex_weights = [];\n\n            for ( var j = 0; j < numBones; j ++ ) {\n\n                var influence = {};\n\n                for ( var k = 0; k < inputs.length; k ++ ) {\n\n                    var input = inputs[ k ];\n                    var value = v[ index + input.offset ];\n\n                    switch ( input.semantic ) {\n\n                        case 'JOINT':\n\n                            influence.joint = value;//this.joints[value];\n                            break;\n\n                        case 'WEIGHT':\n\n                            influence.weight = sources[ input.source ].data[ value ];\n                            break;\n\n                        default:\n                            break;\n\n                    }\n\n                }\n\n                vertex_weights.push( influence );\n                index += inputs.length;\n            }\n\n            for ( var j = 0; j < vertex_weights.length; j ++ ) {\n\n                vertex_weights[ j ].index = i;\n\n            }\n\n            this.weights.push( vertex_weights );\n\n        }\n\n    };\n\n    function VisualScene () {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.nodes = [];\n        this.scene = new THREE.Group();\n\n    }\n\n    VisualScene.prototype.getChildById = function( id, recursive ) {\n\n        for ( var i = 0; i < this.nodes.length; i ++ ) {\n\n            var node = this.nodes[ i ].getChildById( id, recursive );\n\n            if ( node ) {\n\n                return node;\n\n            }\n\n        }\n\n        return null;\n\n    };\n\n    VisualScene.prototype.getChildBySid = function( sid, recursive ) {\n\n        for ( var i = 0; i < this.nodes.length; i ++ ) {\n\n            var node = this.nodes[ i ].getChildBySid( sid, recursive );\n\n            if ( node ) {\n\n                return node;\n\n            }\n\n        }\n\n        return null;\n\n    };\n\n    VisualScene.prototype.parse = function( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n        this.nodes = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'node':\n\n                    this.nodes.push( ( new Node() ).parse( child ) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Node() {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.sid = \"\";\n        this.nodes = [];\n        this.controllers = [];\n        this.transforms = [];\n        this.geometries = [];\n        this.channels = [];\n        this.matrix = new THREE.Matrix4();\n\n    }\n\n    Node.prototype.getChannelForTransform = function( transformSid ) {\n\n        for ( var i = 0; i < this.channels.length; i ++ ) {\n\n            var channel = this.channels[i];\n            var parts = channel.target.split('/');\n            var id = parts.shift();\n            var sid = parts.shift();\n            var dotSyntax = (sid.indexOf(\".\") >= 0);\n            var arrSyntax = (sid.indexOf(\"(\") >= 0);\n            var arrIndices;\n            var member;\n\n            if ( dotSyntax ) {\n\n                parts = sid.split(\".\");\n                sid = parts.shift();\n                member = parts.shift();\n\n            } else if ( arrSyntax ) {\n\n                arrIndices = sid.split(\"(\");\n                sid = arrIndices.shift();\n\n                for ( var j = 0; j < arrIndices.length; j ++ ) {\n\n                    arrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\\)/, '' ) );\n\n                }\n\n            }\n\n            if ( sid === transformSid ) {\n\n                channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };\n                return channel;\n\n            }\n\n        }\n\n        return null;\n\n    };\n\n    Node.prototype.getChildById = function ( id, recursive ) {\n\n        if ( this.id === id ) {\n\n            return this;\n\n        }\n\n        if ( recursive ) {\n\n            for ( var i = 0; i < this.nodes.length; i ++ ) {\n\n                var n = this.nodes[ i ].getChildById( id, recursive );\n\n                if ( n ) {\n\n                    return n;\n\n                }\n\n            }\n\n        }\n\n        return null;\n\n    };\n\n    Node.prototype.getChildBySid = function ( sid, recursive ) {\n\n        if ( this.sid === sid ) {\n\n            return this;\n\n        }\n\n        if ( recursive ) {\n\n            for ( var i = 0; i < this.nodes.length; i ++ ) {\n\n                var n = this.nodes[ i ].getChildBySid( sid, recursive );\n\n                if ( n ) {\n\n                    return n;\n\n                }\n\n            }\n        }\n\n        return null;\n\n    };\n\n    Node.prototype.getTransformBySid = function ( sid ) {\n\n        for ( var i = 0; i < this.transforms.length; i ++ ) {\n\n            if ( this.transforms[ i ].sid === sid ) return this.transforms[ i ];\n\n        }\n\n        return null;\n\n    };\n\n    Node.prototype.parse = function( element ) {\n\n        var url;\n\n        this.id = element.getAttribute('id');\n        this.sid = element.getAttribute('sid');\n        this.name = element.getAttribute('name');\n        this.type = element.getAttribute('type');\n        this.layer = element.getAttribute('layer');\n\n        this.type = this.type === 'JOINT' ? this.type : 'NODE';\n\n        this.nodes = [];\n        this.transforms = [];\n        this.geometries = [];\n        this.cameras = [];\n        this.lights = [];\n        this.controllers = [];\n        this.matrix = new THREE.Matrix4();\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'node':\n\n                    this.nodes.push( ( new Node() ).parse( child ) );\n                    break;\n\n                case 'instance_camera':\n\n                    this.cameras.push( ( new InstanceCamera() ).parse( child ) );\n                    break;\n\n                case 'instance_controller':\n\n                    this.controllers.push( ( new InstanceController() ).parse( child ) );\n                    break;\n\n                case 'instance_geometry':\n\n                    this.geometries.push( ( new InstanceGeometry() ).parse( child ) );\n                    break;\n\n                case 'instance_light':\n\n                    this.lights.push( ( new InstanceLight() ).parse( child ) );\n                    break;\n\n                case 'instance_node':\n\n                    url = child.getAttribute( 'url' ).replace( /^#/, '' );\n                    var iNode = getLibraryNode( url );\n\n                    if ( iNode ) {\n\n                        this.nodes.push( ( new Node() ).parse( iNode )) ;\n\n                    }\n\n                    break;\n\n                case 'rotate':\n                case 'translate':\n                case 'scale':\n                case 'matrix':\n                case 'lookat':\n                case 'skew':\n\n                    this.transforms.push( ( new Transform() ).parse( child ) );\n                    break;\n\n                case 'extra':\n                    break;\n\n                default:\n\n                    console.log( child.nodeName );\n                    break;\n\n            }\n\n        }\n\n        this.channels = getChannelsForNode( this );\n        bakeAnimations( this );\n\n        this.updateMatrix();\n\n        return this;\n\n    };\n\n    Node.prototype.updateMatrix = function () {\n\n        this.matrix.identity();\n\n        for ( var i = 0; i < this.transforms.length; i ++ ) {\n\n            this.transforms[ i ].apply( this.matrix );\n\n        }\n\n    };\n\n    function Transform () {\n\n        this.sid = \"\";\n        this.type = \"\";\n        this.data = [];\n        this.obj = null;\n\n    }\n\n    Transform.prototype.parse = function ( element ) {\n\n        this.sid = element.getAttribute( 'sid' );\n        this.type = element.nodeName;\n        this.data = _floats( element.textContent );\n        this.convert();\n\n        return this;\n\n    };\n\n    Transform.prototype.convert = function () {\n\n        switch ( this.type ) {\n\n            case 'matrix':\n\n                this.obj = getConvertedMat4( this.data );\n                break;\n\n            case 'rotate':\n\n                this.angle = THREE.Math.degToRad( this.data[3] );\n\n            case 'translate':\n\n                fixCoords( this.data, -1 );\n                this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\n                break;\n\n            case 'scale':\n\n                fixCoords( this.data, 1 );\n                this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\n                break;\n\n            default:\n                console.log( 'Can not convert Transform of type ' + this.type );\n                break;\n\n        }\n\n    };\n\n    Transform.prototype.apply = function () {\n\n        var m1 = new THREE.Matrix4();\n\n        return function ( matrix ) {\n\n            switch ( this.type ) {\n\n                case 'matrix':\n\n                    matrix.multiply( this.obj );\n\n                    break;\n\n                case 'translate':\n\n                    matrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );\n\n                    break;\n\n                case 'rotate':\n\n                    matrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );\n\n                    break;\n\n                case 'scale':\n\n                    matrix.scale( this.obj );\n\n                    break;\n\n            }\n\n        };\n\n    }();\n\n    Transform.prototype.update = function ( data, member ) {\n\n        var members = [ 'X', 'Y', 'Z', 'ANGLE' ];\n\n        switch ( this.type ) {\n\n            case 'matrix':\n\n                if ( ! member ) {\n\n                    this.obj.copy( data );\n\n                } else if ( member.length === 1 ) {\n\n                    switch ( member[ 0 ] ) {\n\n                        case 0:\n\n                            this.obj.n11 = data[ 0 ];\n                            this.obj.n21 = data[ 1 ];\n                            this.obj.n31 = data[ 2 ];\n                            this.obj.n41 = data[ 3 ];\n\n                            break;\n\n                        case 1:\n\n                            this.obj.n12 = data[ 0 ];\n                            this.obj.n22 = data[ 1 ];\n                            this.obj.n32 = data[ 2 ];\n                            this.obj.n42 = data[ 3 ];\n\n                            break;\n\n                        case 2:\n\n                            this.obj.n13 = data[ 0 ];\n                            this.obj.n23 = data[ 1 ];\n                            this.obj.n33 = data[ 2 ];\n                            this.obj.n43 = data[ 3 ];\n\n                            break;\n\n                        case 3:\n\n                            this.obj.n14 = data[ 0 ];\n                            this.obj.n24 = data[ 1 ];\n                            this.obj.n34 = data[ 2 ];\n                            this.obj.n44 = data[ 3 ];\n\n                            break;\n\n                    }\n\n                } else if ( member.length === 2 ) {\n\n                    var propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );\n                    this.obj[ propName ] = data;\n\n                } else {\n\n                    console.log('Incorrect addressing of matrix in transform.');\n\n                }\n\n                break;\n\n            case 'translate':\n            case 'scale':\n\n                if ( Object.prototype.toString.call( member ) === '[object Array]' ) {\n\n                    member = members[ member[ 0 ] ];\n\n                }\n\n                switch ( member ) {\n\n                    case 'X':\n\n                        this.obj.x = data;\n                        break;\n\n                    case 'Y':\n\n                        this.obj.y = data;\n                        break;\n\n                    case 'Z':\n\n                        this.obj.z = data;\n                        break;\n\n                    default:\n\n                        this.obj.x = data[ 0 ];\n                        this.obj.y = data[ 1 ];\n                        this.obj.z = data[ 2 ];\n                        break;\n\n                }\n\n                break;\n\n            case 'rotate':\n\n                if ( Object.prototype.toString.call( member ) === '[object Array]' ) {\n\n                    member = members[ member[ 0 ] ];\n\n                }\n\n                switch ( member ) {\n\n                    case 'X':\n\n                        this.obj.x = data;\n                        break;\n\n                    case 'Y':\n\n                        this.obj.y = data;\n                        break;\n\n                    case 'Z':\n\n                        this.obj.z = data;\n                        break;\n\n                    case 'ANGLE':\n\n                        this.angle = THREE.Math.degToRad( data );\n                        break;\n\n                    default:\n\n                        this.obj.x = data[ 0 ];\n                        this.obj.y = data[ 1 ];\n                        this.obj.z = data[ 2 ];\n                        this.angle = THREE.Math.degToRad( data[ 3 ] );\n                        break;\n\n                }\n                break;\n\n        }\n\n    };\n\n    function InstanceController() {\n\n        this.url = \"\";\n        this.skeleton = [];\n        this.instance_material = [];\n\n    }\n\n    InstanceController.prototype.parse = function ( element ) {\n\n        this.url = element.getAttribute('url').replace(/^#/, '');\n        this.skeleton = [];\n        this.instance_material = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType !== 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'skeleton':\n\n                    this.skeleton.push( child.textContent.replace(/^#/, '') );\n                    break;\n\n                case 'bind_material':\n\n                    var instances = child.querySelectorAll('instance_material');\n\n                    for ( var j = 0; j < instances.length; j ++ ) {\n\n                        var instance = instances[j];\n                        this.instance_material.push( (new InstanceMaterial()).parse(instance) );\n\n                    }\n\n\n                    break;\n\n                case 'extra':\n                    break;\n\n                default:\n                    break;\n\n            }\n        }\n\n        return this;\n\n    };\n\n    function InstanceMaterial () {\n\n        this.symbol = \"\";\n        this.target = \"\";\n\n    }\n\n    InstanceMaterial.prototype.parse = function ( element ) {\n\n        this.symbol = element.getAttribute('symbol');\n        this.target = element.getAttribute('target').replace(/^#/, '');\n        return this;\n\n    };\n\n    function InstanceGeometry() {\n\n        this.url = \"\";\n        this.instance_material = [];\n\n    }\n\n    InstanceGeometry.prototype.parse = function ( element ) {\n\n        this.url = element.getAttribute('url').replace(/^#/, '');\n        this.instance_material = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1 ) continue;\n\n            if ( child.nodeName === 'bind_material' ) {\n\n                var instances = child.querySelectorAll('instance_material');\n\n                for ( var j = 0; j < instances.length; j ++ ) {\n\n                    var instance = instances[j];\n                    this.instance_material.push( (new InstanceMaterial()).parse(instance) );\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Geometry() {\n\n        this.id = \"\";\n        this.mesh = null;\n\n    }\n\n    Geometry.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute('id');\n\n        extractDoubleSided( this, element );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n\n            switch ( child.nodeName ) {\n\n                case 'mesh':\n\n                    this.mesh = (new Mesh(this)).parse(child);\n                    break;\n\n                case 'extra':\n\n                    // console.log( child );\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        return this;\n\n    };\n\n    function Mesh( geometry ) {\n\n        this.geometry = geometry.id;\n        this.primitives = [];\n        this.vertices = null;\n        this.geometry3js = null;\n\n    }\n\n    Mesh.prototype.parse = function ( element ) {\n\n        this.primitives = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            switch ( child.nodeName ) {\n\n                case 'source':\n\n                    _source( child );\n                    break;\n\n                case 'vertices':\n\n                    this.vertices = ( new Vertices() ).parse( child );\n                    break;\n\n                case 'linestrips':\n\n                    this.primitives.push( ( new LineStrips().parse( child ) ) );\n                    break;\n\n                case 'triangles':\n\n                    this.primitives.push( ( new Triangles().parse( child ) ) );\n                    break;\n\n                case 'polygons':\n\n                    this.primitives.push( ( new Polygons().parse( child ) ) );\n                    break;\n\n                case 'polylist':\n\n                    this.primitives.push( ( new Polylist().parse( child ) ) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        this.geometry3js = new THREE.Geometry();\n\n        if ( this.vertices === null ) {\n\n            // TODO (mrdoob): Study case when this is null (carrier.dae)\n\n            return this;\n\n        }\n\n        var vertexData = sources[ this.vertices.input['POSITION'].source ].data;\n\n        for ( var i = 0; i < vertexData.length; i += 3 ) {\n\n            this.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );\n\n        }\n\n        for ( var i = 0; i < this.primitives.length; i ++ ) {\n\n            var primitive = this.primitives[ i ];\n            primitive.setVertices( this.vertices );\n            this.handlePrimitive( primitive, this.geometry3js );\n\n        }\n\n        if ( this.geometry3js.calcNormals ) {\n\n            this.geometry3js.computeVertexNormals();\n            delete this.geometry3js.calcNormals;\n\n        }\n\n        return this;\n\n    };\n\n    Mesh.prototype.handlePrimitive = function ( primitive, geom ) {\n\n        if ( primitive instanceof LineStrips ) {\n\n            // TODO: Handle indices. Maybe easier with BufferGeometry?\n\n            geom.isLineStrip = true;\n            return;\n\n        }\n\n        var j, k, pList = primitive.p, inputs = primitive.inputs;\n        var input, index, idx32;\n        var source, numParams;\n        var vcIndex = 0, vcount = 3, maxOffset = 0;\n        var texture_sets = [];\n\n        for ( j = 0; j < inputs.length; j ++ ) {\n\n            input = inputs[ j ];\n\n            var offset = input.offset + 1;\n            maxOffset = (maxOffset < offset) ? offset : maxOffset;\n\n            switch ( input.semantic ) {\n\n                case 'TEXCOORD':\n                    texture_sets.push( input.set );\n                    break;\n\n            }\n\n        }\n\n        for ( var pCount = 0; pCount < pList.length; ++ pCount ) {\n\n            var p = pList[ pCount ], i = 0;\n\n            while ( i < p.length ) {\n\n                var vs = [];\n                var ns = [];\n                var ts = null;\n                var cs = [];\n\n                if ( primitive.vcount ) {\n\n                    vcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;\n\n                } else {\n\n                    vcount = p.length / maxOffset;\n\n                }\n\n\n                for ( j = 0; j < vcount; j ++ ) {\n\n                    for ( k = 0; k < inputs.length; k ++ ) {\n\n                        input = inputs[ k ];\n                        source = sources[ input.source ];\n\n                        index = p[ i + ( j * maxOffset ) + input.offset ];\n                        numParams = source.accessor.params.length;\n                        idx32 = index * numParams;\n\n                        switch ( input.semantic ) {\n\n                            case 'VERTEX':\n\n                                vs.push( index );\n\n                                break;\n\n                            case 'NORMAL':\n\n                                ns.push( getConvertedVec3( source.data, idx32 ) );\n\n                                break;\n\n                            case 'TEXCOORD':\n\n                                ts = ts || { };\n                                if ( ts[ input.set ] === undefined ) ts[ input.set ] = [];\n                                // invert the V\n                                ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );\n\n                                break;\n\n                            case 'COLOR':\n\n                                cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\n\n                                break;\n\n                            default:\n\n                                break;\n\n                        }\n\n                    }\n\n                }\n\n                if ( ns.length === 0 ) {\n\n                    // check the vertices inputs\n                    input = this.vertices.input.NORMAL;\n\n                    if ( input ) {\n\n                        source = sources[ input.source ];\n                        numParams = source.accessor.params.length;\n\n                        for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n                            ns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );\n\n                        }\n\n                    } else {\n\n                        geom.calcNormals = true;\n\n                    }\n\n                }\n\n                if ( !ts ) {\n\n                    ts = { };\n                    // check the vertices inputs\n                    input = this.vertices.input.TEXCOORD;\n\n                    if ( input ) {\n\n                        texture_sets.push( input.set );\n                        source = sources[ input.source ];\n                        numParams = source.accessor.params.length;\n\n                        for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n                            idx32 = vs[ ndx ] * numParams;\n                            if ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];\n                            // invert the V\n                            ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );\n\n                        }\n\n                    }\n\n                }\n\n                if ( cs.length === 0 ) {\n\n                    // check the vertices inputs\n                    input = this.vertices.input.COLOR;\n\n                    if ( input ) {\n\n                        source = sources[ input.source ];\n                        numParams = source.accessor.params.length;\n\n                        for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n                            idx32 = vs[ ndx ] * numParams;\n                            cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\n\n                        }\n\n                    }\n\n                }\n\n                var face = null, faces = [], uv, uvArr;\n\n                if ( vcount === 3 ) {\n\n                    faces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );\n\n                } else if ( vcount === 4 ) {\n\n                    faces.push( new THREE.Face3( vs[0], vs[1], vs[3], ns.length ? [ ns[0].clone(), ns[1].clone(), ns[3].clone() ] : [], cs.length ? [ cs[0], cs[1], cs[3] ] : new THREE.Color() ) );\n\n                    faces.push( new THREE.Face3( vs[1], vs[2], vs[3], ns.length ? [ ns[1].clone(), ns[2].clone(), ns[3].clone() ] : [], cs.length ? [ cs[1], cs[2], cs[3] ] : new THREE.Color() ) );\n\n                } else if ( vcount > 4 && options.subdivideFaces ) {\n\n                    var clr = cs.length ? cs : new THREE.Color(),\n                        vec1, vec2, vec3, v1, v2, norm;\n\n                    // subdivide into multiple Face3s\n\n                    for ( k = 1; k < vcount - 1; ) {\n\n                        faces.push( new THREE.Face3( vs[0], vs[k], vs[k + 1], ns.length ? [ ns[0].clone(), ns[k ++].clone(), ns[k].clone() ] : [], clr ) );\n\n                    }\n\n                }\n\n                if ( faces.length ) {\n\n                    for ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {\n\n                        face = faces[ndx];\n                        face.daeMaterial = primitive.material;\n                        geom.faces.push( face );\n\n                        for ( k = 0; k < texture_sets.length; k ++ ) {\n\n                            uv = ts[ texture_sets[k] ];\n\n                            if ( vcount > 4 ) {\n\n                                // Grab the right UVs for the vertices in this face\n                                uvArr = [ uv[0], uv[ndx + 1], uv[ndx + 2] ];\n\n                            } else if ( vcount === 4 ) {\n\n                                if ( ndx === 0 ) {\n\n                                    uvArr = [ uv[0], uv[1], uv[3] ];\n\n                                } else {\n\n                                    uvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];\n\n                                }\n\n                            } else {\n\n                                uvArr = [ uv[0], uv[1], uv[2] ];\n\n                            }\n\n                            if ( geom.faceVertexUvs[k] === undefined ) {\n\n                                geom.faceVertexUvs[k] = [];\n\n                            }\n\n                            geom.faceVertexUvs[k].push( uvArr );\n\n                        }\n\n                    }\n\n                } else {\n\n                    console.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );\n\n                }\n\n                i += maxOffset * vcount;\n\n            }\n\n        }\n\n    };\n\n    function Polygons () {\n\n        this.material = \"\";\n        this.count = 0;\n        this.inputs = [];\n        this.vcount = null;\n        this.p = [];\n        this.geometry = new THREE.Geometry();\n\n    }\n\n    Polygons.prototype.setVertices = function ( vertices ) {\n\n        for ( var i = 0; i < this.inputs.length; i ++ ) {\n\n            if ( this.inputs[ i ].source === vertices.id ) {\n\n                this.inputs[ i ].source = vertices.input[ 'POSITION' ].source;\n\n            }\n\n        }\n\n    };\n\n    Polygons.prototype.parse = function ( element ) {\n\n        this.material = element.getAttribute( 'material' );\n        this.count = _attr_as_int( element, 'count', 0 );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            switch ( child.nodeName ) {\n\n                case 'input':\n\n                    this.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );\n                    break;\n\n                case 'vcount':\n\n                    this.vcount = _ints( child.textContent );\n                    break;\n\n                case 'p':\n\n                    this.p.push( _ints( child.textContent ) );\n                    break;\n\n                case 'ph':\n\n                    console.warn( 'polygon holes not yet supported!' );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Polylist () {\n\n        Polygons.call( this );\n\n        this.vcount = [];\n\n    }\n\n    Polylist.prototype = Object.create( Polygons.prototype );\n    Polylist.prototype.constructor = Polylist;\n\n    function LineStrips() {\n\n        Polygons.call( this );\n\n        this.vcount = 1;\n\n    }\n\n    LineStrips.prototype = Object.create( Polygons.prototype );\n    LineStrips.prototype.constructor = LineStrips;\n\n    function Triangles () {\n\n        Polygons.call( this );\n\n        this.vcount = 3;\n\n    }\n\n    Triangles.prototype = Object.create( Polygons.prototype );\n    Triangles.prototype.constructor = Triangles;\n\n    function Accessor() {\n\n        this.source = \"\";\n        this.count = 0;\n        this.stride = 0;\n        this.params = [];\n\n    }\n\n    Accessor.prototype.parse = function ( element ) {\n\n        this.params = [];\n        this.source = element.getAttribute( 'source' );\n        this.count = _attr_as_int( element, 'count', 0 );\n        this.stride = _attr_as_int( element, 'stride', 0 );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            if ( child.nodeName === 'param' ) {\n\n                var param = {};\n                param[ 'name' ] = child.getAttribute( 'name' );\n                param[ 'type' ] = child.getAttribute( 'type' );\n                this.params.push( param );\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Vertices() {\n\n        this.input = {};\n\n    }\n\n    Vertices.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute('id');\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            if ( element.childNodes[i].nodeName === 'input' ) {\n\n                var input = ( new Input() ).parse( element.childNodes[ i ] );\n                this.input[ input.semantic ] = input;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Input () {\n\n        this.semantic = \"\";\n        this.offset = 0;\n        this.source = \"\";\n        this.set = 0;\n\n    }\n\n    Input.prototype.parse = function ( element ) {\n\n        this.semantic = element.getAttribute('semantic');\n        this.source = element.getAttribute('source').replace(/^#/, '');\n        this.set = _attr_as_int(element, 'set', -1);\n        this.offset = _attr_as_int(element, 'offset', 0);\n\n        if ( this.semantic === 'TEXCOORD' && this.set < 0 ) {\n\n            this.set = 0;\n\n        }\n\n        return this;\n\n    };\n\n    function Source ( id ) {\n\n        this.id = id;\n        this.type = null;\n\n    }\n\n    Source.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n\n            switch ( child.nodeName ) {\n\n                case 'bool_array':\n\n                    this.data = _bools( child.textContent );\n                    this.type = child.nodeName;\n                    break;\n\n                case 'float_array':\n\n                    this.data = _floats( child.textContent );\n                    this.type = child.nodeName;\n                    break;\n\n                case 'int_array':\n\n                    this.data = _ints( child.textContent );\n                    this.type = child.nodeName;\n                    break;\n\n                case 'IDREF_array':\n                case 'Name_array':\n\n                    this.data = _strings( child.textContent );\n                    this.type = child.nodeName;\n                    break;\n\n                case 'technique_common':\n\n                    for ( var j = 0; j < child.childNodes.length; j ++ ) {\n\n                        if ( child.childNodes[ j ].nodeName === 'accessor' ) {\n\n                            this.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );\n                            break;\n\n                        }\n                    }\n                    break;\n\n                default:\n                    // console.log(child.nodeName);\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Source.prototype.read = function () {\n\n        var result = [];\n\n        //for (var i = 0; i < this.accessor.params.length; i++) {\n\n        var param = this.accessor.params[ 0 ];\n\n            //console.log(param.name + \" \" + param.type);\n\n        switch ( param.type ) {\n\n            case 'IDREF':\n            case 'Name': case 'name':\n            case 'float':\n\n                return this.data;\n\n            case 'float4x4':\n\n                for ( var j = 0; j < this.data.length; j += 16 ) {\n\n                    var s = this.data.slice( j, j + 16 );\n                    var m = getConvertedMat4( s );\n                    result.push( m );\n                }\n\n                break;\n\n            default:\n\n                console.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );\n                break;\n\n        }\n\n        //}\n\n        return result;\n\n    };\n\n    function Material () {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.instance_effect = null;\n\n    }\n\n    Material.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            if ( element.childNodes[ i ].nodeName === 'instance_effect' ) {\n\n                this.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );\n                break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function ColorOrTexture () {\n\n        this.color = new THREE.Color();\n        this.color.setRGB( Math.random(), Math.random(), Math.random() );\n        this.color.a = 1.0;\n\n        this.texture = null;\n        this.texcoord = null;\n        this.texOpts = null;\n\n    }\n\n    ColorOrTexture.prototype.isColor = function () {\n\n        return ( this.texture === null );\n\n    };\n\n    ColorOrTexture.prototype.isTexture = function () {\n\n        return ( this.texture != null );\n\n    };\n\n    ColorOrTexture.prototype.parse = function ( element ) {\n\n        if (element.nodeName === 'transparent') {\n\n            this.opaque = element.getAttribute('opaque');\n\n        }\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'color':\n\n                    var rgba = _floats( child.textContent );\n                    this.color = new THREE.Color();\n                    this.color.setRGB( rgba[0], rgba[1], rgba[2] );\n                    this.color.a = rgba[3];\n                    break;\n\n                case 'texture':\n\n                    this.texture = child.getAttribute('texture');\n                    this.texcoord = child.getAttribute('texcoord');\n                    // Defaults from:\n                    // https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension\n                    this.texOpts = {\n                        offsetU: 0,\n                        offsetV: 0,\n                        repeatU: 1,\n                        repeatV: 1,\n                        wrapU: 1,\n                        wrapV: 1\n                    };\n                    this.parseTexture( child );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    ColorOrTexture.prototype.parseTexture = function ( element ) {\n\n        if ( ! element.childNodes ) return this;\n\n        // This should be supported by Maya, 3dsMax, and MotionBuilder\n\n        if ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {\n\n            element = element.childNodes[1];\n\n            if ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {\n\n                element = element.childNodes[1];\n\n            }\n\n        }\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            switch ( child.nodeName ) {\n\n                case 'offsetU':\n                case 'offsetV':\n                case 'repeatU':\n                case 'repeatV':\n\n                    this.texOpts[ child.nodeName ] = parseFloat( child.textContent );\n\n                    break;\n\n                case 'wrapU':\n                case 'wrapV':\n\n                    // some dae have a value of true which becomes NaN via parseInt\n\n                    if ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n                        this.texOpts[ child.nodeName ] = 1;\n\n                    } else {\n\n                        this.texOpts[ child.nodeName ] = parseInt( child.textContent );\n\n                    }\n                    break;\n\n                default:\n\n                    this.texOpts[ child.nodeName ] = child.textContent;\n\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Shader ( type, effect ) {\n\n        this.type = type;\n        this.effect = effect;\n        this.material = null;\n\n    }\n\n    Shader.prototype.parse = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'emission':\n                case 'diffuse':\n                case 'specular':\n                case 'transparent':\n\n                    this[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );\n                    break;\n\n                case 'bump':\n\n                    // If 'bumptype' is 'heightfield', create a 'bump' property\n                    // Else if 'bumptype' is 'normalmap', create a 'normal' property\n                    // (Default to 'bump')\n                    var bumpType = child.getAttribute( 'bumptype' );\n                    if ( bumpType ) {\n                        if ( bumpType.toLowerCase() === \"heightfield\" ) {\n                            this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n                        } else if ( bumpType.toLowerCase() === \"normalmap\" ) {\n                            this[ 'normal' ] = ( new ColorOrTexture() ).parse( child );\n                        } else {\n                            console.error( \"Shader.prototype.parse: Invalid value for attribute 'bumptype' (\" + bumpType + \") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'\" );\n                            this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n                        }\n                    } else {\n                        console.warn( \"Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'\" );\n                        this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n                    }\n\n                    break;\n\n                case 'shininess':\n                case 'reflectivity':\n                case 'index_of_refraction':\n                case 'transparency':\n\n                    var f = child.querySelectorAll('float');\n\n                    if ( f.length > 0 )\n                        this[ child.nodeName ] = parseFloat( f[ 0 ].textContent );\n\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        this.create();\n        return this;\n\n    };\n\n    Shader.prototype.create = function() {\n\n        var props = {};\n\n        var transparent = false;\n\n        if (this['transparency'] !== undefined && this['transparent'] !== undefined) {\n            // convert transparent color RBG to average value\n            var transparentColor = this['transparent'];\n            var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;\n\n            if (transparencyLevel > 0) {\n                transparent = true;\n                props[ 'transparent' ] = true;\n                props[ 'opacity' ] = 1 - transparencyLevel;\n\n            }\n\n        }\n\n        var keys = {\n            'diffuse':'map',\n            'ambient':'lightMap',\n            'specular':'specularMap',\n            'emission':'emissionMap',\n            'bump':'bumpMap',\n            'normal':'normalMap'\n            };\n\n        for ( var prop in this ) {\n\n            switch ( prop ) {\n\n                case 'ambient':\n                case 'emission':\n                case 'diffuse':\n                case 'specular':\n                case 'bump':\n                case 'normal':\n\n                    var cot = this[ prop ];\n\n                    if ( cot instanceof ColorOrTexture ) {\n\n                        if ( cot.isTexture() ) {\n\n                            var samplerId = cot.texture;\n                            var surfaceId = this.effect.sampler[samplerId];\n\n                            if ( surfaceId !== undefined && surfaceId.source !== undefined ) {\n\n                                var surface = this.effect.surface[surfaceId.source];\n\n                                if ( surface !== undefined ) {\n\n                                    var image = images[ surface.init_from ];\n\n                                    if ( image ) {\n\n                                        var url = baseUrl + image.init_from;\n\n                                        var texture;\n                                        var loader = THREE.Loader.Handlers.get( url );\n\n                                        if ( loader !== null ) {\n\n                                            texture = loader.load( url );\n\n                                        } else {\n\n                                            texture = new THREE.Texture();\n\n                                            loadTextureImage( texture, url );\n\n                                        }\n\n                                        texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n                                        texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n                                        texture.offset.x = cot.texOpts.offsetU;\n                                        texture.offset.y = cot.texOpts.offsetV;\n                                        texture.repeat.x = cot.texOpts.repeatU;\n                                        texture.repeat.y = cot.texOpts.repeatV;\n                                        props[keys[prop]] = texture;\n\n                                        // Texture with baked lighting?\n                                        if (prop === 'emission') props['emissive'] = 0xffffff;\n\n                                    }\n\n                                }\n\n                            }\n\n                        } else if ( prop === 'diffuse' || !transparent ) {\n\n                            if ( prop === 'emission' ) {\n\n                                props[ 'emissive' ] = cot.color.getHex();\n\n                            } else {\n\n                                props[ prop ] = cot.color.getHex();\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                case 'shininess':\n\n                    props[ prop ] = this[ prop ];\n                    break;\n\n                case 'reflectivity':\n\n                    props[ prop ] = this[ prop ];\n                    if ( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;\n                    props['combine'] = THREE.MixOperation;\t//mix regular shading with reflective component\n                    break;\n\n                case 'index_of_refraction':\n\n                    props[ 'refractionRatio' ] = this[ prop ]; //TODO: \"index_of_refraction\" becomes \"refractionRatio\" in shader, but I'm not sure if the two are actually comparable\n                    if ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;\n                    break;\n\n                case 'transparency':\n                    // gets figured out up top\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        props[ 'shading' ] = preferredShading;\n        props[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;\n\n        if ( props.diffuse !== undefined ) {\n\n            props.color = props.diffuse;\n            delete props.diffuse;\n\n        }\n\n        switch ( this.type ) {\n\n            case 'constant':\n\n                if (props.emissive != undefined) props.color = props.emissive;\n                this.material = new THREE.MeshBasicMaterial( props );\n                break;\n\n            case 'phong':\n            case 'blinn':\n\n                this.material = new THREE.MeshPhongMaterial( props );\n                break;\n\n            case 'lambert':\n            default:\n\n                this.material = new THREE.MeshLambertMaterial( props );\n                break;\n\n        }\n\n        return this.material;\n\n    };\n\n    function Surface ( effect ) {\n\n        this.effect = effect;\n        this.init_from = null;\n        this.format = null;\n\n    }\n\n    Surface.prototype.parse = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'init_from':\n\n                    this.init_from = child.textContent;\n                    break;\n\n                case 'format':\n\n                    this.format = child.textContent;\n                    break;\n\n                default:\n\n                    console.log( \"unhandled Surface prop: \" + child.nodeName );\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Sampler2D ( effect ) {\n\n        this.effect = effect;\n        this.source = null;\n        this.wrap_s = null;\n        this.wrap_t = null;\n        this.minfilter = null;\n        this.magfilter = null;\n        this.mipfilter = null;\n\n    }\n\n    Sampler2D.prototype.parse = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'source':\n\n                    this.source = child.textContent;\n                    break;\n\n                case 'minfilter':\n\n                    this.minfilter = child.textContent;\n                    break;\n\n                case 'magfilter':\n\n                    this.magfilter = child.textContent;\n                    break;\n\n                case 'mipfilter':\n\n                    this.mipfilter = child.textContent;\n                    break;\n\n                case 'wrap_s':\n\n                    this.wrap_s = child.textContent;\n                    break;\n\n                case 'wrap_t':\n\n                    this.wrap_t = child.textContent;\n                    break;\n\n                default:\n\n                    console.log( \"unhandled Sampler2D prop: \" + child.nodeName );\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Effect () {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.shader = null;\n        this.surface = {};\n        this.sampler = {};\n\n    }\n\n    Effect.prototype.create = function () {\n\n        if ( this.shader === null ) {\n\n            return null;\n\n        }\n\n    };\n\n    Effect.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n\n        extractDoubleSided( this, element );\n\n        this.shader = null;\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'profile_COMMON':\n\n                    this.parseTechnique( this.parseProfileCOMMON( child ) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Effect.prototype.parseNewparam = function ( element ) {\n\n        var sid = element.getAttribute( 'sid' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'surface':\n\n                    this.surface[sid] = ( new Surface( this ) ).parse( child );\n                    break;\n\n                case 'sampler2D':\n\n                    this.sampler[sid] = ( new Sampler2D( this ) ).parse( child );\n                    break;\n\n                case 'extra':\n\n                    break;\n\n                default:\n\n                    console.log( child.nodeName );\n                    break;\n\n            }\n\n        }\n\n    };\n\n    Effect.prototype.parseProfileCOMMON = function ( element ) {\n\n        var technique;\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'profile_COMMON':\n\n                    this.parseProfileCOMMON( child );\n                    break;\n\n                case 'technique':\n\n                    technique = child;\n                    break;\n\n                case 'newparam':\n\n                    this.parseNewparam( child );\n                    break;\n\n                case 'image':\n\n                    var _image = ( new _Image() ).parse( child );\n                    images[ _image.id ] = _image;\n                    break;\n\n                case 'extra':\n                    break;\n\n                default:\n\n                    console.log( child.nodeName );\n                    break;\n\n            }\n\n        }\n\n        return technique;\n\n    };\n\n    Effect.prototype.parseTechnique = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'constant':\n                case 'lambert':\n                case 'blinn':\n                case 'phong':\n\n                    this.shader = ( new Shader( child.nodeName, this ) ).parse( child );\n                    break;\n                case 'extra':\n                    this.parseExtra(child);\n                    break;\n                default:\n                    break;\n\n            }\n\n        }\n\n    };\n\n    Effect.prototype.parseExtra = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'technique':\n                    this.parseExtraTechnique( child );\n                    break;\n                default:\n                    break;\n\n            }\n\n        }\n\n    };\n\n    Effect.prototype.parseExtraTechnique = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[i];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'bump':\n                    this.shader.parse( element );\n                    break;\n                default:\n                    break;\n\n            }\n\n        }\n\n    };\n\n    function InstanceEffect () {\n\n        this.url = \"\";\n\n    }\n\n    InstanceEffect.prototype.parse = function ( element ) {\n\n        this.url = element.getAttribute( 'url' ).replace( /^#/, '' );\n        return this;\n\n    };\n\n    function Animation() {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.source = {};\n        this.sampler = [];\n        this.channel = [];\n\n    }\n\n    Animation.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n        this.source = {};\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'animation':\n\n                    var anim = ( new Animation() ).parse( child );\n\n                    for ( var src in anim.source ) {\n\n                        this.source[ src ] = anim.source[ src ];\n\n                    }\n\n                    for ( var j = 0; j < anim.channel.length; j ++ ) {\n\n                        this.channel.push( anim.channel[ j ] );\n                        this.sampler.push( anim.sampler[ j ] );\n\n                    }\n\n                    break;\n\n                case 'source':\n\n                    var src = ( new Source() ).parse( child );\n                    this.source[ src.id ] = src;\n                    break;\n\n                case 'sampler':\n\n                    this.sampler.push( ( new Sampler( this ) ).parse( child ) );\n                    break;\n\n                case 'channel':\n\n                    this.channel.push( ( new Channel( this ) ).parse( child ) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Channel( animation ) {\n\n        this.animation = animation;\n        this.source = \"\";\n        this.target = \"\";\n        this.fullSid = null;\n        this.sid = null;\n        this.dotSyntax = null;\n        this.arrSyntax = null;\n        this.arrIndices = null;\n        this.member = null;\n\n    }\n\n    Channel.prototype.parse = function ( element ) {\n\n        this.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n        this.target = element.getAttribute( 'target' );\n\n        var parts = this.target.split( '/' );\n\n        var id = parts.shift();\n        var sid = parts.shift();\n\n        var dotSyntax = ( sid.indexOf(\".\") >= 0 );\n        var arrSyntax = ( sid.indexOf(\"(\") >= 0 );\n\n        if ( dotSyntax ) {\n\n            parts = sid.split(\".\");\n            this.sid = parts.shift();\n            this.member = parts.shift();\n\n        } else if ( arrSyntax ) {\n\n            var arrIndices = sid.split(\"(\");\n            this.sid = arrIndices.shift();\n\n            for (var j = 0; j < arrIndices.length; j ++ ) {\n\n                arrIndices[j] = parseInt( arrIndices[j].replace(/\\)/, '') );\n\n            }\n\n            this.arrIndices = arrIndices;\n\n        } else {\n\n            this.sid = sid;\n\n        }\n\n        this.fullSid = sid;\n        this.dotSyntax = dotSyntax;\n        this.arrSyntax = arrSyntax;\n\n        return this;\n\n    };\n\n    function Sampler ( animation ) {\n\n        this.id = \"\";\n        this.animation = animation;\n        this.inputs = [];\n        this.input = null;\n        this.output = null;\n        this.strideOut = null;\n        this.interpolation = null;\n        this.startTime = null;\n        this.endTime = null;\n        this.duration = 0;\n\n    }\n\n    Sampler.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.inputs = [];\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'input':\n\n                    this.inputs.push( (new Input()).parse( child ) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Sampler.prototype.create = function () {\n\n        for ( var i = 0; i < this.inputs.length; i ++ ) {\n\n            var input = this.inputs[ i ];\n            var source = this.animation.source[ input.source ];\n\n            switch ( input.semantic ) {\n\n                case 'INPUT':\n\n                    this.input = source.read();\n                    break;\n\n                case 'OUTPUT':\n\n                    this.output = source.read();\n                    this.strideOut = source.accessor.stride;\n                    break;\n\n                case 'INTERPOLATION':\n\n                    this.interpolation = source.read();\n                    break;\n\n                case 'IN_TANGENT':\n\n                    break;\n\n                case 'OUT_TANGENT':\n\n                    break;\n\n                default:\n\n                    console.log(input.semantic);\n                    break;\n\n            }\n\n        }\n\n        this.startTime = 0;\n        this.endTime = 0;\n        this.duration = 0;\n\n        if ( this.input.length ) {\n\n            this.startTime = 100000000;\n            this.endTime = -100000000;\n\n            for ( var i = 0; i < this.input.length; i ++ ) {\n\n                this.startTime = Math.min( this.startTime, this.input[ i ] );\n                this.endTime = Math.max( this.endTime, this.input[ i ] );\n\n            }\n\n            this.duration = this.endTime - this.startTime;\n\n        }\n\n    };\n\n    Sampler.prototype.getData = function ( type, ndx, member ) {\n\n        var data;\n\n        if ( type === 'matrix' && this.strideOut === 16 ) {\n\n            data = this.output[ ndx ];\n\n        } else if ( this.strideOut > 1 ) {\n\n            data = [];\n            ndx *= this.strideOut;\n\n            for ( var i = 0; i < this.strideOut; ++ i ) {\n\n                data[ i ] = this.output[ ndx + i ];\n\n            }\n\n            if ( this.strideOut === 3 ) {\n\n                switch ( type ) {\n\n                    case 'rotate':\n                    case 'translate':\n\n                        fixCoords( data, -1 );\n                        break;\n\n                    case 'scale':\n\n                        fixCoords( data, 1 );\n                        break;\n\n                }\n\n            } else if ( this.strideOut === 4 && type === 'matrix' ) {\n\n                fixCoords( data, -1 );\n\n            }\n\n        } else {\n\n            data = this.output[ ndx ];\n\n            if ( member && type === 'translate' ) {\n                data = getConvertedTranslation( member, data );\n            }\n\n        }\n\n        return data;\n\n    };\n\n    function Key ( time ) {\n\n        this.targets = [];\n        this.time = time;\n\n    }\n\n    Key.prototype.addTarget = function ( fullSid, transform, member, data ) {\n\n        this.targets.push( {\n            sid: fullSid,\n            member: member,\n            transform: transform,\n            data: data\n        } );\n\n    };\n\n    Key.prototype.apply = function ( opt_sid ) {\n\n        for ( var i = 0; i < this.targets.length; ++ i ) {\n\n            var target = this.targets[ i ];\n\n            if ( !opt_sid || target.sid === opt_sid ) {\n\n                target.transform.update( target.data, target.member );\n\n            }\n\n        }\n\n    };\n\n    Key.prototype.getTarget = function ( fullSid ) {\n\n        for ( var i = 0; i < this.targets.length; ++ i ) {\n\n            if ( this.targets[ i ].sid === fullSid ) {\n\n                return this.targets[ i ];\n\n            }\n\n        }\n\n        return null;\n\n    };\n\n    Key.prototype.hasTarget = function ( fullSid ) {\n\n        for ( var i = 0; i < this.targets.length; ++ i ) {\n\n            if ( this.targets[ i ].sid === fullSid ) {\n\n                return true;\n\n            }\n\n        }\n\n        return false;\n\n    };\n\n    // TODO: Currently only doing linear interpolation. Should support full COLLADA spec.\n    Key.prototype.interpolate = function ( nextKey, time ) {\n\n        for ( var i = 0, l = this.targets.length; i < l; i ++ ) {\n\n            var target = this.targets[ i ],\n                nextTarget = nextKey.getTarget( target.sid ),\n                data;\n\n            if ( target.transform.type !== 'matrix' && nextTarget ) {\n\n                var scale = ( time - this.time ) / ( nextKey.time - this.time ),\n                    nextData = nextTarget.data,\n                    prevData = target.data;\n\n                if ( scale < 0 ) scale = 0;\n                if ( scale > 1 ) scale = 1;\n\n                if ( prevData.length ) {\n\n                    data = [];\n\n                    for ( var j = 0; j < prevData.length; ++ j ) {\n\n                        data[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;\n\n                    }\n\n                } else {\n\n                    data = prevData + ( nextData - prevData ) * scale;\n\n                }\n\n            } else {\n\n                data = target.data;\n\n            }\n\n            target.transform.update( data, target.member );\n\n        }\n\n    };\n\n    // Camera\n    function Camera() {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.technique = \"\";\n\n    }\n\n    Camera.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'optics':\n\n                    this.parseOptics( child );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Camera.prototype.parseOptics = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            if ( element.childNodes[ i ].nodeName === 'technique_common' ) {\n\n                var technique = element.childNodes[ i ];\n\n                for ( var j = 0; j < technique.childNodes.length; j ++ ) {\n\n                    this.technique = technique.childNodes[ j ].nodeName;\n\n                    if ( this.technique === 'perspective' ) {\n\n                        var perspective = technique.childNodes[ j ];\n\n                        for ( var k = 0; k < perspective.childNodes.length; k ++ ) {\n\n                            var param = perspective.childNodes[ k ];\n\n                            switch ( param.nodeName ) {\n\n                                case 'yfov':\n                                    this.yfov = param.textContent;\n                                    break;\n                                case 'xfov':\n                                    this.xfov = param.textContent;\n                                    break;\n                                case 'znear':\n                                    this.znear = param.textContent;\n                                    break;\n                                case 'zfar':\n                                    this.zfar = param.textContent;\n                                    break;\n                                case 'aspect_ratio':\n                                    this.aspect_ratio = param.textContent;\n                                    break;\n\n                            }\n\n                        }\n\n                    } else if ( this.technique === 'orthographic' ) {\n\n                        var orthographic = technique.childNodes[ j ];\n\n                        for ( var k = 0; k < orthographic.childNodes.length; k ++ ) {\n\n                            var param = orthographic.childNodes[ k ];\n\n                            switch ( param.nodeName ) {\n\n                                case 'xmag':\n                                    this.xmag = param.textContent;\n                                    break;\n                                case 'ymag':\n                                    this.ymag = param.textContent;\n                                    break;\n                                case 'znear':\n                                    this.znear = param.textContent;\n                                    break;\n                                case 'zfar':\n                                    this.zfar = param.textContent;\n                                    break;\n                                case 'aspect_ratio':\n                                    this.aspect_ratio = param.textContent;\n                                    break;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function InstanceCamera() {\n\n        this.url = \"\";\n\n    }\n\n    InstanceCamera.prototype.parse = function ( element ) {\n\n        this.url = element.getAttribute('url').replace(/^#/, '');\n\n        return this;\n\n    };\n\n    // Light\n\n    function Light() {\n\n        this.id = \"\";\n        this.name = \"\";\n        this.technique = \"\";\n\n    }\n\n    Light.prototype.parse = function ( element ) {\n\n        this.id = element.getAttribute( 'id' );\n        this.name = element.getAttribute( 'name' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'technique_common':\n\n                    this.parseCommon( child );\n                    break;\n\n                case 'technique':\n\n                    this.parseTechnique( child );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Light.prototype.parseCommon = function ( element ) {\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            switch ( element.childNodes[ i ].nodeName ) {\n\n                case 'directional':\n                case 'point':\n                case 'spot':\n                case 'ambient':\n\n                    this.technique = element.childNodes[ i ].nodeName;\n\n                    var light = element.childNodes[ i ];\n\n                    for ( var j = 0; j < light.childNodes.length; j ++ ) {\n\n                        var child = light.childNodes[j];\n\n                        switch ( child.nodeName ) {\n\n                            case 'color':\n\n                                var rgba = _floats( child.textContent );\n                                this.color = new THREE.Color(0);\n                                this.color.setRGB( rgba[0], rgba[1], rgba[2] );\n                                this.color.a = rgba[3];\n                                break;\n\n                            case 'falloff_angle':\n\n                                this.falloff_angle = parseFloat( child.textContent );\n                                break;\n\n                            case 'quadratic_attenuation':\n                                var f = parseFloat( child.textContent );\n                                this.distance = f ? Math.sqrt( 1 / f ) : 0;\n                        }\n\n                    }\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    Light.prototype.parseTechnique = function ( element ) {\n\n        this.profile = element.getAttribute( 'profile' );\n\n        for ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n\n            switch ( child.nodeName ) {\n\n                case 'intensity':\n\n                    this.intensity = parseFloat(child.textContent);\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function InstanceLight() {\n\n        this.url = \"\";\n\n    }\n\n    InstanceLight.prototype.parse = function ( element ) {\n\n        this.url = element.getAttribute('url').replace(/^#/, '');\n\n        return this;\n\n    };\n\n    function KinematicsModel( ) {\n\n        this.id = '';\n        this.name = '';\n        this.joints = [];\n        this.links = [];\n\n    }\n\n    KinematicsModel.prototype.parse = function( element ) {\n\n        this.id = element.getAttribute('id');\n        this.name = element.getAttribute('name');\n        this.joints = [];\n        this.links = [];\n\n        for (var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'technique_common':\n\n                    this.parseCommon(child);\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    KinematicsModel.prototype.parseCommon = function( element ) {\n\n        for (var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( element.childNodes[ i ].nodeName ) {\n\n                case 'joint':\n                    this.joints.push( (new Joint()).parse(child) );\n                    break;\n\n                case 'link':\n                    this.links.push( (new Link()).parse(child) );\n                    break;\n\n                default:\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Joint( ) {\n\n        this.sid = '';\n        this.name = '';\n        this.axis = new THREE.Vector3();\n        this.limits = {\n            min: 0,\n            max: 0\n        };\n        this.type = '';\n        this.static = false;\n        this.zeroPosition = 0.0;\n        this.middlePosition = 0.0;\n\n    }\n\n    Joint.prototype.parse = function( element ) {\n\n        this.sid = element.getAttribute('sid');\n        this.name = element.getAttribute('name');\n        this.axis = new THREE.Vector3();\n        this.limits = {\n            min: 0,\n            max: 0\n        };\n        this.type = '';\n        this.static = false;\n        this.zeroPosition = 0.0;\n        this.middlePosition = 0.0;\n\n        var axisElement = element.querySelector('axis');\n        var _axis = _floats(axisElement.textContent);\n        this.axis = getConvertedVec3(_axis, 0);\n\n        var min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;\n        var max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;\n\n        this.limits = {\n            min: min,\n            max: max\n        };\n\n        var jointTypes = [ 'prismatic', 'revolute' ];\n        for (var i = 0; i < jointTypes.length; i ++ ) {\n\n            var type = jointTypes[ i ];\n\n            var jointElement = element.querySelector(type);\n\n            if ( jointElement ) {\n\n                this.type = type;\n\n            }\n\n        }\n\n        // if the min is equal to or somehow greater than the max, consider the joint static\n        if ( this.limits.min >= this.limits.max ) {\n\n            this.static = true;\n\n        }\n\n        this.middlePosition = (this.limits.min + this.limits.max) / 2.0;\n        return this;\n\n    };\n\n    function Link( ) {\n\n        this.sid = '';\n        this.name = '';\n        this.transforms = [];\n        this.attachments = [];\n\n    }\n\n    Link.prototype.parse = function( element ) {\n\n        this.sid = element.getAttribute('sid');\n        this.name = element.getAttribute('name');\n        this.transforms = [];\n        this.attachments = [];\n\n        for (var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'attachment_full':\n                    this.attachments.push( (new Attachment()).parse(child) );\n                    break;\n\n                case 'rotate':\n                case 'translate':\n                case 'matrix':\n\n                    this.transforms.push( (new Transform()).parse(child) );\n                    break;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function Attachment( ) {\n\n        this.joint = '';\n        this.transforms = [];\n        this.links = [];\n\n    }\n\n    Attachment.prototype.parse = function( element ) {\n\n        this.joint = element.getAttribute('joint').split('/').pop();\n        this.links = [];\n\n        for (var i = 0; i < element.childNodes.length; i ++ ) {\n\n            var child = element.childNodes[ i ];\n            if ( child.nodeType != 1 ) continue;\n\n            switch ( child.nodeName ) {\n\n                case 'link':\n                    this.links.push( (new Link()).parse(child) );\n                    break;\n\n                case 'rotate':\n                case 'translate':\n                case 'matrix':\n\n                    this.transforms.push( (new Transform()).parse(child) );\n                    break;\n\n                default:\n\n                    break;\n\n            }\n\n        }\n\n        return this;\n\n    };\n\n    function _source( element ) {\n\n        var id = element.getAttribute( 'id' );\n\n        if ( sources[ id ] != undefined ) {\n\n            return sources[ id ];\n\n        }\n\n        sources[ id ] = ( new Source(id )).parse( element );\n        return sources[ id ];\n\n    }\n\n    function _nsResolver( nsPrefix ) {\n\n        if ( nsPrefix === \"dae\" ) {\n\n            return \"http://www.collada.org/2005/11/COLLADASchema\";\n\n        }\n\n        return null;\n\n    }\n\n    function _bools( str ) {\n\n        var raw = _strings( str );\n        var data = [];\n\n        for ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n            data.push( (raw[i] === 'true' || raw[i] === '1') ? true : false );\n\n        }\n\n        return data;\n\n    }\n\n    function _floats( str ) {\n\n        var raw = _strings(str);\n        var data = [];\n\n        for ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n            data.push( parseFloat( raw[ i ] ) );\n\n        }\n\n        return data;\n\n    }\n\n    function _ints( str ) {\n\n        var raw = _strings( str );\n        var data = [];\n\n        for ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n            data.push( parseInt( raw[ i ], 10 ) );\n\n        }\n\n        return data;\n\n    }\n\n    function _strings( str ) {\n\n        return ( str.length > 0 ) ? _trimString( str ).split( /\\s+/ ) : [];\n\n    }\n\n    function _trimString( str ) {\n\n        return str.replace( /^\\s+/, \"\" ).replace( /\\s+$/, \"\" );\n\n    }\n\n    function _attr_as_float( element, name, defaultValue ) {\n\n        if ( element.hasAttribute( name ) ) {\n\n            return parseFloat( element.getAttribute( name ) );\n\n        } else {\n\n            return defaultValue;\n\n        }\n\n    }\n\n    function _attr_as_int( element, name, defaultValue ) {\n\n        if ( element.hasAttribute( name ) ) {\n\n            return parseInt( element.getAttribute( name ), 10) ;\n\n        } else {\n\n            return defaultValue;\n\n        }\n\n    }\n\n    function _attr_as_string( element, name, defaultValue ) {\n\n        if ( element.hasAttribute( name ) ) {\n\n            return element.getAttribute( name );\n\n        } else {\n\n            return defaultValue;\n\n        }\n\n    }\n\n    function _format_float( f, num ) {\n\n        if ( f === undefined ) {\n\n            var s = '0.';\n\n            while ( s.length < num + 2 ) {\n\n                s += '0';\n\n            }\n\n            return s;\n\n        }\n\n        num = num || 2;\n\n        var parts = f.toString().split( '.' );\n        parts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : \"0\";\n\n        while ( parts[ 1 ].length < num ) {\n\n            parts[ 1 ] += '0';\n\n        }\n\n        return parts.join( '.' );\n\n    }\n\n    function loadTextureImage ( texture, url ) {\n\n        var loader = new THREE.ImageLoader();\n\n        loader.load( url, function ( image ) {\n\n            texture.image = image;\n            texture.needsUpdate = true;\n\n        } );\n\n    }\n\n    function extractDoubleSided( obj, element ) {\n\n        obj.doubleSided = false;\n\n        var node = element.querySelectorAll('extra double_sided')[0];\n\n        if ( node ) {\n\n            if ( node && parseInt( node.textContent, 10 ) === 1 ) {\n\n                obj.doubleSided = true;\n\n            }\n\n        }\n\n    }\n\n    // Up axis conversion\n\n    function setUpConversion() {\n\n        if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n            upConversion = null;\n\n        } else {\n\n            switch ( colladaUp ) {\n\n                case 'X':\n\n                    upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';\n                    break;\n\n                case 'Y':\n\n                    upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';\n                    break;\n\n                case 'Z':\n\n                    upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';\n                    break;\n\n            }\n\n        }\n\n    }\n\n    function fixCoords( data, sign ) {\n\n        if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n            return;\n\n        }\n\n        switch ( upConversion ) {\n\n            case 'XtoY':\n\n                var tmp = data[ 0 ];\n                data[ 0 ] = sign * data[ 1 ];\n                data[ 1 ] = tmp;\n                break;\n\n            case 'XtoZ':\n\n                var tmp = data[ 2 ];\n                data[ 2 ] = data[ 1 ];\n                data[ 1 ] = data[ 0 ];\n                data[ 0 ] = tmp;\n                break;\n\n            case 'YtoX':\n\n                var tmp = data[ 0 ];\n                data[ 0 ] = data[ 1 ];\n                data[ 1 ] = sign * tmp;\n                break;\n\n            case 'YtoZ':\n\n                var tmp = data[ 1 ];\n                data[ 1 ] = sign * data[ 2 ];\n                data[ 2 ] = tmp;\n                break;\n\n            case 'ZtoX':\n\n                var tmp = data[ 0 ];\n                data[ 0 ] = data[ 1 ];\n                data[ 1 ] = data[ 2 ];\n                data[ 2 ] = tmp;\n                break;\n\n            case 'ZtoY':\n\n                var tmp = data[ 1 ];\n                data[ 1 ] = data[ 2 ];\n                data[ 2 ] = sign * tmp;\n                break;\n\n        }\n\n    }\n\n    function getConvertedTranslation( axis, data ) {\n\n        if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n            return data;\n\n        }\n\n        switch ( axis ) {\n            case 'X':\n                data = upConversion === 'XtoY' ? data * -1 : data;\n                break;\n            case 'Y':\n                data = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;\n                break;\n            case 'Z':\n                data = upConversion === 'ZtoY' ? data * -1 : data ;\n                break;\n            default:\n                break;\n        }\n\n        return data;\n    }\n\n    function getConvertedVec3( data, offset ) {\n\n        var arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];\n        fixCoords( arr, -1 );\n        return new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );\n\n    }\n\n    function getConvertedMat4( data ) {\n\n        if ( options.convertUpAxis ) {\n\n            // First fix rotation and scale\n\n            // Columns first\n            var arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];\n            fixCoords( arr, -1 );\n            data[ 0 ] = arr[ 0 ];\n            data[ 4 ] = arr[ 1 ];\n            data[ 8 ] = arr[ 2 ];\n            arr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];\n            fixCoords( arr, -1 );\n            data[ 1 ] = arr[ 0 ];\n            data[ 5 ] = arr[ 1 ];\n            data[ 9 ] = arr[ 2 ];\n            arr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];\n            fixCoords( arr, -1 );\n            data[ 2 ] = arr[ 0 ];\n            data[ 6 ] = arr[ 1 ];\n            data[ 10 ] = arr[ 2 ];\n            // Rows second\n            arr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];\n            fixCoords( arr, -1 );\n            data[ 0 ] = arr[ 0 ];\n            data[ 1 ] = arr[ 1 ];\n            data[ 2 ] = arr[ 2 ];\n            arr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];\n            fixCoords( arr, -1 );\n            data[ 4 ] = arr[ 0 ];\n            data[ 5 ] = arr[ 1 ];\n            data[ 6 ] = arr[ 2 ];\n            arr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];\n            fixCoords( arr, -1 );\n            data[ 8 ] = arr[ 0 ];\n            data[ 9 ] = arr[ 1 ];\n            data[ 10 ] = arr[ 2 ];\n\n            // Now fix translation\n            arr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];\n            fixCoords( arr, -1 );\n            data[ 3 ] = arr[ 0 ];\n            data[ 7 ] = arr[ 1 ];\n            data[ 11 ] = arr[ 2 ];\n\n        }\n\n        return new THREE.Matrix4().set(\n            data[0], data[1], data[2], data[3],\n            data[4], data[5], data[6], data[7],\n            data[8], data[9], data[10], data[11],\n            data[12], data[13], data[14], data[15]\n            );\n\n    }\n\n    function getConvertedIndex( index ) {\n\n        if ( index > -1 && index < 3 ) {\n\n            var members = [ 'X', 'Y', 'Z' ],\n                indices = { X: 0, Y: 1, Z: 2 };\n\n            index = getConvertedMember( members[ index ] );\n            index = indices[ index ];\n\n        }\n\n        return index;\n\n    }\n\n    function getConvertedMember( member ) {\n\n        if ( options.convertUpAxis ) {\n\n            switch ( member ) {\n\n                case 'X':\n\n                    switch ( upConversion ) {\n\n                        case 'XtoY':\n                        case 'XtoZ':\n                        case 'YtoX':\n\n                            member = 'Y';\n                            break;\n\n                        case 'ZtoX':\n\n                            member = 'Z';\n                            break;\n\n                    }\n\n                    break;\n\n                case 'Y':\n\n                    switch ( upConversion ) {\n\n                        case 'XtoY':\n                        case 'YtoX':\n                        case 'ZtoX':\n\n                            member = 'X';\n                            break;\n\n                        case 'XtoZ':\n                        case 'YtoZ':\n                        case 'ZtoY':\n\n                            member = 'Z';\n                            break;\n\n                    }\n\n                    break;\n\n                case 'Z':\n\n                    switch ( upConversion ) {\n\n                        case 'XtoZ':\n\n                            member = 'X';\n                            break;\n\n                        case 'YtoZ':\n                        case 'ZtoX':\n                        case 'ZtoY':\n\n                            member = 'Y';\n                            break;\n\n                    }\n\n                    break;\n\n            }\n\n        }\n\n        return member;\n\n    }\n\n    return {\n\n        load: load,\n        parse: parse,\n        setPreferredShading: setPreferredShading,\n        applySkin: applySkin,\n        geometries : geometries,\n        options: options\n\n    };\n\n};\n\nmodule.exports = ColladaLoader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi90aHJlZS1jb2xsYWRhLWxvYWRlci9pbmRleC5qcz9mMzk0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBUSFJFRSA9IHJlcXVpcmUoICd0aHJlZScgKTtcblxuLyoqXG4qIEBhdXRob3IgVGltIEtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vIC8gdGltIGF0IGZsb29ycGxhbm5lci5jb21cbiogQGF1dGhvciBUb255IFBhcmlzaSAvIGh0dHA6Ly93d3cudG9ueXBhcmlzaS5jb20vXG4qL1xuXG52YXIgQ29sbGFkYUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBDT0xMQURBID0gbnVsbDtcbiAgICB2YXIgc2NlbmUgPSBudWxsO1xuICAgIHZhciB2aXN1YWxTY2VuZTtcbiAgICB2YXIga2luZW1hdGljc01vZGVsO1xuXG4gICAgdmFyIHJlYWR5Q2FsbGJhY2tGdW5jID0gbnVsbDtcblxuICAgIHZhciBzb3VyY2VzID0ge307XG4gICAgdmFyIGltYWdlcyA9IHt9O1xuICAgIHZhciBhbmltYXRpb25zID0ge307XG4gICAgdmFyIGNvbnRyb2xsZXJzID0ge307XG4gICAgdmFyIGdlb21ldHJpZXMgPSB7fTtcbiAgICB2YXIgbWF0ZXJpYWxzID0ge307XG4gICAgdmFyIGVmZmVjdHMgPSB7fTtcbiAgICB2YXIgY2FtZXJhcyA9IHt9O1xuICAgIHZhciBsaWdodHMgPSB7fTtcblxuICAgIHZhciBhbmltRGF0YTtcbiAgICB2YXIga2luZW1hdGljcztcbiAgICB2YXIgdmlzdWFsU2NlbmVzO1xuICAgIHZhciBraW5lbWF0aWNzTW9kZWxzO1xuICAgIHZhciBiYXNlVXJsO1xuICAgIHZhciBtb3JwaHM7XG4gICAgdmFyIHNraW5zO1xuXG4gICAgdmFyIGZsaXBfdXYgPSB0cnVlO1xuICAgIHZhciBwcmVmZXJyZWRTaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAvLyBGb3JjZSBHZW9tZXRyeSB0byBhbHdheXMgYmUgY2VudGVyZWQgYXQgdGhlIGxvY2FsIG9yaWdpbiBvZiB0aGVcbiAgICAgICAgLy8gY29udGFpbmluZyBNZXNoLlxuICAgICAgICBjZW50ZXJHZW9tZXRyeTogZmFsc2UsXG5cbiAgICAgICAgLy8gQXhpcyBjb252ZXJzaW9uIGlzIGRvbmUgZm9yIGdlb21ldHJpZXMsIGFuaW1hdGlvbnMsIGFuZCBjb250cm9sbGVycy5cbiAgICAgICAgLy8gSWYgd2UgZXZlciBwdWxsIGNhbWVyYXMgb3IgbGlnaHRzIG91dCBvZiB0aGUgQ09MTEFEQSBmaWxlLCB0aGV5J2xsXG4gICAgICAgIC8vIG5lZWQgZXh0cmEgd29yay5cbiAgICAgICAgY29udmVydFVwQXhpczogZmFsc2UsXG5cbiAgICAgICAgc3ViZGl2aWRlRmFjZXM6IHRydWUsXG5cbiAgICAgICAgdXBBeGlzOiAnWScsXG5cbiAgICAgICAgLy8gRm9yIHJlZmxlY3RpdmUgb3IgcmVmcmFjdGl2ZSBtYXRlcmlhbHMgd2UnbGwgdXNlIHRoaXMgY3ViZW1hcFxuICAgICAgICBkZWZhdWx0RW52TWFwOiBudWxsXG5cbiAgICB9O1xuXG4gICAgdmFyIGNvbGxhZGFVbml0ID0gMS4wO1xuICAgIHZhciBjb2xsYWRhVXAgPSAnWSc7XG4gICAgdmFyIHVwQ29udmVyc2lvbiA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBsb2FkICggdXJsLCByZWFkeUNhbGxiYWNrLCBwcm9ncmVzc0NhbGxiYWNrLCBmYWlsQ2FsbGJhY2sgKSB7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKCBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudCApIHtcblxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmICggcmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggcmVxdWVzdC5zdGF0dXMgPT09IDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDIwMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZXF1ZXN0LnJlc3BvbnNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlDYWxsYmFja0Z1bmMgPSByZWFkeUNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlKCByZXF1ZXN0LnJlc3BvbnNlLCB1bmRlZmluZWQsIHVybCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmYWlsQ2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbENhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIFwiQ29sbGFkYUxvYWRlcjogRW1wdHkgb3Igbm9uLWV4aXN0aW5nIGZpbGUgKFwiICsgdXJsICsgXCIpXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHByb2dyZXNzQ2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LUxlbmd0aFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayggeyB0b3RhbDogbGVuZ3RoLCBsb2FkZWQ6IHJlcXVlc3QucmVzcG9uc2VUZXh0Lmxlbmd0aCB9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCBudWxsICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYWxlcnQoIFwiRG9uJ3Qga25vdyBob3cgdG8gcGFyc2UgWE1MIVwiICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoIHRleHQsIGNhbGxCYWNrLCB1cmwgKSB7XG5cbiAgICAgICAgQ09MTEFEQSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoIHRleHQsICd0ZXh0L3htbCcgKTtcbiAgICAgICAgY2FsbEJhY2sgPSBjYWxsQmFjayB8fCByZWFkeUNhbGxiYWNrRnVuYztcblxuICAgICAgICBpZiAoIHVybCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICBiYXNlVXJsID0gKCBwYXJ0cy5sZW5ndGggPCAxID8gJy4nIDogcGFydHMuam9pbiggJy8nICkgKSArICcvJztcblxuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VBc3NldCgpO1xuICAgICAgICBzZXRVcENvbnZlcnNpb24oKTtcbiAgICAgICAgaW1hZ2VzID0gcGFyc2VMaWIoIFwibGlicmFyeV9pbWFnZXMgaW1hZ2VcIiwgX0ltYWdlLCBcImltYWdlXCIgKTtcbiAgICAgICAgbWF0ZXJpYWxzID0gcGFyc2VMaWIoIFwibGlicmFyeV9tYXRlcmlhbHMgbWF0ZXJpYWxcIiwgTWF0ZXJpYWwsIFwibWF0ZXJpYWxcIiApO1xuICAgICAgICBlZmZlY3RzID0gcGFyc2VMaWIoIFwibGlicmFyeV9lZmZlY3RzIGVmZmVjdFwiLCBFZmZlY3QsIFwiZWZmZWN0XCIgKTtcbiAgICAgICAgZ2VvbWV0cmllcyA9IHBhcnNlTGliKCBcImxpYnJhcnlfZ2VvbWV0cmllcyBnZW9tZXRyeVwiLCBHZW9tZXRyeSwgXCJnZW9tZXRyeVwiICk7XG4gICAgICAgIGNhbWVyYXMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2NhbWVyYXMgY2FtZXJhXCIsIENhbWVyYSwgXCJjYW1lcmFcIiApO1xuICAgICAgICBsaWdodHMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2xpZ2h0cyBsaWdodFwiLCBMaWdodCwgXCJsaWdodFwiICk7XG4gICAgICAgIGNvbnRyb2xsZXJzID0gcGFyc2VMaWIoIFwibGlicmFyeV9jb250cm9sbGVycyBjb250cm9sbGVyXCIsIENvbnRyb2xsZXIsIFwiY29udHJvbGxlclwiICk7XG4gICAgICAgIGFuaW1hdGlvbnMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2FuaW1hdGlvbnMgYW5pbWF0aW9uXCIsIEFuaW1hdGlvbiwgXCJhbmltYXRpb25cIiApO1xuICAgICAgICB2aXN1YWxTY2VuZXMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X3Zpc3VhbF9zY2VuZXMgdmlzdWFsX3NjZW5lXCIsIFZpc3VhbFNjZW5lLCBcInZpc3VhbF9zY2VuZVwiICk7XG4gICAgICAgIGtpbmVtYXRpY3NNb2RlbHMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2tpbmVtYXRpY3NfbW9kZWxzIGtpbmVtYXRpY3NfbW9kZWxcIiwgS2luZW1hdGljc01vZGVsLCBcImtpbmVtYXRpY3NfbW9kZWxcIiApO1xuXG4gICAgICAgIG1vcnBocyA9IFtdO1xuICAgICAgICBza2lucyA9IFtdO1xuXG4gICAgICAgIHZpc3VhbFNjZW5lID0gcGFyc2VTY2VuZSgpO1xuICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZpc3VhbFNjZW5lLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgc2NlbmUuYWRkKCBjcmVhdGVTY2VuZUdyYXBoKCB2aXN1YWxTY2VuZS5ub2Rlc1sgaSBdICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5pdCBjb252ZXJzaW9uXG4gICAgICAgIHNjZW5lLnNjYWxlLm11bHRpcGx5U2NhbGFyKCBjb2xsYWRhVW5pdCApO1xuXG4gICAgICAgIGNyZWF0ZUFuaW1hdGlvbnMoKTtcblxuICAgICAgICBraW5lbWF0aWNzTW9kZWwgPSBwYXJzZUtpbmVtYXRpY3NNb2RlbCgpO1xuICAgICAgICBjcmVhdGVLaW5lbWF0aWNzKCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcblxuICAgICAgICAgICAgc2NlbmU6IHNjZW5lLFxuICAgICAgICAgICAgbW9ycGhzOiBtb3JwaHMsXG4gICAgICAgICAgICBza2luczogc2tpbnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBhbmltRGF0YSxcbiAgICAgICAgICAgIGtpbmVtYXRpY3M6IGtpbmVtYXRpY3MsXG4gICAgICAgICAgICBkYWU6IHtcbiAgICAgICAgICAgICAgICBpbWFnZXM6IGltYWdlcyxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHM6IG1hdGVyaWFscyxcbiAgICAgICAgICAgICAgICBjYW1lcmFzOiBjYW1lcmFzLFxuICAgICAgICAgICAgICAgIGxpZ2h0czogbGlnaHRzLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGVmZmVjdHMsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllczogZ2VvbWV0cmllcyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyczogY29udHJvbGxlcnMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICB2aXN1YWxTY2VuZXM6IHZpc3VhbFNjZW5lcyxcbiAgICAgICAgICAgICAgICB2aXN1YWxTY2VuZTogdmlzdWFsU2NlbmUsXG4gICAgICAgICAgICAgICAgc2NlbmU6IHZpc3VhbFNjZW5lLFxuICAgICAgICAgICAgICAgIGtpbmVtYXRpY3NNb2RlbHM6IGtpbmVtYXRpY3NNb2RlbHMsXG4gICAgICAgICAgICAgICAga2luZW1hdGljc01vZGVsOiBraW5lbWF0aWNzTW9kZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggY2FsbEJhY2sgKSB7XG5cbiAgICAgICAgICAgIGNhbGxCYWNrKCByZXN1bHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFByZWZlcnJlZFNoYWRpbmcgKCBzaGFkaW5nICkge1xuXG4gICAgICAgIHByZWZlcnJlZFNoYWRpbmcgPSBzaGFkaW5nO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VBc3NldCAoKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdhc3NldCcpO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XG5cbiAgICAgICAgaWYgKCBlbGVtZW50ICYmIGVsZW1lbnQuY2hpbGROb2RlcyApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5pdCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRlciA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ21ldGVyJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1ldGVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFkYVVuaXQgPSBwYXJzZUZsb2F0KCBtZXRlciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwX2F4aXMnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYWRhVXAgPSBjaGlsZC50ZXh0Q29udGVudC5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGliICggcSwgY2xhc3NTcGVjLCBwcmVmaXggKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKHEpO1xuXG4gICAgICAgIHZhciBsaWIgPSB7fTtcblxuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRzTGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGVsZW1lbnRzTGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2pdO1xuICAgICAgICAgICAgdmFyIGRhZUVsZW1lbnQgPSAoIG5ldyBjbGFzc1NwZWMoKSApLnBhcnNlKCBlbGVtZW50ICk7XG5cbiAgICAgICAgICAgIGlmICggIWRhZUVsZW1lbnQuaWQgfHwgZGFlRWxlbWVudC5pZC5sZW5ndGggPT09IDAgKSBkYWVFbGVtZW50LmlkID0gcHJlZml4ICsgKCBpICsrICk7XG4gICAgICAgICAgICBsaWJbIGRhZUVsZW1lbnQuaWQgXSA9IGRhZUVsZW1lbnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaWI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNjZW5lKCkge1xuXG4gICAgICAgIHZhciBzY2VuZUVsZW1lbnQgPSBDT0xMQURBLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjZW5lIGluc3RhbmNlX3Zpc3VhbF9zY2VuZScpWzBdO1xuXG4gICAgICAgIGlmICggc2NlbmVFbGVtZW50ICkge1xuXG4gICAgICAgICAgICB2YXIgdXJsID0gc2NlbmVFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuICAgICAgICAgICAgcmV0dXJuIHZpc3VhbFNjZW5lc1sgdXJsLmxlbmd0aCA+IDAgPyB1cmwgOiAndmlzdWFsX3NjZW5lMCcgXTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NNb2RlbCgpIHtcblxuICAgICAgICB2YXIga2luZW1hdGljc01vZGVsRWxlbWVudCA9IENPTExBREEucXVlcnlTZWxlY3RvckFsbCgnaW5zdGFuY2Vfa2luZW1hdGljc19tb2RlbCcpWzBdO1xuXG4gICAgICAgIGlmICgga2luZW1hdGljc01vZGVsRWxlbWVudCApIHtcblxuICAgICAgICAgICAgdmFyIHVybCA9IGtpbmVtYXRpY3NNb2RlbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndXJsJyApLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgICAgICAgcmV0dXJuIGtpbmVtYXRpY3NNb2RlbHNbIHVybC5sZW5ndGggPiAwID8gdXJsIDogJ2tpbmVtYXRpY3NfbW9kZWwwJyBdO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbnMoKSB7XG5cbiAgICAgICAgYW5pbURhdGEgPSBbXTtcblxuICAgICAgICAvLyBmaWxsIGluIHRoZSBrZXlzXG4gICAgICAgIHJlY3Vyc2VIaWVyYXJjaHkoIHNjZW5lICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlSGllcmFyY2h5KCBub2RlICkge1xuXG4gICAgICAgIHZhciBuID0gdmlzdWFsU2NlbmUuZ2V0Q2hpbGRCeUlkKCBub2RlLmNvbGxhZGFJZCwgdHJ1ZSApLFxuICAgICAgICAgICAgbmV3RGF0YSA9IG51bGw7XG5cbiAgICAgICAgaWYgKCBuICYmIG4ua2V5cyApIHtcblxuICAgICAgICAgICAgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmcHM6IDYwLFxuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogWyB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG4sXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IG4ua2V5cyxcbiAgICAgICAgICAgICAgICAgICAgc2lkczogbi5zaWRzXG4gICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuaW1hdGlvbl8nICsgbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYW5pbURhdGEucHVzaChuZXdEYXRhKTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG4ua2V5cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgICAgIG5ld0RhdGEubGVuZ3RoID0gTWF0aC5tYXgoIG5ld0RhdGEubGVuZ3RoLCBuLmtleXNbaV0udGltZSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBoaWVyYXJjaHk6IFsge1xuICAgICAgICAgICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2lkczogW11cbiAgICAgICAgICAgICAgICB9IF1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBkID0gcmVjdXJzZUhpZXJhcmNoeSggbm9kZS5jaGlsZHJlbltpXSApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZC5oaWVyYXJjaHkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICBuZXdEYXRhLmhpZXJhcmNoeS5wdXNoKCB7XG4gICAgICAgICAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzaWRzOiBbXVxuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNBbmltYXRpb25Cb3VuZHMgKCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IDEwMDAwMDA7XG4gICAgICAgIHZhciBlbmQgPSAtc3RhcnQ7XG4gICAgICAgIHZhciBmcmFtZXMgPSAwO1xuICAgICAgICB2YXIgSUQ7XG4gICAgICAgIGZvciAoIHZhciBpZCBpbiBhbmltYXRpb25zICkge1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1sgaWQgXTtcbiAgICAgICAgICAgIElEID0gSUQgfHwgYW5pbWF0aW9uLmlkO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uLnNhbXBsZXIubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZXIgPSBhbmltYXRpb24uc2FtcGxlclsgaSBdO1xuXG4gICAgICAgICAgICAgICAgc2FtcGxlci5jcmVhdGUoKTtcblxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oIHN0YXJ0LCBzYW1wbGVyLnN0YXJ0VGltZSApO1xuICAgICAgICAgICAgICAgIGVuZCA9IE1hdGgubWF4KCBlbmQsIHNhbXBsZXIuZW5kVGltZSApO1xuICAgICAgICAgICAgICAgIGZyYW1lcyA9IE1hdGgubWF4KCBmcmFtZXMsIHNhbXBsZXIuaW5wdXQubGVuZ3RoICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6c3RhcnQsIGVuZDplbmQsIGZyYW1lczpmcmFtZXMsSUQ6SUQgfTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1vcnBoICggZ2VvbWV0cnksIGN0cmwgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoQ3RybCA9IGN0cmwgaW5zdGFuY2VvZiBJbnN0YW5jZUNvbnRyb2xsZXIgPyBjb250cm9sbGVyc1sgY3RybC51cmwgXSA6IGN0cmw7XG5cbiAgICAgICAgaWYgKCAhbW9ycGhDdHJsIHx8ICFtb3JwaEN0cmwubW9ycGggKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgbW9ycGggY29udHJvbGxlciFcIik7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3JwaCA9IG1vcnBoQ3RybC5tb3JwaDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaC50YXJnZXRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIHRhcmdldF9pZCA9IG1vcnBoLnRhcmdldHNbIGkgXTtcbiAgICAgICAgICAgIHZhciBkYWVHZW9tZXRyeSA9IGdlb21ldHJpZXNbIHRhcmdldF9pZCBdO1xuXG4gICAgICAgICAgICBpZiAoICFkYWVHZW9tZXRyeS5tZXNoIHx8XG4gICAgICAgICAgICAgICAgICFkYWVHZW9tZXRyeS5tZXNoLnByaW1pdGl2ZXMgfHxcbiAgICAgICAgICAgICAgICAgIWRhZUdlb21ldHJ5Lm1lc2gucHJpbWl0aXZlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZGFlR2VvbWV0cnkubWVzaC5wcmltaXRpdmVzWyAwIF0uZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgIGlmICggdGFyZ2V0LnZlcnRpY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLnB1c2goIHsgbmFtZTogXCJ0YXJnZXRfMVwiLCB2ZXJ0aWNlczogdGFyZ2V0LnZlcnRpY2VzIH0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHMucHVzaCggeyBuYW1lOiBcInRhcmdldF9aXCIsIHZlcnRpY2VzOiBnZW9tZXRyeS52ZXJ0aWNlcyB9ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTa2luICggZ2VvbWV0cnksIGN0cmwsIGFwcGx5QmluZFNoYXBlICkge1xuXG4gICAgICAgIHZhciBza2luQ3RybCA9IGNvbnRyb2xsZXJzWyBjdHJsLnVybCBdO1xuXG4gICAgICAgIGlmICggIXNraW5DdHJsIHx8ICFza2luQ3RybC5za2luICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyggXCJjb3VsZCBub3QgZmluZCBza2luIGNvbnRyb2xsZXIhXCIgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhY3RybC5za2VsZXRvbiB8fCAhY3RybC5za2VsZXRvbi5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHRoZSBza2VsZXRvbiBmb3IgdGhlIHNraW4hXCIgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNraW4gPSBza2luQ3RybC5za2luO1xuICAgICAgICB2YXIgc2tlbGV0b24gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIGN0cmwuc2tlbGV0b25bIDAgXSApO1xuICAgICAgICB2YXIgaGllcmFyY2h5ID0gW107XG5cbiAgICAgICAgYXBwbHlCaW5kU2hhcGUgPSBhcHBseUJpbmRTaGFwZSAhPT0gdW5kZWZpbmVkID8gYXBwbHlCaW5kU2hhcGUgOiB0cnVlO1xuXG4gICAgICAgIHZhciBib25lcyA9IFtdO1xuICAgICAgICBnZW9tZXRyeS5za2luV2VpZ2h0cyA9IFtdO1xuICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8vY3JlYXRlQm9uZXMoIGdlb21ldHJ5LmJvbmVzLCBza2luLCBoaWVyYXJjaHksIHNrZWxldG9uLCBudWxsLCAtMSApO1xuICAgICAgICAvL2NyZWF0ZVdlaWdodHMoIHNraW4sIGdlb21ldHJ5LmJvbmVzLCBnZW9tZXRyeS5za2luSW5kaWNlcywgZ2VvbWV0cnkuc2tpbldlaWdodHMgKTtcblxuICAgICAgICAvKlxuICAgICAgICBnZW9tZXRyeS5hbmltYXRpb24gPSB7XG4gICAgICAgICAgICBuYW1lOiAndGFrZV8wMDEnLFxuICAgICAgICAgICAgZnBzOiAzMCxcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIEpJVDogdHJ1ZSxcbiAgICAgICAgICAgIGhpZXJhcmNoeTogaGllcmFyY2h5XG4gICAgICAgIH07XG4gICAgICAgICovXG5cbiAgICAgICAgaWYgKCBhcHBseUJpbmRTaGFwZSApIHtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbIGkgXS5hcHBseU1hdHJpeDQoIHNraW4uYmluZFNoYXBlTWF0cml4ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cFNrZWxldG9uICggbm9kZSwgYm9uZXMsIGZyYW1lLCBwYXJlbnQgKSB7XG5cbiAgICAgICAgbm9kZS53b3JsZCA9IG5vZGUud29ybGQgfHwgbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgbm9kZS5sb2NhbHdvcmxkID0gbm9kZS5sb2NhbHdvcmxkIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICAgIG5vZGUud29ybGQuY29weSggbm9kZS5tYXRyaXggKTtcbiAgICAgICAgbm9kZS5sb2NhbHdvcmxkLmNvcHkoIG5vZGUubWF0cml4ICk7XG5cbiAgICAgICAgaWYgKCBub2RlLmNoYW5uZWxzICYmIG5vZGUuY2hhbm5lbHMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbIDAgXTtcbiAgICAgICAgICAgIHZhciBtID0gY2hhbm5lbC5zYW1wbGVyLm91dHB1dFsgZnJhbWUgXTtcblxuICAgICAgICAgICAgaWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApIHtcblxuICAgICAgICAgICAgICAgIG5vZGUud29ybGQuY29weSggbSApO1xuICAgICAgICAgICAgICAgIG5vZGUubG9jYWx3b3JsZC5jb3B5KG0pO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXRyaXguY29weShtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG5cbiAgICAgICAgICAgIG5vZGUud29ybGQubXVsdGlwbHlNYXRyaWNlcyggcGFyZW50LCBub2RlLndvcmxkICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGJvbmVzLnB1c2goIG5vZGUgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgc2V0dXBTa2VsZXRvbiggbm9kZS5ub2Rlc1sgaSBdLCBib25lcywgZnJhbWUsIG5vZGUud29ybGQgKTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cFNraW5uaW5nTWF0cmljZXMgKCBib25lcywgc2tpbiApIHtcblxuICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBkdW1iLi4uXG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgYm9uZSA9IGJvbmVzWyBpIF07XG4gICAgICAgICAgICB2YXIgZm91bmQgPSAtMTtcblxuICAgICAgICAgICAgaWYgKCBib25lLnR5cGUgIT0gJ0pPSU5UJyApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBza2luLmpvaW50cy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGJvbmUuc2lkID09PSBza2luLmpvaW50c1sgaiBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBmb3VuZCA+PSAwICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGludiA9IHNraW4uaW52QmluZE1hdHJpY2VzWyBmb3VuZCBdO1xuXG4gICAgICAgICAgICAgICAgYm9uZS5pbnZCaW5kTWF0cml4ID0gaW52O1xuICAgICAgICAgICAgICAgIGJvbmUuc2tpbm5pbmdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICAgICAgICAgIGJvbmUuc2tpbm5pbmdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhib25lLndvcmxkLCBpbnYpOyAvLyAoSUJNaSAqIEpNaSlcbiAgICAgICAgICAgICAgICBib25lLmFuaW1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgICAgICAgICBib25lLmFuaW1hdHJpeC5jb3B5KGJvbmUubG9jYWx3b3JsZCk7XG4gICAgICAgICAgICAgICAgYm9uZS53ZWlnaHRzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBza2luLndlaWdodHMubGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2tpbi53ZWlnaHRzWyBqIF0ubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHNraW4ud2VpZ2h0c1sgaiBdWyBrIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdy5qb2ludCA9PT0gZm91bmQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lLndlaWdodHMucHVzaCggdyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIkNvbGxhZGFMb2FkZXI6IENvdWxkIG5vdCBmaW5kIGpvaW50ICdcIiArIGJvbmUuc2lkICsgXCInLlwiICk7XG5cbiAgICAgICAgICAgICAgICBib25lLnNraW5uaW5nTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgICAgICAgICBib25lLndlaWdodHMgPSBbXTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvL1dhbGsgdGhlIENvbGxhZGEgdHJlZSBhbmQgZmxhdHRlbiB0aGUgYm9uZXMgaW50byBhIGxpc3QsIGV4dHJhY3QgdGhlIHBvc2l0aW9uLCBxdWF0IGFuZCBzY2FsZSBmcm9tIHRoZSBtYXRyaXhcbiAgICBmdW5jdGlvbiBmbGF0dGVuU2tlbGV0b24oc2tlbGV0b24pIHtcblxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uKHBhcmVudGlkLCBub2RlLCBsaXN0KSB7XG5cbiAgICAgICAgICAgIHZhciBib25lID0ge307XG4gICAgICAgICAgICBib25lLm5hbWUgPSBub2RlLnNpZDtcbiAgICAgICAgICAgIGJvbmUucGFyZW50ID0gcGFyZW50aWQ7XG4gICAgICAgICAgICBib25lLm1hdHJpeCA9IG5vZGUubWF0cml4O1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksbmV3IFRIUkVFLlF1YXRlcm5pb24oKSxuZXcgVEhSRUUuVmVjdG9yMygpIF07XG4gICAgICAgICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSk7XG5cbiAgICAgICAgICAgIGJvbmUucG9zID0gWyBkYXRhWzBdLngsZGF0YVswXS55LGRhdGFbMF0ueiBdO1xuXG4gICAgICAgICAgICBib25lLnNjbCA9IFsgZGF0YVsyXS54LGRhdGFbMl0ueSxkYXRhWzJdLnogXTtcbiAgICAgICAgICAgIGJvbmUucm90cSA9IFsgZGF0YVsxXS54LGRhdGFbMV0ueSxkYXRhWzFdLnosZGF0YVsxXS53IF07XG4gICAgICAgICAgICBsaXN0LnB1c2goYm9uZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5ub2Rlcykge1xuXG4gICAgICAgICAgICAgICAgd2Fsayhub2RlLnNpZCwgbm9kZS5ub2Rlc1tpXSwgbGlzdCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIHdhbGsoLTEsIHNrZWxldG9uLCBsaXN0KTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG5cbiAgICB9XG5cbiAgICAvL01vdmUgdGhlIHZlcnRpY2VzIGludG8gdGhlIHBvc2UgdGhhdCBpcyBwcm9wZXIgZm9yIHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gc2tpblRvQmluZFBvc2UoZ2VvbWV0cnksc2tlbGV0b24sc2tpbkNvbnRyb2xsZXIpIHtcblxuICAgICAgICB2YXIgYm9uZXMgPSBbXTtcbiAgICAgICAgc2V0dXBTa2VsZXRvbiggc2tlbGV0b24sIGJvbmVzLCAtMSApO1xuICAgICAgICBzZXR1cFNraW5uaW5nTWF0cmljZXMoIGJvbmVzLCBza2luQ29udHJvbGxlci5za2luICk7XG4gICAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmFyIHNraW5uZWQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSArKykge1xuXG4gICAgICAgICAgICBza2lubmVkLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGJvbmVzWyBpIF0udHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGJvbmVzWyBpIF0ud2VpZ2h0cy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdyA9IGJvbmVzWyBpIF0ud2VpZ2h0c1sgaiBdO1xuICAgICAgICAgICAgICAgIHZhciB2aWR4ID0gdy5pbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdy53ZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgbyA9IGdlb21ldHJ5LnZlcnRpY2VzW3ZpZHhdO1xuICAgICAgICAgICAgICAgIHZhciBzID0gc2tpbm5lZFt2aWR4XTtcblxuICAgICAgICAgICAgICAgIHYueCA9IG8ueDtcbiAgICAgICAgICAgICAgICB2LnkgPSBvLnk7XG4gICAgICAgICAgICAgICAgdi56ID0gby56O1xuXG4gICAgICAgICAgICAgICAgdi5hcHBseU1hdHJpeDQoIGJvbmVzW2ldLnNraW5uaW5nTWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgICBzLnggKz0gKHYueCAqIHdlaWdodCk7XG4gICAgICAgICAgICAgICAgcy55ICs9ICh2LnkgKiB3ZWlnaHQpO1xuICAgICAgICAgICAgICAgIHMueiArPSAodi56ICogd2VpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7IGkgKyspIHtcblxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNbaV0gPSBza2lubmVkW2ldO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5U2tpbiAoIGdlb21ldHJ5LCBpbnN0YW5jZUN0cmwsIGZyYW1lICkge1xuXG4gICAgICAgIHZhciBza2luQ29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbnN0YW5jZUN0cmwudXJsIF07XG5cbiAgICAgICAgZnJhbWUgPSBmcmFtZSAhPT0gdW5kZWZpbmVkID8gZnJhbWUgOiA0MDtcblxuICAgICAgICBpZiAoICFza2luQ29udHJvbGxlciB8fCAhc2tpbkNvbnRyb2xsZXIuc2tpbiApIHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBDb3VsZCBub3QgZmluZCBza2luIGNvbnRyb2xsZXIuJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICFpbnN0YW5jZUN0cmwuc2tlbGV0b24gfHwgIWluc3RhbmNlQ3RybC5za2VsZXRvbi5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgdGhlIHNrZWxldG9uIGZvciB0aGUgc2tpbi4gJyApO1xuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pbWF0aW9uQm91bmRzID0gY2FsY0FuaW1hdGlvbkJvdW5kcygpO1xuICAgICAgICB2YXIgc2tlbGV0b24gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIGluc3RhbmNlQ3RybC5za2VsZXRvblswXSwgdHJ1ZSApIHx8IHZpc3VhbFNjZW5lLmdldENoaWxkQnlTaWQoIGluc3RhbmNlQ3RybC5za2VsZXRvblswXSwgdHJ1ZSApO1xuXG4gICAgICAgIC8vZmxhdHRlbiB0aGUgc2tlbGV0b24gaW50byBhIGxpc3Qgb2YgYm9uZXNcbiAgICAgICAgdmFyIGJvbmVsaXN0ID0gZmxhdHRlblNrZWxldG9uKHNrZWxldG9uKTtcbiAgICAgICAgdmFyIGpvaW50cyA9IHNraW5Db250cm9sbGVyLnNraW4uam9pbnRzO1xuXG4gICAgICAgIC8vc29ydCB0aGF0IGxpc3Qgc28gdGhhdCB0aGUgb3JkZXIgcmVmbGVjdHMgdGhlIG9yZGVyIGluIHRoZSBqb2ludCBsaXN0XG4gICAgICAgIHZhciBzb3J0ZWRib25lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpvaW50cy5sZW5ndGg7IGkgKyspIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBib25lbGlzdC5sZW5ndGg7IGogKyspIHtcblxuICAgICAgICAgICAgICAgIGlmIChib25lbGlzdFtqXS5uYW1lID09PSBqb2ludHNbaV0pIHtcblxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRib25lc1tpXSA9IGJvbmVsaXN0W2pdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaG9vayB1cCB0aGUgcGFyZW50cyBieSBpbmRleCBpbnN0ZWFkIG9mIG5hbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRib25lcy5sZW5ndGg7IGkgKyspIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzb3J0ZWRib25lcy5sZW5ndGg7IGogKyspIHtcblxuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRib25lc1tpXS5wYXJlbnQgPT09IHNvcnRlZGJvbmVzW2pdLm5hbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRib25lc1tpXS5wYXJlbnQgPSBqO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGksIGosIHcsIHZpZHgsIHdlaWdodDtcbiAgICAgICAgdmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBvLCBzO1xuXG4gICAgICAgIC8vIG1vdmUgdmVydGljZXMgdG8gYmluZCBzaGFwZVxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzW2ldLmFwcGx5TWF0cml4NCggc2tpbkNvbnRyb2xsZXIuc2tpbi5iaW5kU2hhcGVNYXRyaXggKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBza2luSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgc2tpbldlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIHdlaWdodHMgPSBza2luQ29udHJvbGxlci5za2luLndlaWdodHM7XG5cbiAgICAgICAgLy8gaG9vayB1cCB0aGUgc2tpbiB3ZWlnaHRzXG4gICAgICAgIC8vIFRPRE8gLSB0aGlzIG1pZ2h0IGJlIGEgZ29vZCBwbGFjZSB0byBjaG9vc2UgZ3JlYXRlc3QgNCB3ZWlnaHRzXG4gICAgICAgIGZvciAoIHZhciBpID0wOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmRpY2llcyA9IG5ldyBUSFJFRS5WZWN0b3I0KHdlaWdodHNbaV1bMF0gPyB3ZWlnaHRzW2ldWzBdLmpvaW50IDogMCx3ZWlnaHRzW2ldWzFdID8gd2VpZ2h0c1tpXVsxXS5qb2ludCA6IDAsd2VpZ2h0c1tpXVsyXSA/IHdlaWdodHNbaV1bMl0uam9pbnQgOiAwLHdlaWdodHNbaV1bM10gPyB3ZWlnaHRzW2ldWzNdLmpvaW50IDogMCk7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjQod2VpZ2h0c1tpXVswXSA/IHdlaWdodHNbaV1bMF0ud2VpZ2h0IDogMCx3ZWlnaHRzW2ldWzFdID8gd2VpZ2h0c1tpXVsxXS53ZWlnaHQgOiAwLHdlaWdodHNbaV1bMl0gPyB3ZWlnaHRzW2ldWzJdLndlaWdodCA6IDAsd2VpZ2h0c1tpXVszXSA/IHdlaWdodHNbaV1bM10ud2VpZ2h0IDogMCk7XG5cbiAgICAgICAgICAgIHNraW5JbmRpY2VzLnB1c2goaW5kaWNpZXMpO1xuICAgICAgICAgICAgc2tpbldlaWdodHMucHVzaCh3ZWlnaHQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5za2luSW5kaWNlcyA9IHNraW5JbmRpY2VzO1xuICAgICAgICBnZW9tZXRyeS5za2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzO1xuICAgICAgICBnZW9tZXRyeS5ib25lcyA9IHNvcnRlZGJvbmVzO1xuICAgICAgICAvLyBwcm9jZXNzIGFuaW1hdGlvbiwgb3Igc2ltcGx5IHBvc2UgdGhlIHJpZyBpZiBubyBhbmltYXRpb25cblxuICAgICAgICAvL2NyZWF0ZSBhbiBhbmltYXRpb24gZm9yIHRoZSBhbmltYXRlZCBib25lc1xuICAgICAgICAvL05PVEU6IHRoaXMgaGFzIG5vIGVmZmVjdCB3aGVuIHVzaW5nIG1vcnBodGFyZ2V0c1xuICAgICAgICB2YXIgYW5pbWF0aW9uZGF0YSA9IHsgXCJuYW1lXCI6YW5pbWF0aW9uQm91bmRzLklELFwiZnBzXCI6MzAsXCJsZW5ndGhcIjphbmltYXRpb25Cb3VuZHMuZnJhbWVzIC8gMzAsXCJoaWVyYXJjaHlcIjpbXSB9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc29ydGVkYm9uZXMubGVuZ3RoOyBqICsrKSB7XG5cbiAgICAgICAgICAgIGFuaW1hdGlvbmRhdGEuaGllcmFyY2h5LnB1c2goeyBwYXJlbnQ6c29ydGVkYm9uZXNbal0ucGFyZW50LCBuYW1lOnNvcnRlZGJvbmVzW2pdLm5hbWUsIGtleXM6W10gfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjonLCBhbmltYXRpb25Cb3VuZHMuSUQgKyAnIGhhcyAnICsgc29ydGVkYm9uZXMubGVuZ3RoICsgJyBib25lcy4nICk7XG5cblxuXG4gICAgICAgIHNraW5Ub0JpbmRQb3NlKGdlb21ldHJ5LCBza2VsZXRvbiwgc2tpbkNvbnRyb2xsZXIpO1xuXG5cbiAgICAgICAgZm9yICggZnJhbWUgPSAwOyBmcmFtZSA8IGFuaW1hdGlvbkJvdW5kcy5mcmFtZXM7IGZyYW1lICsrICkge1xuXG4gICAgICAgICAgICB2YXIgYm9uZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBza2lubmVkID0gW107XG4gICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBmcmFtZSBhbmQgc2V0dXAgdGhlIHJpZyB3aXRoIGEgZnJlc2hcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSwgcG9zc2libHkgZnJvbSB0aGUgYm9uZSdzIGFuaW1hdGlvbiBjaGFubmVsKHMpXG5cbiAgICAgICAgICAgIHNldHVwU2tlbGV0b24oIHNrZWxldG9uLCBib25lcywgZnJhbWUgKTtcbiAgICAgICAgICAgIHNldHVwU2tpbm5pbmdNYXRyaWNlcyggYm9uZXMsIHNraW5Db250cm9sbGVyLnNraW4gKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKyspIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5pbWF0aW9uZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBqICsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbmRhdGEuaGllcmFyY2h5W2pdLm5hbWUgPT09IGJvbmVzW2ldLnNpZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkudGltZSA9IChmcmFtZSAvIDMwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5tYXRyaXggPSBib25lc1tpXS5hbmltYXRyaXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib25lc1tpXS5tYXRyaXggPSBrZXkubWF0cml4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSxuZXcgVEhSRUUuUXVhdGVybmlvbigpLG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5tYXRyaXguZGVjb21wb3NlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkucG9zID0gWyBkYXRhWzBdLngsZGF0YVswXS55LGRhdGFbMF0ueiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuc2NsID0gWyBkYXRhWzJdLngsZGF0YVsyXS55LGRhdGFbMl0ueiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnJvdCA9IGRhdGFbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbmRhdGEuaGllcmFyY2h5W2pdLmtleXMucHVzaChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZW9tZXRyeS5hbmltYXRpb24gPSBhbmltYXRpb25kYXRhO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUtpbmVtYXRpY3MoKSB7XG5cbiAgICAgICAgaWYgKCBraW5lbWF0aWNzTW9kZWwgJiYga2luZW1hdGljc01vZGVsLmpvaW50cy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICBraW5lbWF0aWNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGpvaW50TWFwID0ge307XG5cbiAgICAgICAgdmFyIF9hZGRUb01hcCA9IGZ1bmN0aW9uKCBqb2ludEluZGV4LCBwYXJlbnRWaXN1YWxFbGVtZW50ICkge1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50VmlzdWFsRWxlbWVudElkID0gcGFyZW50VmlzdWFsRWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcbiAgICAgICAgICAgIHZhciBjb2xsYWRhTm9kZSA9IHZpc3VhbFNjZW5lLmdldENoaWxkQnlJZCggcGFyZW50VmlzdWFsRWxlbWVudElkLCB0cnVlICk7XG4gICAgICAgICAgICB2YXIgam9pbnQgPSBraW5lbWF0aWNzTW9kZWwuam9pbnRzWyBqb2ludEluZGV4IF07XG5cbiAgICAgICAgICAgIHNjZW5lLnRyYXZlcnNlKGZ1bmN0aW9uKCBub2RlICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBub2RlLmNvbGxhZGFJZCA9PSBwYXJlbnRWaXN1YWxFbGVtZW50SWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgam9pbnRNYXBbIGpvaW50SW5kZXggXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiBjb2xsYWRhTm9kZS50cmFuc2Zvcm1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQ6IGpvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGpvaW50Lnplcm9Qb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGtpbmVtYXRpY3MgPSB7XG5cbiAgICAgICAgICAgIGpvaW50czoga2luZW1hdGljc01vZGVsICYmIGtpbmVtYXRpY3NNb2RlbC5qb2ludHMsXG5cbiAgICAgICAgICAgIGdldEpvaW50VmFsdWU6IGZ1bmN0aW9uKCBqb2ludEluZGV4ICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGpvaW50RGF0YSA9IGpvaW50TWFwWyBqb2ludEluZGV4IF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGpvaW50RGF0YSApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gam9pbnREYXRhLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ2dldEpvaW50VmFsdWU6IGpvaW50ICcgKyBqb2ludEluZGV4ICsgJyBkb2VzblxcJ3QgZXhpc3QnICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEpvaW50VmFsdWU6IGZ1bmN0aW9uKCBqb2ludEluZGV4LCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgIHZhciBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqb2ludERhdGEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW50ID0gam9pbnREYXRhLmpvaW50O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPiBqb2ludC5saW1pdHMubWF4IHx8IHZhbHVlIDwgam9pbnQubGltaXRzLm1pbiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coICdzZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgdmFsdWUgJyArIHZhbHVlICsgJyBvdXRzaWRlIG9mIGxpbWl0cyAobWluOiAnICsgam9pbnQubGltaXRzLm1pbiArICcsIG1heDogJyArIGpvaW50LmxpbWl0cy5tYXggKyAnKScgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBqb2ludC5zdGF0aWMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnc2V0Sm9pbnRWYWx1ZTogam9pbnQgJyArIGpvaW50SW5kZXggKyAnIGlzIHN0YXRpYycgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZWVqc05vZGUgPSBqb2ludERhdGEubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gam9pbnQuYXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gam9pbnREYXRhLnRyYW5zZm9ybXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZGEgZ2hldHRvIGpvaW50IGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHJhbnNmb3JtLnNpZCAmJiB0cmFuc2Zvcm0uc2lkLmluZGV4T2YoICdqb2ludCcgKyBqb2ludEluZGV4ICkgIT09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGFjdHVhbCBqb2ludCB2YWx1ZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIGpvaW50LnR5cGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Jldm9sdXRlJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVJvdGF0aW9uQXhpcyggYXhpcywgVEhSRUUuTWF0aC5kZWdUb1JhZCh2YWx1ZSkgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmlzbWF0aWMnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlVHJhbnNsYXRpb24oYXhpcy54ICogdmFsdWUsIGF4aXMueSAqIHZhbHVlLCBheGlzLnogKiB2YWx1ZSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdzZXRKb2ludFZhbHVlOiB1bmtub3duIGpvaW50IHR5cGU6ICcgKyBqb2ludC50eXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIHRyYW5zZm9ybS50eXBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5KCB0cmFuc2Zvcm0ub2JqICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVRyYW5zbGF0aW9uKCB0cmFuc2Zvcm0ub2JqLngsIHRyYW5zZm9ybS5vYmoueSwgdHJhbnNmb3JtLm9iai56ICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlUm90YXRpb25BeGlzKCB0cmFuc2Zvcm0ub2JqLCB0cmFuc2Zvcm0uYW5nbGUgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgdGhlIG1hdHJpeCB0byB0aGUgdGhyZWVqcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHNGbG9hdDMyQXJyID0gbWF0cml4LmVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGVsZW1lbnRzRmxvYXQzMkFyciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHNSb3dNYWpvciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgMCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzWyA0IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbIDggXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgMTIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzWyA1IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbIDkgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgMTMgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgMiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzWyA2IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbIDEwIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbIDE0IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbIDMgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1sgNyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzWyAxMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzWyAxNSBdXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlZWpzTm9kZS5tYXRyaXguc2V0LmFwcGx5KCB0aHJlZWpzTm9kZS5tYXRyaXgsIGVsZW1lbnRzUm93TWFqb3IgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocmVlanNOb2RlLm1hdHJpeC5kZWNvbXBvc2UoIHRocmVlanNOb2RlLnBvc2l0aW9uLCB0aHJlZWpzTm9kZS5xdWF0ZXJuaW9uLCB0aHJlZWpzTm9kZS5zY2FsZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnc2V0Sm9pbnRWYWx1ZTogam9pbnQgJyArIGpvaW50SW5kZXggKyAnIGRvZXNuXFwndCBleGlzdCcgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBDT0xMQURBLnF1ZXJ5U2VsZWN0b3IoJ3NjZW5lIGluc3RhbmNlX2tpbmVtYXRpY3Nfc2NlbmUnKTtcblxuICAgICAgICBpZiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmluZF9qb2ludF9heGlzJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc3VhbFRhcmdldCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKS5zcGxpdCggJy8nICkucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGNoaWxkLnF1ZXJ5U2VsZWN0b3IoJ2F4aXMgcGFyYW0nKS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqb2ludEluZGV4ID0gcGFyc2VJbnQoIGF4aXMuc3BsaXQoICdqb2ludCcgKS5wb3AoKS5zcGxpdCggJy4nIClbMF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXN1YWxUYXJnZXRFbGVtZW50ID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yKCAnW3NpZD1cIicgKyB2aXN1YWxUYXJnZXQgKyAnXCJdJyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZpc3VhbFRhcmdldEVsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxUYXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkZFRvTWFwKGpvaW50SW5kZXgsIHBhcmVudFZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTY2VuZUdyYXBoICggbm9kZSwgcGFyZW50ICkge1xuXG4gICAgICAgIHZhciBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICAgICAgdmFyIHNraW5uZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNraW5Db250cm9sbGVyO1xuICAgICAgICB2YXIgbW9ycGhDb250cm9sbGVyO1xuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICAvLyBGSVhNRTogY29udHJvbGxlcnNcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGUuY29udHJvbGxlcnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBub2RlLmNvbnRyb2xsZXJzWyBpIF0udXJsIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNvbnRyb2xsZXIudHlwZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3NraW4nOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cmllc1sgY29udHJvbGxlci5za2luLnNvdXJjZSBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdF9nZW9tID0gbmV3IEluc3RhbmNlR2VvbWV0cnkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdF9nZW9tLnVybCA9IGNvbnRyb2xsZXIuc2tpbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0X2dlb20uaW5zdGFuY2VfbWF0ZXJpYWwgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF0uaW5zdGFuY2VfbWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZ2VvbWV0cmllcy5wdXNoKCBpbnN0X2dlb20gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraW5uZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbkNvbnRyb2xsZXIgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udHJvbGxlcnNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXJnaDogY29udHJvbGxlciBjYW4gYmUgY2hhaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBtb3N0IGJhc2ljIGNhc2UuLi5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZCA9IGNvbnRyb2xsZXJzWyBjb250cm9sbGVyLnNraW4uc291cmNlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaENvbnRyb2xsZXIgPSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgIC8vXHRza2luQ29udHJvbGxlciA9IG5vZGUuY29udHJvbGxlcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2Vjb25kLm1vcnBoICYmIGdlb21ldHJpZXNbIHNlY29uZC5tb3JwaC5zb3VyY2UgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0X2dlb20gPSBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdF9nZW9tLnVybCA9IHNlY29uZC5tb3JwaC5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdF9nZW9tLmluc3RhbmNlX21hdGVyaWFsID0gbm9kZS5jb250cm9sbGVyc1sgaSBdLmluc3RhbmNlX21hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5nZW9tZXRyaWVzLnB1c2goIGluc3RfZ2VvbSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbW9ycGgnOlxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZ2VvbWV0cmllc1sgY29udHJvbGxlci5tb3JwaC5zb3VyY2UgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RfZ2VvbSA9IG5ldyBJbnN0YW5jZUdlb21ldHJ5KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RfZ2VvbS51cmwgPSBjb250cm9sbGVyLm1vcnBoLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RfZ2VvbS5pbnN0YW5jZV9tYXRlcmlhbCA9IG5vZGUuY29udHJvbGxlcnNbIGkgXS5pbnN0YW5jZV9tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5nZW9tZXRyaWVzLnB1c2goIGluc3RfZ2VvbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhDb250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ0NvbGxhZGFMb2FkZXI6IE1vcnBoLWNvbnRyb2xsZXIgcGFydGlhbGx5IHN1cHBvcnRlZC4nICk7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZW9tZXRyaWVzXG5cbiAgICAgICAgdmFyIGRvdWJsZV9zaWRlZF9tYXRlcmlhbHMgPSB7fTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGUuZ2VvbWV0cmllcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZV9nZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZV9tYXRlcmlhbHMgPSBpbnN0YW5jZV9nZW9tZXRyeS5pbnN0YW5jZV9tYXRlcmlhbDtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGluc3RhbmNlX2dlb21ldHJ5LnVybCBdO1xuICAgICAgICAgICAgdmFyIHVzZWRfbWF0ZXJpYWxzID0ge307XG4gICAgICAgICAgICB2YXIgdXNlZF9tYXRlcmlhbHNfYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciBudW1fbWF0ZXJpYWxzID0gMDtcbiAgICAgICAgICAgIHZhciBmaXJzdF9tYXRlcmlhbDtcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggIWdlb21ldHJ5Lm1lc2ggfHwgIWdlb21ldHJ5Lm1lc2gucHJpbWl0aXZlcyApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBvYmoubmFtZS5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLm5hbWUgPSBnZW9tZXRyeS5pZDtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdXNlZCBmeCBmb3IgdGhpcyBnZW9tZXRyeS1pbnN0YW5jZVxuXG4gICAgICAgICAgICAgICAgaWYgKCBpbnN0YW5jZV9tYXRlcmlhbHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VfbWF0ZXJpYWwgPSBpbnN0YW5jZV9tYXRlcmlhbHNbIGogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXQgPSBtYXRlcmlhbHNbIGluc3RhbmNlX21hdGVyaWFsLnRhcmdldCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVmZmVjdF9pZCA9IG1hdC5pbnN0YW5jZV9lZmZlY3QudXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYWRlciA9IGVmZmVjdHNbIGVmZmVjdF9pZCBdLnNoYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbDNqcyA9IHNoYWRlci5tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tZXRyeS5kb3VibGVTaWRlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISggaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIGluIGRvdWJsZV9zaWRlZF9tYXRlcmlhbHMgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2NvcGllZF9tYXRlcmlhbCA9IG1hdGVyaWFsM2pzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb3BpZWRfbWF0ZXJpYWwuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZV9zaWRlZF9tYXRlcmlhbHNbIGluc3RhbmNlX21hdGVyaWFsLnN5bWJvbCBdID0gX2NvcGllZF9tYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsM2pzID0gZG91YmxlX3NpZGVkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwzanMub3BhY2l0eSA9ICFtYXRlcmlhbDNqcy5vcGFjaXR5ID8gMSA6IG1hdGVyaWFsM2pzLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF0gPSBudW1fbWF0ZXJpYWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZF9tYXRlcmlhbHNfYXJyYXkucHVzaCggbWF0ZXJpYWwzanMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X21hdGVyaWFsID0gbWF0ZXJpYWwzanM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9tYXRlcmlhbC5uYW1lID0gbWF0Lm5hbWUgPT09IG51bGwgfHwgbWF0Lm5hbWUgPT09ICcnID8gbWF0LmlkIDogbWF0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1fbWF0ZXJpYWxzICsrO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtZXNoO1xuICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IGZpcnN0X21hdGVyaWFsIHx8IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKCB7IGNvbG9yOiAweGRkZGRkZCwgc2lkZTogZ2VvbWV0cnkuZG91YmxlU2lkZWQgPyBUSFJFRS5Eb3VibGVTaWRlIDogVEhSRUUuRnJvbnRTaWRlIH0gKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvbSA9IGdlb21ldHJ5Lm1lc2guZ2VvbWV0cnkzanM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG51bV9tYXRlcmlhbHMgPiAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk11bHRpTWF0ZXJpYWwoIHVzZWRfbWF0ZXJpYWxzX2FycmF5ICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNraW5Db250cm9sbGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblxuICAgICAgICAgICAgICAgICAgICBhcHBseVNraW4oIGdlb20sIHNraW5Db250cm9sbGVyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tLm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuc2tpbm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNraW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBtZXNoID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCBnZW9tLCBtYXRlcmlhbCwgZmFsc2UgKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vbWVzaC5za2VsZXRvbiA9IHNraW5Db250cm9sbGVyLnNrZWxldG9uO1xuICAgICAgICAgICAgICAgICAgICAvL21lc2guc2tpbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgc2tpbkNvbnRyb2xsZXIudXJsIF07XG4gICAgICAgICAgICAgICAgICAgIC8vbWVzaC5za2luSW5zdGFuY2VDb250cm9sbGVyID0gc2tpbkNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubmFtZSA9ICdza2luXycgKyBza2lucy5sZW5ndGg7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vbWVzaC5hbmltYXRpb25IYW5kbGUuc2V0S2V5KDApO1xuICAgICAgICAgICAgICAgICAgICBza2lucy5wdXNoKCBtZXNoICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBtb3JwaENvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVNb3JwaCggZ2VvbSwgbW9ycGhDb250cm9sbGVyICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb20sIG1hdGVyaWFsICk7XG4gICAgICAgICAgICAgICAgICAgIG1lc2gubmFtZSA9ICdtb3JwaF8nICsgbW9ycGhzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBtb3JwaHMucHVzaCggbWVzaCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdlb20uaXNMaW5lU3RyaXAgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTGluZSggZ2VvbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbSwgbWF0ZXJpYWwgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouYWRkKG1lc2gpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbm9kZS5jYW1lcmFzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlX2NhbWVyYSA9IG5vZGUuY2FtZXJhc1tpXTtcbiAgICAgICAgICAgIHZhciBjcGFyYW1zID0gY2FtZXJhc1tpbnN0YW5jZV9jYW1lcmEudXJsXTtcblxuICAgICAgICAgICAgdmFyIGNhbSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShjcGFyYW1zLnlmb3YsIHBhcnNlRmxvYXQoY3BhcmFtcy5hc3BlY3RfcmF0aW8pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNwYXJhbXMuem5lYXIpLCBwYXJzZUZsb2F0KGNwYXJhbXMuemZhcikpO1xuXG4gICAgICAgICAgICBvYmouYWRkKGNhbSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGUubGlnaHRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZV9saWdodCA9IG5vZGUubGlnaHRzW2ldO1xuICAgICAgICAgICAgdmFyIGxwYXJhbXMgPSBsaWdodHNbaW5zdGFuY2VfbGlnaHQudXJsXTtcblxuICAgICAgICAgICAgaWYgKCBscGFyYW1zICYmIGxwYXJhbXMudGVjaG5pcXVlICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gbHBhcmFtcy5jb2xvci5nZXRIZXgoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZW5zaXR5ID0gbHBhcmFtcy5pbnRlbnNpdHk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gbHBhcmFtcy5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBscGFyYW1zLmZhbGxvZmZfYW5nbGU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCBscGFyYW1zLnRlY2huaXF1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXJlY3Rpb25hbCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWdodC5wb3NpdGlvbi5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdwb2ludCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzcG90JzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGlnaHQgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FtYmllbnQnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGNvbG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGlnaHQpIHtcbiAgICAgICAgICAgICAgICBvYmouYWRkKGxpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5uYW1lID0gbm9kZS5uYW1lIHx8IG5vZGUuaWQgfHwgXCJcIjtcbiAgICAgICAgb2JqLmNvbGxhZGFJZCA9IG5vZGUuaWQgfHwgXCJcIjtcbiAgICAgICAgb2JqLmxheWVyID0gbm9kZS5sYXllciB8fCBcIlwiO1xuICAgICAgICBvYmoubWF0cml4ID0gbm9kZS5tYXRyaXg7XG4gICAgICAgIG9iai5tYXRyaXguZGVjb21wb3NlKCBvYmoucG9zaXRpb24sIG9iai5xdWF0ZXJuaW9uLCBvYmouc2NhbGUgKTtcblxuICAgICAgICBpZiAoIG9wdGlvbnMuY2VudGVyR2VvbWV0cnkgJiYgb2JqLmdlb21ldHJ5ICkge1xuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBvYmouZ2VvbWV0cnkuY2VudGVyKCk7XG4gICAgICAgICAgICBkZWx0YS5tdWx0aXBseSggb2JqLnNjYWxlICk7XG4gICAgICAgICAgICBkZWx0YS5hcHBseVF1YXRlcm5pb24oIG9iai5xdWF0ZXJuaW9uICk7XG5cbiAgICAgICAgICAgIG9iai5wb3NpdGlvbi5zdWIoIGRlbHRhICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbm9kZS5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG9iai5hZGQoIGNyZWF0ZVNjZW5lR3JhcGgoIG5vZGUubm9kZXNbaV0sIG5vZGUgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Sm9pbnRJZCggc2tpbiwgaWQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2tpbi5qb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICBpZiAoIHNraW4uam9pbnRzWyBpIF0gPT09IGlkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMaWJyYXJ5Tm9kZSggaWQgKSB7XG5cbiAgICAgICAgdmFyIG5vZGVzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdsaWJyYXJ5X25vZGVzIG5vZGUnKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICAgICAgdmFyIGF0dE9iaiA9IG5vZGVzW2ldLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdpZCcpO1xuXG4gICAgICAgICAgICBpZiAoIGF0dE9iaiAmJiBhdHRPYmoudmFsdWUgPT09IGlkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDaGFubmVsc0Zvck5vZGUgKCBub2RlICkge1xuXG4gICAgICAgIHZhciBjaGFubmVscyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gMTAwMDAwMDtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSAtMTAwMDAwMDtcblxuICAgICAgICBmb3IgKCB2YXIgaWQgaW4gYW5pbWF0aW9ucyApIHtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaWRdO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbmltYXRpb24uY2hhbm5lbC5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGFuaW1hdGlvbi5jaGFubmVsW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gY2hhbm5lbC50YXJnZXQuc3BsaXQoJy8nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmICggaWQgPT0gbm9kZS5pZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnNhbXBsZXIgPSBzYW1wbGVyO1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBNYXRoLm1pbihzdGFydFRpbWUsIHNhbXBsZXIuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA9IE1hdGgubWF4KGVuZFRpbWUsIHNhbXBsZXIuZW5kVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzLnB1c2goY2hhbm5lbCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBjaGFubmVscy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIG5vZGUuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgbm9kZS5lbmRUaW1lID0gZW5kVGltZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYW5uZWxzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0ZyYW1lRHVyYXRpb24oIG5vZGUgKSB7XG5cbiAgICAgICAgdmFyIG1pblQgPSAxMDAwMDAwMDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLmNoYW5uZWxzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIHNhbXBsZXIgPSBub2RlLmNoYW5uZWxzW2ldLnNhbXBsZXI7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IHNhbXBsZXIuaW5wdXQubGVuZ3RoIC0gMTsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgIHZhciB0MCA9IHNhbXBsZXIuaW5wdXRbIGogXTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSBzYW1wbGVyLmlucHV0WyBqICsgMSBdO1xuICAgICAgICAgICAgICAgIG1pblQgPSBNYXRoLm1pbiggbWluVCwgdDEgLSB0MCApO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluVDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNNYXRyaXhBdCggbm9kZSwgdCApIHtcblxuICAgICAgICB2YXIgYW5pbWF0ZWQgPSB7fTtcblxuICAgICAgICB2YXIgaSwgajtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbIGkgXTtcbiAgICAgICAgICAgIGFuaW1hdGVkWyBjaGFubmVsLnNpZCBdID0gY2hhbm5lbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBub2RlLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gbm9kZS50cmFuc2Zvcm1zWyBpIF07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGFuaW1hdGVkWyB0cmFuc2Zvcm0uc2lkIF07XG5cbiAgICAgICAgICAgIGlmICggY2hhbm5lbCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZXIgPSBjaGFubmVsLnNhbXBsZXI7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBzYW1wbGVyLmlucHV0Lmxlbmd0aCAtIDE7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzYW1wbGVyLmlucHV0WyBqICsgMSBdID4gdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzYW1wbGVyLm91dHB1dFsgaiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2YWx1ZS5mbGF0dGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBoYW5kbGUgb3RoZXIgdHlwZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRyaXg7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYWtlQW5pbWF0aW9ucyAoIG5vZGUgKSB7XG5cbiAgICAgICAgaWYgKCBub2RlLmNoYW5uZWxzICYmIG5vZGUuY2hhbm5lbHMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdLFxuICAgICAgICAgICAgICAgIHNpZHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTaWQgPSBjaGFubmVsLmZ1bGxTaWQsXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXIgPSBjaGFubmVsLnNhbXBsZXIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gc2FtcGxlci5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbm9kZS5nZXRUcmFuc2Zvcm1CeVNpZCggY2hhbm5lbC5zaWQgKSxcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBjaGFubmVsLmFyckluZGljZXMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGNoYW5uZWwuYXJySW5kaWNlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyWyBqIF0gPSBnZXRDb252ZXJ0ZWRJbmRleCggY2hhbm5lbC5hcnJJbmRpY2VzWyBqIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IGdldENvbnZlcnRlZE1lbWJlciggY2hhbm5lbC5tZW1iZXIgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggdHJhbnNmb3JtICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2lkcy5pbmRleE9mKCBmdWxsU2lkICkgPT09IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRzLnB1c2goIGZ1bGxTaWQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGlucHV0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGlucHV0W2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzYW1wbGVyLmdldERhdGEoIHRyYW5zZm9ybS50eXBlLCBqLCBtZW1iZXIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBmaW5kS2V5KCBrZXlzLCB0aW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWtleSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5ldyBLZXkoIHRpbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZU5keCA9IGZpbmRUaW1lTmR4KCBrZXlzLCB0aW1lICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoIHRpbWVOZHggPT09IC0xID8ga2V5cy5sZW5ndGggOiB0aW1lTmR4LCAwLCBrZXkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuYWRkVGFyZ2V0KCBmdWxsU2lkLCB0cmFuc2Zvcm0sIG1lbWJlciwgZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coICdDb3VsZCBub3QgZmluZCB0cmFuc2Zvcm0gXCInICsgY2hhbm5lbC5zaWQgKyAnXCIgaW4gbm9kZSAnICsgbm9kZS5pZCApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHBvc3QgcHJvY2Vzc1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2lkcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2lkID0gc2lkc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFrZXkuaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVLZXlzKCBrZXlzLCBrZXksIGosIHNpZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLmtleXMgPSBrZXlzO1xuICAgICAgICAgICAgbm9kZS5zaWRzID0gc2lkcztcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kS2V5ICgga2V5cywgdGltZSkge1xuXG4gICAgICAgIHZhciByZXRWYWwgPSBudWxsO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsICYmIHJldFZhbCA9PT0gbnVsbDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmICgga2V5LnRpbWUgPT09IHRpbWUgKSB7XG5cbiAgICAgICAgICAgICAgICByZXRWYWwgPSBrZXk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGtleS50aW1lID4gdGltZSApIHtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRWYWw7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kVGltZU5keCAoIGtleXMsIHRpbWUpIHtcblxuICAgICAgICB2YXIgbmR4ID0gLTE7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWwgJiYgbmR4ID09PSAtMTsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIGlmICgga2V5LnRpbWUgPj0gdGltZSApIHtcblxuICAgICAgICAgICAgICAgIG5keCA9IGk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5keDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlS2V5cyAoIGtleXMsIGtleSwgbmR4LCBmdWxsU2lkICkge1xuXG4gICAgICAgIHZhciBwcmV2S2V5ID0gZ2V0UHJldktleVdpdGgoIGtleXMsIGZ1bGxTaWQsIG5keCA/IG5keCAtIDEgOiAwICksXG4gICAgICAgICAgICBuZXh0S2V5ID0gZ2V0TmV4dEtleVdpdGgoIGtleXMsIGZ1bGxTaWQsIG5keCArIDEgKTtcblxuICAgICAgICBpZiAoIHByZXZLZXkgJiYgbmV4dEtleSApIHtcblxuICAgICAgICAgICAgdmFyIHNjYWxlID0gKGtleS50aW1lIC0gcHJldktleS50aW1lKSAvIChuZXh0S2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUpLFxuICAgICAgICAgICAgICAgIHByZXZUYXJnZXQgPSBwcmV2S2V5LmdldFRhcmdldCggZnVsbFNpZCApLFxuICAgICAgICAgICAgICAgIG5leHREYXRhID0gbmV4dEtleS5nZXRUYXJnZXQoIGZ1bGxTaWQgKS5kYXRhLFxuICAgICAgICAgICAgICAgIHByZXZEYXRhID0gcHJldlRhcmdldC5kYXRhLFxuICAgICAgICAgICAgICAgIGRhdGE7XG5cbiAgICAgICAgICAgIGlmICggcHJldlRhcmdldC50eXBlID09PSAnbWF0cml4JyApIHtcblxuICAgICAgICAgICAgICAgIGRhdGEgPSBwcmV2RGF0YTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggcHJldkRhdGEubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcHJldkRhdGEubGVuZ3RoOyArKyBpICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbIGkgXSA9IHByZXZEYXRhWyBpIF0gKyAoIG5leHREYXRhWyBpIF0gLSBwcmV2RGF0YVsgaSBdICkgKiBzY2FsZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGRhdGEgPSBwcmV2RGF0YSArICggbmV4dERhdGEgLSBwcmV2RGF0YSApICogc2NhbGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5LmFkZFRhcmdldCggZnVsbFNpZCwgcHJldlRhcmdldC50cmFuc2Zvcm0sIHByZXZUYXJnZXQubWVtYmVyLCBkYXRhICk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gR2V0IG5leHQga2V5IHdpdGggZ2l2ZW4gc2lkXG5cbiAgICBmdW5jdGlvbiBnZXROZXh0S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ICkge1xuXG4gICAgICAgIGZvciAoIDsgbmR4IDwga2V5cy5sZW5ndGg7IG5keCArKyApIHtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbIG5keCBdO1xuXG4gICAgICAgICAgICBpZiAoIGtleS5oYXNUYXJnZXQoIGZ1bGxTaWQgKSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9XG5cbiAgICAvLyBHZXQgcHJldmlvdXMga2V5IHdpdGggZ2l2ZW4gc2lkXG5cbiAgICBmdW5jdGlvbiBnZXRQcmV2S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ICkge1xuXG4gICAgICAgIG5keCA9IG5keCA+PSAwID8gbmR4IDogbmR4ICsga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBuZHggPj0gMDsgbmR4IC0tICkge1xuXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1sgbmR4IF07XG5cbiAgICAgICAgICAgIGlmICgga2V5Lmhhc1RhcmdldCggZnVsbFNpZCApICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9JbWFnZSgpIHtcblxuICAgICAgICB0aGlzLmlkID0gXCJcIjtcbiAgICAgICAgdGhpcy5pbml0X2Zyb20gPSBcIlwiO1xuXG4gICAgfVxuXG4gICAgX0ltYWdlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdpbml0X2Zyb20nICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0X2Zyb20gPSBjaGlsZC50ZXh0Q29udGVudDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgICAgICB0aGlzLnNraW4gPSBudWxsO1xuICAgICAgICB0aGlzLm1vcnBoID0gbnVsbDtcblxuICAgIH1cblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIm5vbmVcIjtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdza2luJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraW4gPSAobmV3IFNraW4oKSkucGFyc2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtb3JwaCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3JwaCA9IChuZXcgTW9ycGgoKSkucGFyc2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTW9ycGgoKSB7XG5cbiAgICAgICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBNb3JwaC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuICAgICAgICB2YXIgc291cmNlcyA9IHt9O1xuICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIHRoaXMubWV0aG9kID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtZXRob2QnICk7XG4gICAgICAgIHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gKCBuZXcgU291cmNlKCkgKS5wYXJzZSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1sgc291cmNlLmlkIF0gPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndGFyZ2V0cyc6XG5cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzID0gdGhpcy5wYXJzZUlucHV0cyggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c1sgaSBdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBpbnB1dC5zZW1hbnRpYyApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ01PUlBIX1RBUkdFVCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRzID0gc291cmNlLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdNT1JQSF9XRUlHSFQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2VpZ2h0cyA9IHNvdXJjZS5yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIE1vcnBoLnByb3RvdHlwZS5wYXJzZUlucHV0cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgICB2YXIgaW5wdXRzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XG5cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2goIChuZXcgSW5wdXQoKSkucGFyc2UoY2hpbGQpICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFNraW4oKSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgICAgICB0aGlzLmJpbmRTaGFwZU1hdHJpeCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW52QmluZE1hdHJpY2VzID0gW107XG4gICAgICAgIHRoaXMuam9pbnRzID0gW107XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuXG4gICAgfVxuXG4gICAgU2tpbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuICAgICAgICB2YXIgc291cmNlcyA9IHt9O1xuICAgICAgICB2YXIgam9pbnRzLCB3ZWlnaHRzO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcbiAgICAgICAgdGhpcy5pbnZCaW5kTWF0cmljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5qb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy53ZWlnaHRzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYmluZF9zaGFwZV9tYXRyaXgnOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gX2Zsb2F0cyhjaGlsZC50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZFNoYXBlTWF0cml4ID0gZ2V0Q29udmVydGVkTWF0NCggZiApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IG5ldyBTb3VyY2UoKS5wYXJzZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXNbIHNyYy5pZCBdID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2pvaW50cyc6XG5cbiAgICAgICAgICAgICAgICAgICAgam9pbnRzID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGV4X3dlaWdodHMnOlxuXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHMgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJzZUpvaW50cyggam9pbnRzLCBzb3VyY2VzICk7XG4gICAgICAgIHRoaXMucGFyc2VXZWlnaHRzKCB3ZWlnaHRzLCBzb3VyY2VzICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgU2tpbi5wcm90b3R5cGUucGFyc2VKb2ludHMgPSBmdW5jdGlvbiAoIGVsZW1lbnQsIHNvdXJjZXMgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gKCBuZXcgSW5wdXQoKSApLnBhcnNlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1sgaW5wdXQuc291cmNlIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnB1dC5zZW1hbnRpYyA9PT0gJ0pPSU5UJyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qb2ludHMgPSBzb3VyY2UucmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlucHV0LnNlbWFudGljID09PSAnSU5WX0JJTkRfTUFUUklYJyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZCaW5kTWF0cmljZXMgPSBzb3VyY2UucmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTa2luLnByb3RvdHlwZS5wYXJzZVdlaWdodHMgPSBmdW5jdGlvbiAoIGVsZW1lbnQsIHNvdXJjZXMgKSB7XG5cbiAgICAgICAgdmFyIHYsIHZjb3VudCwgaW5wdXRzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XG5cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2goICggbmV3IElucHV0KCkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuXG4gICAgICAgICAgICAgICAgICAgIHYgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd2Y291bnQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHZjb3VudCA9IF9pbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmNvdW50Lmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIG51bUJvbmVzID0gdmNvdW50W2ldO1xuICAgICAgICAgICAgdmFyIHZlcnRleF93ZWlnaHRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG51bUJvbmVzOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgaW5wdXRzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNbIGsgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdlsgaW5kZXggKyBpbnB1dC5vZmZzZXQgXTtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCBpbnB1dC5zZW1hbnRpYyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnSk9JTlQnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbHVlbmNlLmpvaW50ID0gdmFsdWU7Ly90aGlzLmpvaW50c1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1dFSUdIVCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsdWVuY2Uud2VpZ2h0ID0gc291cmNlc1sgaW5wdXQuc291cmNlIF0uZGF0YVsgdmFsdWUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfd2VpZ2h0cy5wdXNoKCBpbmZsdWVuY2UgKTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBpbnB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB2ZXJ0ZXhfd2VpZ2h0cy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfd2VpZ2h0c1sgaiBdLmluZGV4ID0gaTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLndlaWdodHMucHVzaCggdmVydGV4X3dlaWdodHMgKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gVmlzdWFsU2NlbmUgKCkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuICAgIH1cblxuICAgIFZpc3VhbFNjZW5lLnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiggaWQsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeUlkKCBpZCwgcmVjdXJzaXZlICk7XG5cbiAgICAgICAgICAgIGlmICggbm9kZSApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIFZpc3VhbFNjZW5lLnByb3RvdHlwZS5nZXRDaGlsZEJ5U2lkID0gZnVuY3Rpb24oIHNpZCwgcmVjdXJzaXZlICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbIGkgXS5nZXRDaGlsZEJ5U2lkKCBzaWQsIHJlY3Vyc2l2ZSApO1xuXG4gICAgICAgICAgICBpZiAoIG5vZGUgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH07XG5cbiAgICBWaXN1YWxTY2VuZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdub2RlJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goICggbmV3IE5vZGUoKSApLnBhcnNlKCBjaGlsZCApICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTm9kZSgpIHtcblxuICAgICAgICB0aGlzLmlkID0gXCJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIHRoaXMuZ2VvbWV0cmllcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW107XG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIH1cblxuICAgIE5vZGUucHJvdG90eXBlLmdldENoYW5uZWxGb3JUcmFuc2Zvcm0gPSBmdW5jdGlvbiggdHJhbnNmb3JtU2lkICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBjaGFubmVsLnRhcmdldC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgdmFyIGlkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGRvdFN5bnRheCA9IChzaWQuaW5kZXhPZihcIi5cIikgPj0gMCk7XG4gICAgICAgICAgICB2YXIgYXJyU3ludGF4ID0gKHNpZC5pbmRleE9mKFwiKFwiKSA+PSAwKTtcbiAgICAgICAgICAgIHZhciBhcnJJbmRpY2VzO1xuICAgICAgICAgICAgdmFyIG1lbWJlcjtcblxuICAgICAgICAgICAgaWYgKCBkb3RTeW50YXggKSB7XG5cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHNpZC5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgc2lkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBtZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBhcnJTeW50YXggKSB7XG5cbiAgICAgICAgICAgICAgICBhcnJJbmRpY2VzID0gc2lkLnNwbGl0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICBzaWQgPSBhcnJJbmRpY2VzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBhcnJJbmRpY2VzLmxlbmd0aDsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBhcnJJbmRpY2VzWyBqIF0gPSBwYXJzZUludCggYXJySW5kaWNlc1sgaiBdLnJlcGxhY2UoIC9cXCkvLCAnJyApICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBzaWQgPT09IHRyYW5zZm9ybVNpZCApIHtcblxuICAgICAgICAgICAgICAgIGNoYW5uZWwuaW5mbyA9IHsgc2lkOiBzaWQsIGRvdFN5bnRheDogZG90U3ludGF4LCBhcnJTeW50YXg6IGFyclN5bnRheCwgYXJySW5kaWNlczogYXJySW5kaWNlcyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFubmVsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uICggaWQsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgICBpZiAoIHRoaXMuaWQgPT09IGlkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeUlkKCBpZCwgcmVjdXJzaXZlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG4gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRCeVNpZCA9IGZ1bmN0aW9uICggc2lkLCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnNpZCA9PT0gc2lkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWN1cnNpdmUgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeVNpZCggc2lkLCByZWN1cnNpdmUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggbiApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtQnlTaWQgPSBmdW5jdGlvbiAoIHNpZCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMudHJhbnNmb3Jtc1sgaSBdLnNpZCA9PT0gc2lkICkgcmV0dXJuIHRoaXMudHJhbnNmb3Jtc1sgaSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHZhciB1cmw7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzaWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgdGhpcy50eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgdGhpcy5sYXllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYXllcicpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSA9PT0gJ0pPSU5UJyA/IHRoaXMudHlwZSA6ICdOT0RFJztcblxuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICB0aGlzLmdlb21ldHJpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jYW1lcmFzID0gW107XG4gICAgICAgIHRoaXMubGlnaHRzID0gW107XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbm9kZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luc3RhbmNlX2NhbWVyYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFzLnB1c2goICggbmV3IEluc3RhbmNlQ2FtZXJhKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luc3RhbmNlX2NvbnRyb2xsZXInOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnMucHVzaCggKCBuZXcgSW5zdGFuY2VDb250cm9sbGVyKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luc3RhbmNlX2dlb21ldHJ5JzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb21ldHJpZXMucHVzaCggKCBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpICkucGFyc2UoIGNoaWxkICkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnN0YW5jZV9saWdodCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWdodHMucHVzaCggKCBuZXcgSW5zdGFuY2VMaWdodCgpICkucGFyc2UoIGNoaWxkICkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnN0YW5jZV9ub2RlJzpcblxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkucmVwbGFjZSggL14jLywgJycgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlOb2RlID0gZ2V0TGlicmFyeU5vZGUoIHVybCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaU5vZGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCggKCBuZXcgTm9kZSgpICkucGFyc2UoIGlOb2RlICkpIDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9va2F0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdza2V3JzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaCggKCBuZXcgVHJhbnNmb3JtKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4dHJhJzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoYW5uZWxzID0gZ2V0Q2hhbm5lbHNGb3JOb2RlKCB0aGlzICk7XG4gICAgICAgIGJha2VBbmltYXRpb25zKCB0aGlzICk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXNbIGkgXS5hcHBseSggdGhpcy5tYXRyaXggKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtICgpIHtcblxuICAgICAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLm9iaiA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuc2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzaWQnICk7XG4gICAgICAgIHRoaXMudHlwZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gICAgICAgIHRoaXMuZGF0YSA9IF9mbG9hdHMoIGVsZW1lbnQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgdGhpcy5jb252ZXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHN3aXRjaCAoIHRoaXMudHlwZSApIHtcblxuICAgICAgICAgICAgY2FzZSAnbWF0cml4JzpcblxuICAgICAgICAgICAgICAgIHRoaXMub2JqID0gZ2V0Q29udmVydGVkTWF0NCggdGhpcy5kYXRhICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5kYXRhWzNdICk7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG5cbiAgICAgICAgICAgICAgICBmaXhDb29yZHMoIHRoaXMuZGF0YSwgLTEgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9iaiA9IG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLmRhdGFbIDAgXSwgdGhpcy5kYXRhWyAxIF0sIHRoaXMuZGF0YVsgMiBdICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcblxuICAgICAgICAgICAgICAgIGZpeENvb3JkcyggdGhpcy5kYXRhLCAxICk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmogPSBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5kYXRhWyAwIF0sIHRoaXMuZGF0YVsgMSBdLCB0aGlzLmRhdGFbIDIgXSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnQ2FuIG5vdCBjb252ZXJ0IFRyYW5zZm9ybSBvZiB0eXBlICcgKyB0aGlzLnR5cGUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgICAgICAgICAgc3dpdGNoICggdGhpcy50eXBlICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbWF0cml4JzpcblxuICAgICAgICAgICAgICAgICAgICBtYXRyaXgubXVsdGlwbHkoIHRoaXMub2JqICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVRyYW5zbGF0aW9uKCB0aGlzLm9iai54LCB0aGlzLm9iai55LCB0aGlzLm9iai56ICkgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlUm90YXRpb25BeGlzKCB0aGlzLm9iaiwgdGhpcy5hbmdsZSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNjYWxlKCB0aGlzLm9iaiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgIH0oKTtcblxuICAgIFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkYXRhLCBtZW1iZXIgKSB7XG5cbiAgICAgICAgdmFyIG1lbWJlcnMgPSBbICdYJywgJ1knLCAnWicsICdBTkdMRScgXTtcblxuICAgICAgICBzd2l0Y2ggKCB0aGlzLnR5cGUgKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG5cbiAgICAgICAgICAgICAgICBpZiAoICEgbWVtYmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLmNvcHkoIGRhdGEgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lbWJlci5sZW5ndGggPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggbWVtYmVyWyAwIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm4xMSA9IGRhdGFbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5uMjEgPSBkYXRhWyAxIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoubjMxID0gZGF0YVsgMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm40MSA9IGRhdGFbIDMgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5uMTIgPSBkYXRhWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoubjIyID0gZGF0YVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm4zMiA9IGRhdGFbIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5uNDIgPSBkYXRhWyAzIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoubjEzID0gZGF0YVsgMCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm4yMyA9IGRhdGFbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5uMzMgPSBkYXRhWyAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoubjQzID0gZGF0YVsgMyBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm4xNCA9IGRhdGFbIDAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai5uMjQgPSBkYXRhWyAxIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoubjM0ID0gZGF0YVsgMiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLm40NCA9IGRhdGFbIDMgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1lbWJlci5sZW5ndGggPT09IDIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gJ24nICsgKCBtZW1iZXJbIDAgXSArIDEgKSArICggbWVtYmVyWyAxIF0gKyAxICk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqWyBwcm9wTmFtZSBdID0gZGF0YTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0luY29ycmVjdCBhZGRyZXNzaW5nIG9mIG1hdHJpeCBpbiB0cmFuc2Zvcm0uJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcblxuICAgICAgICAgICAgICAgIGlmICggT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBtZW1iZXIgKSA9PT0gJ1tvYmplY3QgQXJyYXldJyApIHtcblxuICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSBtZW1iZXJzWyBtZW1iZXJbIDAgXSBdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoICggbWVtYmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai54ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1knOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai55ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai56ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLnggPSBkYXRhWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai55ID0gZGF0YVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoueiA9IGRhdGFbIDIgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG5cbiAgICAgICAgICAgICAgICBpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggbWVtYmVyICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gbWVtYmVyc1sgbWVtYmVyWyAwIF0gXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoIG1lbWJlciApIHtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdYJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoueCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdZJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoueSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdaJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoueiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdBTkdMRSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBkYXRhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iai54ID0gZGF0YVsgMCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoueSA9IGRhdGFbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JqLnogPSBkYXRhWyAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gVEhSRUUuTWF0aC5kZWdUb1JhZCggZGF0YVsgMyBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5zdGFuY2VDb250cm9sbGVyKCkge1xuXG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAgICAgdGhpcy5za2VsZXRvbiA9IFtdO1xuICAgICAgICB0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cbiAgICB9XG5cbiAgICBJbnN0YW5jZUNvbnRyb2xsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMudXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VybCcpLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgICB0aGlzLnNrZWxldG9uID0gW107XG4gICAgICAgIHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdza2VsZXRvbic6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2VsZXRvbi5wdXNoKCBjaGlsZC50ZXh0Q29udGVudC5yZXBsYWNlKC9eIy8sICcnKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmRfbWF0ZXJpYWwnOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZXMgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9tYXRlcmlhbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGluc3RhbmNlcy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwucHVzaCggKG5ldyBJbnN0YW5jZU1hdGVyaWFsKCkpLnBhcnNlKGluc3RhbmNlKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZXh0cmEnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbnN0YW5jZU1hdGVyaWFsICgpIHtcblxuICAgICAgICB0aGlzLnN5bWJvbCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gXCJcIjtcblxuICAgIH1cblxuICAgIEluc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuc3ltYm9sID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N5bWJvbCcpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKS5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5zdGFuY2VHZW9tZXRyeSgpIHtcblxuICAgICAgICB0aGlzLnVybCA9IFwiXCI7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcblxuICAgIH1cblxuICAgIEluc3RhbmNlR2VvbWV0cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMudXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VybCcpLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgICB0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdiaW5kX21hdGVyaWFsJyApIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZXMgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9tYXRlcmlhbCcpO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgaW5zdGFuY2VzLmxlbmd0aDsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwucHVzaCggKG5ldyBJbnN0YW5jZU1hdGVyaWFsKCkpLnBhcnNlKGluc3RhbmNlKSApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gR2VvbWV0cnkoKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IFwiXCI7XG4gICAgICAgIHRoaXMubWVzaCA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBHZW9tZXRyeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICAgIGV4dHJhY3REb3VibGVTaWRlZCggdGhpcywgZWxlbWVudCApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtZXNoJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc2ggPSAobmV3IE1lc2godGhpcykpLnBhcnNlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdleHRyYSc6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBNZXNoKCBnZW9tZXRyeSApIHtcblxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XG4gICAgICAgIHRoaXMucHJpbWl0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZW9tZXRyeTNqcyA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBNZXNoLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLnByaW1pdGl2ZXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuXG4gICAgICAgICAgICAgICAgICAgIF9zb3VyY2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljZXMnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSAoIG5ldyBWZXJ0aWNlcygpICkucGFyc2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZXN0cmlwcyc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltaXRpdmVzLnB1c2goICggbmV3IExpbmVTdHJpcHMoKS5wYXJzZSggY2hpbGQgKSApICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndHJpYW5nbGVzJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW1pdGl2ZXMucHVzaCggKCBuZXcgVHJpYW5nbGVzKCkucGFyc2UoIGNoaWxkICkgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3BvbHlnb25zJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW1pdGl2ZXMucHVzaCggKCBuZXcgUG9seWdvbnMoKS5wYXJzZSggY2hpbGQgKSApICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncG9seWxpc3QnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbWl0aXZlcy5wdXNoKCAoIG5ldyBQb2x5bGlzdCgpLnBhcnNlKCBjaGlsZCApICkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdlb21ldHJ5M2pzID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgICAgaWYgKCB0aGlzLnZlcnRpY2VzID09PSBudWxsICkge1xuXG4gICAgICAgICAgICAvLyBUT0RPIChtcmRvb2IpOiBTdHVkeSBjYXNlIHdoZW4gdGhpcyBpcyBudWxsIChjYXJyaWVyLmRhZSlcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gc291cmNlc1sgdGhpcy52ZXJ0aWNlcy5pbnB1dFsnUE9TSVRJT04nXS5zb3VyY2UgXS5kYXRhO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkzanMudmVydGljZXMucHVzaCggZ2V0Q29udmVydGVkVmVjMyggdmVydGV4RGF0YSwgaSApLmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5wcmltaXRpdmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIHByaW1pdGl2ZSA9IHRoaXMucHJpbWl0aXZlc1sgaSBdO1xuICAgICAgICAgICAgcHJpbWl0aXZlLnNldFZlcnRpY2VzKCB0aGlzLnZlcnRpY2VzICk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVByaW1pdGl2ZSggcHJpbWl0aXZlLCB0aGlzLmdlb21ldHJ5M2pzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5nZW9tZXRyeTNqcy5jYWxjTm9ybWFscyApIHtcblxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeTNqcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2VvbWV0cnkzanMuY2FsY05vcm1hbHM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIE1lc2gucHJvdG90eXBlLmhhbmRsZVByaW1pdGl2ZSA9IGZ1bmN0aW9uICggcHJpbWl0aXZlLCBnZW9tICkge1xuXG4gICAgICAgIGlmICggcHJpbWl0aXZlIGluc3RhbmNlb2YgTGluZVN0cmlwcyApIHtcblxuICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIGluZGljZXMuIE1heWJlIGVhc2llciB3aXRoIEJ1ZmZlckdlb21ldHJ5P1xuXG4gICAgICAgICAgICBnZW9tLmlzTGluZVN0cmlwID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGosIGssIHBMaXN0ID0gcHJpbWl0aXZlLnAsIGlucHV0cyA9IHByaW1pdGl2ZS5pbnB1dHM7XG4gICAgICAgIHZhciBpbnB1dCwgaW5kZXgsIGlkeDMyO1xuICAgICAgICB2YXIgc291cmNlLCBudW1QYXJhbXM7XG4gICAgICAgIHZhciB2Y0luZGV4ID0gMCwgdmNvdW50ID0gMywgbWF4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHRleHR1cmVfc2V0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgaW5wdXRzLmxlbmd0aDsgaiArKyApIHtcblxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dHNbIGogXTtcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGlucHV0Lm9mZnNldCArIDE7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSAobWF4T2Zmc2V0IDwgb2Zmc2V0KSA/IG9mZnNldCA6IG1heE9mZnNldDtcblxuICAgICAgICAgICAgc3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdURVhDT09SRCc6XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVfc2V0cy5wdXNoKCBpbnB1dC5zZXQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIHBDb3VudCA9IDA7IHBDb3VudCA8IHBMaXN0Lmxlbmd0aDsgKysgcENvdW50ICkge1xuXG4gICAgICAgICAgICB2YXIgcCA9IHBMaXN0WyBwQ291bnQgXSwgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICggaSA8IHAubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHZzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgY3MgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICggcHJpbWl0aXZlLnZjb3VudCApIHtcblxuICAgICAgICAgICAgICAgICAgICB2Y291bnQgPSBwcmltaXRpdmUudmNvdW50Lmxlbmd0aCA/IHByaW1pdGl2ZS52Y291bnRbIHZjSW5kZXggKysgXSA6IHByaW1pdGl2ZS52Y291bnQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHZjb3VudCA9IHAubGVuZ3RoIC8gbWF4T2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IHZjb3VudDsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXRzWyBrIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwWyBpICsgKCBqICogbWF4T2Zmc2V0ICkgKyBpbnB1dC5vZmZzZXQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4MzIgPSBpbmRleCAqIG51bVBhcmFtcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdWRVJURVgnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzLnB1c2goIGluZGV4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdOT1JNQUwnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5zLnB1c2goIGdldENvbnZlcnRlZFZlYzMoIHNvdXJjZS5kYXRhLCBpZHgzMiApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdURVhDT09SRCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSB0cyB8fCB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHNbIGlucHV0LnNldCBdID09PSB1bmRlZmluZWQgKSB0c1sgaW5wdXQuc2V0IF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52ZXJ0IHRoZSBWXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzWyBpbnB1dC5zZXQgXS5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggc291cmNlLmRhdGFbIGlkeDMyIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDEgXSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDT0xPUic6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3MucHVzaCggbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMSBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAyIF0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggbnMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSB2ZXJ0aWNlcyBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnZlcnRpY2VzLmlucHV0Lk5PUk1BTDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlucHV0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgbmR4ID0gMCwgbGVuID0gdnMubGVuZ3RoOyBuZHggPCBsZW47IG5keCArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5zLnB1c2goIGdldENvbnZlcnRlZFZlYzMoIHNvdXJjZS5kYXRhLCB2c1sgbmR4IF0gKiBudW1QYXJhbXMgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbS5jYWxjTm9ybWFscyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCAhdHMgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdHMgPSB7IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSB2ZXJ0aWNlcyBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB0aGlzLnZlcnRpY2VzLmlucHV0LlRFWENPT1JEO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5wdXQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVfc2V0cy5wdXNoKCBpbnB1dC5zZXQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGFyYW1zID0gc291cmNlLmFjY2Vzc29yLnBhcmFtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBuZHggPSAwLCBsZW4gPSB2cy5sZW5ndGg7IG5keCA8IGxlbjsgbmR4ICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4MzIgPSB2c1sgbmR4IF0gKiBudW1QYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0c1sgaW5wdXQuc2V0IF0gPT09IHVuZGVmaW5lZCApIHRzWyBpbnB1dC5zZXQgXSA9IFsgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZlcnQgdGhlIFZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0c1sgaW5wdXQuc2V0IF0ucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHNvdXJjZS5kYXRhWyBpZHgzMiBdLCAxLjAgLSBzb3VyY2UuZGF0YVsgaWR4MzIgKyAxIF0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBjcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHZlcnRpY2VzIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IHRoaXMudmVydGljZXMuaW5wdXQuQ09MT1I7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnB1dCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlc1sgaW5wdXQuc291cmNlIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1QYXJhbXMgPSBzb3VyY2UuYWNjZXNzb3IucGFyYW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIG5keCA9IDAsIGxlbiA9IHZzLmxlbmd0aDsgbmR4IDwgbGVuOyBuZHggKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgzMiA9IHZzWyBuZHggXSAqIG51bVBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHNvdXJjZS5kYXRhWyBpZHgzMiBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAxIF0sIHNvdXJjZS5kYXRhWyBpZHgzMiArIDIgXSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IG51bGwsIGZhY2VzID0gW10sIHV2LCB1dkFycjtcblxuICAgICAgICAgICAgICAgIGlmICggdmNvdW50ID09PSAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdnNbMF0sIHZzWzFdLCB2c1syXSwgbnMsIGNzLmxlbmd0aCA/IGNzIDogbmV3IFRIUkVFLkNvbG9yKCkgKSApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdmNvdW50ID09PSA0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdnNbMF0sIHZzWzFdLCB2c1szXSwgbnMubGVuZ3RoID8gWyBuc1swXS5jbG9uZSgpLCBuc1sxXS5jbG9uZSgpLCBuc1szXS5jbG9uZSgpIF0gOiBbXSwgY3MubGVuZ3RoID8gWyBjc1swXSwgY3NbMV0sIGNzWzNdIF0gOiBuZXcgVEhSRUUuQ29sb3IoKSApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1sxXSwgdnNbMl0sIHZzWzNdLCBucy5sZW5ndGggPyBbIG5zWzFdLmNsb25lKCksIG5zWzJdLmNsb25lKCksIG5zWzNdLmNsb25lKCkgXSA6IFtdLCBjcy5sZW5ndGggPyBbIGNzWzFdLCBjc1syXSwgY3NbM10gXSA6IG5ldyBUSFJFRS5Db2xvcigpICkgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHZjb3VudCA+IDQgJiYgb3B0aW9ucy5zdWJkaXZpZGVGYWNlcyApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xyID0gY3MubGVuZ3RoID8gY3MgOiBuZXcgVEhSRUUuQ29sb3IoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzEsIHZlYzIsIHZlYzMsIHYxLCB2Miwgbm9ybTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJkaXZpZGUgaW50byBtdWx0aXBsZSBGYWNlM3NcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBrID0gMTsgayA8IHZjb3VudCAtIDE7ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHZzWzBdLCB2c1trXSwgdnNbayArIDFdLCBucy5sZW5ndGggPyBbIG5zWzBdLmNsb25lKCksIG5zW2sgKytdLmNsb25lKCksIG5zW2tdLmNsb25lKCkgXSA6IFtdLCBjbHIgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZmFjZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBuZHggPSAwLCBsZW4gPSBmYWNlcy5sZW5ndGg7IG5keCA8IGxlbjsgbmR4ICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlID0gZmFjZXNbbmR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UuZGFlTWF0ZXJpYWwgPSBwcmltaXRpdmUubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tLmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggayA9IDA7IGsgPCB0ZXh0dXJlX3NldHMubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXYgPSB0c1sgdGV4dHVyZV9zZXRzW2tdIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHZjb3VudCA+IDQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgcmlnaHQgVVZzIGZvciB0aGUgdmVydGljZXMgaW4gdGhpcyBmYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2QXJyID0gWyB1dlswXSwgdXZbbmR4ICsgMV0sIHV2W25keCArIDJdIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB2Y291bnQgPT09IDQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuZHggPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2QXJyID0gWyB1dlswXSwgdXZbMV0sIHV2WzNdIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXZBcnIgPSBbIHV2WzFdLmNsb25lKCksIHV2WzJdLCB1dlszXS5jbG9uZSgpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dkFyciA9IFsgdXZbMF0sIHV2WzFdLCB1dlsyXSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBnZW9tLmZhY2VWZXJ0ZXhVdnNba10gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9tLmZhY2VWZXJ0ZXhVdnNba10gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb20uZmFjZVZlcnRleFV2c1trXS5wdXNoKCB1dkFyciApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ2Ryb3BwZWQgZmFjZSB3aXRoIHZjb3VudCAnICsgdmNvdW50ICsgJyBmb3IgZ2VvbWV0cnkgd2l0aCBpZDogJyArIGdlb20uaWQgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgKz0gbWF4T2Zmc2V0ICogdmNvdW50O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFBvbHlnb25zICgpIHtcblxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gXCJcIjtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIHRoaXMudmNvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wID0gW107XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgIH1cblxuICAgIFBvbHlnb25zLnByb3RvdHlwZS5zZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICggdmVydGljZXMgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuaW5wdXRzWyBpIF0uc291cmNlID09PSB2ZXJ0aWNlcy5pZCApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzWyBpIF0uc291cmNlID0gdmVydGljZXMuaW5wdXRbICdQT1NJVElPTicgXS5zb3VyY2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgUG9seWdvbnMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ21hdGVyaWFsJyApO1xuICAgICAgICB0aGlzLmNvdW50ID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnY291bnQnLCAwICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2goICggbmV3IElucHV0KCkgKS5wYXJzZSggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0gKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Zjb3VudCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52Y291bnQgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnAucHVzaCggX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdwaCc6XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAncG9seWdvbiBob2xlcyBub3QgeWV0IHN1cHBvcnRlZCEnICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUG9seWxpc3QgKCkge1xuXG4gICAgICAgIFBvbHlnb25zLmNhbGwoIHRoaXMgKTtcblxuICAgICAgICB0aGlzLnZjb3VudCA9IFtdO1xuXG4gICAgfVxuXG4gICAgUG9seWxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWdvbnMucHJvdG90eXBlICk7XG4gICAgUG9seWxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWxpc3Q7XG5cbiAgICBmdW5jdGlvbiBMaW5lU3RyaXBzKCkge1xuXG4gICAgICAgIFBvbHlnb25zLmNhbGwoIHRoaXMgKTtcblxuICAgICAgICB0aGlzLnZjb3VudCA9IDE7XG5cbiAgICB9XG5cbiAgICBMaW5lU3RyaXBzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHlnb25zLnByb3RvdHlwZSApO1xuICAgIExpbmVTdHJpcHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZVN0cmlwcztcblxuICAgIGZ1bmN0aW9uIFRyaWFuZ2xlcyAoKSB7XG5cbiAgICAgICAgUG9seWdvbnMuY2FsbCggdGhpcyApO1xuXG4gICAgICAgIHRoaXMudmNvdW50ID0gMztcblxuICAgIH1cblxuICAgIFRyaWFuZ2xlcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5Z29ucy5wcm90b3R5cGUgKTtcbiAgICBUcmlhbmdsZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJpYW5nbGVzO1xuXG4gICAgZnVuY3Rpb24gQWNjZXNzb3IoKSB7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdHJpZGUgPSAwO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuXG4gICAgfVxuXG4gICAgQWNjZXNzb3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgICAgIHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICk7XG4gICAgICAgIHRoaXMuY291bnQgPSBfYXR0cl9hc19pbnQoIGVsZW1lbnQsICdjb3VudCcsIDAgKTtcbiAgICAgICAgdGhpcy5zdHJpZGUgPSBfYXR0cl9hc19pbnQoIGVsZW1lbnQsICdzdHJpZGUnLCAwICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdwYXJhbScgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgICAgICAgICAgICBwYXJhbVsgJ25hbWUnIF0gPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuICAgICAgICAgICAgICAgIHBhcmFtWyAndHlwZScgXSA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMucHVzaCggcGFyYW0gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBWZXJ0aWNlcygpIHtcblxuICAgICAgICB0aGlzLmlucHV0ID0ge307XG5cbiAgICB9XG5cbiAgICBWZXJ0aWNlcy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIGlmICggZWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lID09PSAnaW5wdXQnICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gKCBuZXcgSW5wdXQoKSApLnBhcnNlKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXSApO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRbIGlucHV0LnNlbWFudGljIF0gPSBpbnB1dDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJbnB1dCAoKSB7XG5cbiAgICAgICAgdGhpcy5zZW1hbnRpYyA9IFwiXCI7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgICAgICB0aGlzLnNldCA9IDA7XG5cbiAgICB9XG5cbiAgICBJbnB1dC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5zZW1hbnRpYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzZW1hbnRpYycpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzb3VyY2UnKS5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgICAgdGhpcy5zZXQgPSBfYXR0cl9hc19pbnQoZWxlbWVudCwgJ3NldCcsIC0xKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBfYXR0cl9hc19pbnQoZWxlbWVudCwgJ29mZnNldCcsIDApO1xuXG4gICAgICAgIGlmICggdGhpcy5zZW1hbnRpYyA9PT0gJ1RFWENPT1JEJyAmJiB0aGlzLnNldCA8IDAgKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0ID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU291cmNlICggaWQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuXG4gICAgfVxuXG4gICAgU291cmNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbF9hcnJheSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gX2Jvb2xzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmbG9hdF9hcnJheSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaW50X2FycmF5JzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBfaW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnSURSRUZfYXJyYXknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ05hbWVfYXJyYXknOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IF9zdHJpbmdzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGlsZC5jaGlsZE5vZGVzWyBqIF0ubm9kZU5hbWUgPT09ICdhY2Nlc3NvcicgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2Vzc29yID0gKCBuZXcgQWNjZXNzb3IoKSApLnBhcnNlKCBjaGlsZC5jaGlsZE5vZGVzWyBqIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2hpbGQubm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBTb3VyY2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIC8vZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjY2Vzc29yLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBwYXJhbSA9IHRoaXMuYWNjZXNzb3IucGFyYW1zWyAwIF07XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocGFyYW0ubmFtZSArIFwiIFwiICsgcGFyYW0udHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICggcGFyYW0udHlwZSApIHtcblxuICAgICAgICAgICAgY2FzZSAnSURSRUYnOlxuICAgICAgICAgICAgY2FzZSAnTmFtZSc6IGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcblxuICAgICAgICAgICAgY2FzZSAnZmxvYXQ0eDQnOlxuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhLmxlbmd0aDsgaiArPSAxNiApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuZGF0YS5zbGljZSggaiwgaiArIDE2ICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gZ2V0Q29udmVydGVkTWF0NCggcyApO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCggbSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coICdDb2xsYWRhTG9hZGVyOiBTb3VyY2U6IFJlYWQgZG9udCBrbm93IGhvdyB0byByZWFkICcgKyBwYXJhbS50eXBlICsgJy4nICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWwgKCkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmluc3RhbmNlX2VmZmVjdCA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBNYXRlcmlhbC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lID09PSAnaW5zdGFuY2VfZWZmZWN0JyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfZWZmZWN0ID0gKCBuZXcgSW5zdGFuY2VFZmZlY3QoKSApLnBhcnNlKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENvbG9yT3JUZXh0dXJlICgpIHtcblxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG4gICAgICAgIHRoaXMuY29sb3Iuc2V0UkdCKCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICk7XG4gICAgICAgIHRoaXMuY29sb3IuYSA9IDEuMDtcblxuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnRleGNvb3JkID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXhPcHRzID0gbnVsbDtcblxuICAgIH1cblxuICAgIENvbG9yT3JUZXh0dXJlLnByb3RvdHlwZS5pc0NvbG9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiAoIHRoaXMudGV4dHVyZSA9PT0gbnVsbCApO1xuXG4gICAgfTtcblxuICAgIENvbG9yT3JUZXh0dXJlLnByb3RvdHlwZS5pc1RleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuICggdGhpcy50ZXh0dXJlICE9IG51bGwgKTtcblxuICAgIH07XG5cbiAgICBDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICd0cmFuc3BhcmVudCcpIHtcblxuICAgICAgICAgICAgdGhpcy5vcGFxdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3BhcXVlJyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZ2JhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLnNldFJHQiggcmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLmEgPSByZ2JhWzNdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHR1cmUnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGV4dHVyZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleGNvb3JkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd0ZXhjb29yZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyBmcm9tOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NvbGxhZGEub3JnL21lZGlhd2lraS9pbmRleC5waHAvTWF5YV90ZXh0dXJlX3BsYWNlbWVudF9NQVlBX2V4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleE9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRVOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdFU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRWOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwVjogMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGV4dHVyZSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUucGFyc2VUZXh0dXJlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIGlmICggISBlbGVtZW50LmNoaWxkTm9kZXMgKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBzdXBwb3J0ZWQgYnkgTWF5YSwgM2RzTWF4LCBhbmQgTW90aW9uQnVpbGRlclxuXG4gICAgICAgIGlmICggZWxlbWVudC5jaGlsZE5vZGVzWzFdICYmIGVsZW1lbnQuY2hpbGROb2Rlc1sxXS5ub2RlTmFtZSA9PT0gJ2V4dHJhJyApIHtcblxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sxXTtcblxuICAgICAgICAgICAgaWYgKCBlbGVtZW50LmNoaWxkTm9kZXNbMV0gJiYgZWxlbWVudC5jaGlsZE5vZGVzWzFdLm5vZGVOYW1lID09PSAndGVjaG5pcXVlJyApIHtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmNoaWxkTm9kZXNbMV07XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb2Zmc2V0VSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb2Zmc2V0Vic6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwZWF0VSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwZWF0Vic6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3dyYXBVJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3cmFwVic6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBkYWUgaGF2ZSBhIHZhbHVlIG9mIHRydWUgd2hpY2ggYmVjb21lcyBOYU4gdmlhIHBhcnNlSW50XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjaGlsZC50ZXh0Q29udGVudC50b1VwcGVyQ2FzZSgpID09PSAnVFJVRScgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4T3B0c1sgY2hpbGQubm9kZU5hbWUgXSA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VJbnQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU2hhZGVyICggdHlwZSwgZWZmZWN0ICkge1xuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgIH1cblxuICAgIFNoYWRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdlbWlzc2lvbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlmZnVzZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BlY3VsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW50JzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzWyBjaGlsZC5ub2RlTmFtZSBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2J1bXAnOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmICdidW1wdHlwZScgaXMgJ2hlaWdodGZpZWxkJywgY3JlYXRlIGEgJ2J1bXAnIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgaWYgJ2J1bXB0eXBlJyBpcyAnbm9ybWFsbWFwJywgY3JlYXRlIGEgJ25vcm1hbCcgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gKERlZmF1bHQgdG8gJ2J1bXAnKVxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVtcFR5cGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdidW1wdHlwZScgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBidW1wVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYnVtcFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWlnaHRmaWVsZFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbICdidW1wJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggYnVtcFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJub3JtYWxtYXBcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyAnbm9ybWFsJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBcIlNoYWRlci5wcm90b3R5cGUucGFyc2U6IEludmFsaWQgdmFsdWUgZm9yIGF0dHJpYnV0ZSAnYnVtcHR5cGUnIChcIiArIGJ1bXBUeXBlICsgXCIpIC0gdmFsaWQgYnVtcHR5cGVzIGFyZSAnSEVJR0hURklFTEQnIGFuZCAnTk9STUFMTUFQJyAtIGRlZmF1bHRpbmcgdG8gJ0hFSUdIVEZJRUxEJ1wiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sgJ2J1bXAnIF0gPSAoIG5ldyBDb2xvck9yVGV4dHVyZSgpICkucGFyc2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiU2hhZGVyLnByb3RvdHlwZS5wYXJzZTogQXR0cmlidXRlICdidW1wdHlwZScgbWlzc2luZyBmcm9tIGJ1bXAgbm9kZSAtIGRlZmF1bHRpbmcgdG8gJ0hFSUdIVEZJRUxEJ1wiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyAnYnVtcCcgXSA9ICggbmV3IENvbG9yT3JUZXh0dXJlKCkgKS5wYXJzZSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnc2hpbmluZXNzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZWZsZWN0aXZpdHknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luZGV4X29mX3JlZnJhY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdmbG9hdCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZi5sZW5ndGggPiAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBmWyAwIF0udGV4dENvbnRlbnQgKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIFNoYWRlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHByb3BzID0ge307XG5cbiAgICAgICAgdmFyIHRyYW5zcGFyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXNbJ3RyYW5zcGFyZW5jeSddICE9PSB1bmRlZmluZWQgJiYgdGhpc1sndHJhbnNwYXJlbnQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRyYW5zcGFyZW50IGNvbG9yIFJCRyB0byBhdmVyYWdlIHZhbHVlXG4gICAgICAgICAgICB2YXIgdHJhbnNwYXJlbnRDb2xvciA9IHRoaXNbJ3RyYW5zcGFyZW50J107XG4gICAgICAgICAgICB2YXIgdHJhbnNwYXJlbmN5TGV2ZWwgPSAodGhpcy50cmFuc3BhcmVudC5jb2xvci5yICsgdGhpcy50cmFuc3BhcmVudC5jb2xvci5nICsgdGhpcy50cmFuc3BhcmVudC5jb2xvci5iKSAvIDMgKiB0aGlzLnRyYW5zcGFyZW5jeTtcblxuICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW5jeUxldmVsID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wc1sgJ3RyYW5zcGFyZW50JyBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wc1sgJ29wYWNpdHknIF0gPSAxIC0gdHJhbnNwYXJlbmN5TGV2ZWw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSB7XG4gICAgICAgICAgICAnZGlmZnVzZSc6J21hcCcsXG4gICAgICAgICAgICAnYW1iaWVudCc6J2xpZ2h0TWFwJyxcbiAgICAgICAgICAgICdzcGVjdWxhcic6J3NwZWN1bGFyTWFwJyxcbiAgICAgICAgICAgICdlbWlzc2lvbic6J2VtaXNzaW9uTWFwJyxcbiAgICAgICAgICAgICdidW1wJzonYnVtcE1hcCcsXG4gICAgICAgICAgICAnbm9ybWFsJzonbm9ybWFsTWFwJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiB0aGlzICkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBwcm9wICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYW1iaWVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW1pc3Npb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RpZmZ1c2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NwZWN1bGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdidW1wJzpcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3QgPSB0aGlzWyBwcm9wIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjb3QgaW5zdGFuY2VvZiBDb2xvck9yVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb3QuaXNUZXh0dXJlKCkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtcGxlcklkID0gY290LnRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cmZhY2VJZCA9IHRoaXMuZWZmZWN0LnNhbXBsZXJbc2FtcGxlcklkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3VyZmFjZUlkICE9PSB1bmRlZmluZWQgJiYgc3VyZmFjZUlkLnNvdXJjZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXJmYWNlID0gdGhpcy5lZmZlY3Quc3VyZmFjZVtzdXJmYWNlSWQuc291cmNlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHN1cmZhY2UgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gaW1hZ2VzWyBzdXJmYWNlLmluaXRfZnJvbSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGltYWdlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyBpbWFnZS5pbml0X2Zyb207XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggdXJsICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlLCB1cmwgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUud3JhcFMgPSBjb3QudGV4T3B0cy53cmFwVSA/IFRIUkVFLlJlcGVhdFdyYXBwaW5nIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gY290LnRleE9wdHMud3JhcFYgPyBUSFJFRS5SZXBlYXRXcmFwcGluZyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5vZmZzZXQueCA9IGNvdC50ZXhPcHRzLm9mZnNldFU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5vZmZzZXQueSA9IGNvdC50ZXhPcHRzLm9mZnNldFY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5yZXBlYXQueCA9IGNvdC50ZXhPcHRzLnJlcGVhdFU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5yZXBlYXQueSA9IGNvdC50ZXhPcHRzLnJlcGVhdFY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5c1twcm9wXV0gPSB0ZXh0dXJlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGV4dHVyZSB3aXRoIGJha2VkIGxpZ2h0aW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnZW1pc3Npb24nKSBwcm9wc1snZW1pc3NpdmUnXSA9IDB4ZmZmZmZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwcm9wID09PSAnZGlmZnVzZScgfHwgIXRyYW5zcGFyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9wID09PSAnZW1pc3Npb24nICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyAnZW1pc3NpdmUnIF0gPSBjb3QuY29sb3IuZ2V0SGV4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyBwcm9wIF0gPSBjb3QuY29sb3IuZ2V0SGV4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzaGluaW5lc3MnOlxuXG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyBwcm9wIF0gPSB0aGlzWyBwcm9wIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmVmbGVjdGl2aXR5JzpcblxuICAgICAgICAgICAgICAgICAgICBwcm9wc1sgcHJvcCBdID0gdGhpc1sgcHJvcCBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHByb3BzWyBwcm9wIF0gPiAwLjAgKSBwcm9wc1snZW52TWFwJ10gPSBvcHRpb25zLmRlZmF1bHRFbnZNYXA7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWydjb21iaW5lJ10gPSBUSFJFRS5NaXhPcGVyYXRpb247XHQvL21peCByZWd1bGFyIHNoYWRpbmcgd2l0aCByZWZsZWN0aXZlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luZGV4X29mX3JlZnJhY3Rpb24nOlxuXG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyAncmVmcmFjdGlvblJhdGlvJyBdID0gdGhpc1sgcHJvcCBdOyAvL1RPRE86IFwiaW5kZXhfb2ZfcmVmcmFjdGlvblwiIGJlY29tZXMgXCJyZWZyYWN0aW9uUmF0aW9cIiBpbiBzaGFkZXIsIGJ1dCBJJ20gbm90IHN1cmUgaWYgdGhlIHR3byBhcmUgYWN0dWFsbHkgY29tcGFyYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXNbIHByb3AgXSAhPT0gMS4wICkgcHJvcHNbJ2Vudk1hcCddID0gb3B0aW9ucy5kZWZhdWx0RW52TWFwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldHMgZmlndXJlZCBvdXQgdXAgdG9wXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHNbICdzaGFkaW5nJyBdID0gcHJlZmVycmVkU2hhZGluZztcbiAgICAgICAgcHJvcHNbICdzaWRlJyBdID0gdGhpcy5lZmZlY3QuZG91YmxlU2lkZWQgPyBUSFJFRS5Eb3VibGVTaWRlIDogVEhSRUUuRnJvbnRTaWRlO1xuXG4gICAgICAgIGlmICggcHJvcHMuZGlmZnVzZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICBwcm9wcy5jb2xvciA9IHByb3BzLmRpZmZ1c2U7XG4gICAgICAgICAgICBkZWxldGUgcHJvcHMuZGlmZnVzZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICggdGhpcy50eXBlICkge1xuXG4gICAgICAgICAgICBjYXNlICdjb25zdGFudCc6XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZW1pc3NpdmUgIT0gdW5kZWZpbmVkKSBwcm9wcy5jb2xvciA9IHByb3BzLmVtaXNzaXZlO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHByb3BzICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Bob25nJzpcbiAgICAgICAgICAgIGNhc2UgJ2JsaW5uJzpcblxuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoIHByb3BzICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2xhbWJlcnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCggcHJvcHMgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWw7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU3VyZmFjZSAoIGVmZmVjdCApIHtcblxuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDtcbiAgICAgICAgdGhpcy5pbml0X2Zyb20gPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1hdCA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBTdXJmYWNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2luaXRfZnJvbSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0X2Zyb20gPSBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmb3JtYXQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gY2hpbGQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJ1bmhhbmRsZWQgU3VyZmFjZSBwcm9wOiBcIiArIGNoaWxkLm5vZGVOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFNhbXBsZXIyRCAoIGVmZmVjdCApIHtcblxuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLndyYXBfcyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JhcF90ID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5maWx0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1hZ2ZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMubWlwZmlsdGVyID0gbnVsbDtcblxuICAgIH1cblxuICAgIFNhbXBsZXIyRC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0gY2hpbGQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbWluZmlsdGVyJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbmZpbHRlciA9IGNoaWxkLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ21hZ2ZpbHRlcic6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWdmaWx0ZXIgPSBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdtaXBmaWx0ZXInOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlwZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnd3JhcF9zJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBfcyA9IGNoaWxkLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3dyYXBfdCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwX3QgPSBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcInVuaGFuZGxlZCBTYW1wbGVyMkQgcHJvcDogXCIgKyBjaGlsZC5ub2RlTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFZmZlY3QgKCkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VyZmFjZSA9IHt9O1xuICAgICAgICB0aGlzLnNhbXBsZXIgPSB7fTtcblxuICAgIH1cblxuICAgIEVmZmVjdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmICggdGhpcy5zaGFkZXIgPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBFZmZlY3QucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuICAgICAgICB0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cbiAgICAgICAgZXh0cmFjdERvdWJsZVNpZGVkKCB0aGlzLCBlbGVtZW50ICk7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncHJvZmlsZV9DT01NT04nOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZWNobmlxdWUoIHRoaXMucGFyc2VQcm9maWxlQ09NTU9OKCBjaGlsZCApICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgRWZmZWN0LnByb3RvdHlwZS5wYXJzZU5ld3BhcmFtID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHZhciBzaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NpZCcgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1cmZhY2UnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VyZmFjZVtzaWRdID0gKCBuZXcgU3VyZmFjZSggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZXJbc2lkXSA9ICggbmV3IFNhbXBsZXIyRCggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZXh0cmEnOlxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggY2hpbGQubm9kZU5hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgRWZmZWN0LnByb3RvdHlwZS5wYXJzZVByb2ZpbGVDT01NT04gPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdmFyIHRlY2huaXF1ZTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncHJvZmlsZV9DT01NT04nOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9maWxlQ09NTU9OKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3RlY2huaXF1ZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGVjaG5pcXVlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3cGFyYW0nOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VOZXdwYXJhbSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pbWFnZSA9ICggbmV3IF9JbWFnZSgpICkucGFyc2UoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sgX2ltYWdlLmlkIF0gPSBfaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZXh0cmEnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZWNobmlxdWU7XG5cbiAgICB9O1xuXG4gICAgRWZmZWN0LnByb3RvdHlwZS5wYXJzZVRlY2huaXF1ZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjb25zdGFudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFtYmVydCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxpbm4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Bob25nJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYWRlciA9ICggbmV3IFNoYWRlciggY2hpbGQubm9kZU5hbWUsIHRoaXMgKSApLnBhcnNlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHRyYSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFeHRyYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIEVmZmVjdC5wcm90b3R5cGUucGFyc2VFeHRyYSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0ZWNobmlxdWUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXh0cmFUZWNobmlxdWUoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIEVmZmVjdC5wcm90b3R5cGUucGFyc2VFeHRyYVRlY2huaXF1ZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdidW1wJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkZXIucGFyc2UoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gSW5zdGFuY2VFZmZlY3QgKCkge1xuXG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcblxuICAgIH1cblxuICAgIEluc3RhbmNlRWZmZWN0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndXJsJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbigpIHtcblxuICAgICAgICB0aGlzLmlkID0gXCJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB7fTtcbiAgICAgICAgdGhpcy5zYW1wbGVyID0gW107XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IFtdO1xuXG4gICAgfVxuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltID0gKCBuZXcgQW5pbWF0aW9uKCkgKS5wYXJzZSggY2hpbGQgKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgc3JjIGluIGFuaW0uc291cmNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVsgc3JjIF0gPSBhbmltLnNvdXJjZVsgc3JjIF07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGFuaW0uY2hhbm5lbC5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5wdXNoKCBhbmltLmNoYW5uZWxbIGogXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVyLnB1c2goIGFuaW0uc2FtcGxlclsgaiBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3JjID0gKCBuZXcgU291cmNlKCkgKS5wYXJzZSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VbIHNyYy5pZCBdID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXInOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlci5wdXNoKCAoIG5ldyBTYW1wbGVyKCB0aGlzICkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5wdXNoKCAoIG5ldyBDaGFubmVsKCB0aGlzICkgKS5wYXJzZSggY2hpbGQgKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENoYW5uZWwoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgICAgICB0aGlzLnRhcmdldCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZnVsbFNpZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3RTeW50YXggPSBudWxsO1xuICAgICAgICB0aGlzLmFyclN5bnRheCA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJySW5kaWNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubWVtYmVyID0gbnVsbDtcblxuICAgIH1cblxuICAgIENoYW5uZWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkucmVwbGFjZSggL14jLywgJycgKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKTtcblxuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnRhcmdldC5zcGxpdCggJy8nICk7XG5cbiAgICAgICAgdmFyIGlkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIHNpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgdmFyIGRvdFN5bnRheCA9ICggc2lkLmluZGV4T2YoXCIuXCIpID49IDAgKTtcbiAgICAgICAgdmFyIGFyclN5bnRheCA9ICggc2lkLmluZGV4T2YoXCIoXCIpID49IDAgKTtcblxuICAgICAgICBpZiAoIGRvdFN5bnRheCApIHtcblxuICAgICAgICAgICAgcGFydHMgPSBzaWQuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgdGhpcy5zaWQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5tZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGFyclN5bnRheCApIHtcblxuICAgICAgICAgICAgdmFyIGFyckluZGljZXMgPSBzaWQuc3BsaXQoXCIoXCIpO1xuICAgICAgICAgICAgdGhpcy5zaWQgPSBhcnJJbmRpY2VzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJySW5kaWNlcy5sZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgICBhcnJJbmRpY2VzW2pdID0gcGFyc2VJbnQoIGFyckluZGljZXNbal0ucmVwbGFjZSgvXFwpLywgJycpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hcnJJbmRpY2VzID0gYXJySW5kaWNlcztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnNpZCA9IHNpZDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mdWxsU2lkID0gc2lkO1xuICAgICAgICB0aGlzLmRvdFN5bnRheCA9IGRvdFN5bnRheDtcbiAgICAgICAgdGhpcy5hcnJTeW50YXggPSBhcnJTeW50YXg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gU2FtcGxlciAoIGFuaW1hdGlvbiApIHtcblxuICAgICAgICB0aGlzLmlkID0gXCJcIjtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyaWRlT3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcblxuICAgIH1cblxuICAgIFNhbXBsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuICAgICAgICB0aGlzLmlucHV0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5wdXQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2goIChuZXcgSW5wdXQoKSkucGFyc2UoIGNoaWxkICkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBTYW1wbGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0c1sgaSBdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuYW5pbWF0aW9uLnNvdXJjZVsgaW5wdXQuc291cmNlIF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnSU5QVVQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBzb3VyY2UucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ09VVFBVVCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBzb3VyY2UucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZU91dCA9IHNvdXJjZS5hY2Nlc3Nvci5zdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnSU5URVJQT0xBVElPTic6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gc291cmNlLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdJTl9UQU5HRU5UJzpcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ09VVF9UQU5HRU5UJzpcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5wdXQuc2VtYW50aWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IDA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuXG4gICAgICAgIGlmICggdGhpcy5pbnB1dC5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMTAwMDAwMDAwO1xuICAgICAgICAgICAgdGhpcy5lbmRUaW1lID0gLTEwMDAwMDAwMDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dC5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5pbnB1dFsgaSBdICk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIHRoaXMuZW5kVGltZSwgdGhpcy5pbnB1dFsgaSBdICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTYW1wbGVyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCB0eXBlLCBuZHgsIG1lbWJlciApIHtcblxuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAoIHR5cGUgPT09ICdtYXRyaXgnICYmIHRoaXMuc3RyaWRlT3V0ID09PSAxNiApIHtcblxuICAgICAgICAgICAgZGF0YSA9IHRoaXMub3V0cHV0WyBuZHggXTtcblxuICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLnN0cmlkZU91dCA+IDEgKSB7XG5cbiAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgIG5keCAqPSB0aGlzLnN0cmlkZU91dDtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5zdHJpZGVPdXQ7ICsrIGkgKSB7XG5cbiAgICAgICAgICAgICAgICBkYXRhWyBpIF0gPSB0aGlzLm91dHB1dFsgbmR4ICsgaSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5zdHJpZGVPdXQgPT09IDMgKSB7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCB0eXBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeENvb3JkcyggZGF0YSwgLTEgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgZml4Q29vcmRzKCBkYXRhLCAxICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5zdHJpZGVPdXQgPT09IDQgJiYgdHlwZSA9PT0gJ21hdHJpeCcgKSB7XG5cbiAgICAgICAgICAgICAgICBmaXhDb29yZHMoIGRhdGEsIC0xICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5vdXRwdXRbIG5keCBdO1xuXG4gICAgICAgICAgICBpZiAoIG1lbWJlciAmJiB0eXBlID09PSAndHJhbnNsYXRlJyApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0Q29udmVydGVkVHJhbnNsYXRpb24oIG1lbWJlciwgZGF0YSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBLZXkgKCB0aW1lICkge1xuXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuXG4gICAgfVxuXG4gICAgS2V5LnByb3RvdHlwZS5hZGRUYXJnZXQgPSBmdW5jdGlvbiAoIGZ1bGxTaWQsIHRyYW5zZm9ybSwgbWVtYmVyLCBkYXRhICkge1xuXG4gICAgICAgIHRoaXMudGFyZ2V0cy5wdXNoKCB7XG4gICAgICAgICAgICBzaWQ6IGZ1bGxTaWQsXG4gICAgICAgICAgICBtZW1iZXI6IG1lbWJlcixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9ICk7XG5cbiAgICB9O1xuXG4gICAgS2V5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICggb3B0X3NpZCApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRhcmdldHMubGVuZ3RoOyArKyBpICkge1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRzWyBpIF07XG5cbiAgICAgICAgICAgIGlmICggIW9wdF9zaWQgfHwgdGFyZ2V0LnNpZCA9PT0gb3B0X3NpZCApIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldC50cmFuc2Zvcm0udXBkYXRlKCB0YXJnZXQuZGF0YSwgdGFyZ2V0Lm1lbWJlciApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIEtleS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCBmdWxsU2lkICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudGFyZ2V0cy5sZW5ndGg7ICsrIGkgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy50YXJnZXRzWyBpIF0uc2lkID09PSBmdWxsU2lkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0c1sgaSBdO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIEtleS5wcm90b3R5cGUuaGFzVGFyZ2V0ID0gZnVuY3Rpb24gKCBmdWxsU2lkICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudGFyZ2V0cy5sZW5ndGg7ICsrIGkgKSB7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy50YXJnZXRzWyBpIF0uc2lkID09PSBmdWxsU2lkICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfTtcblxuICAgIC8vIFRPRE86IEN1cnJlbnRseSBvbmx5IGRvaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBTaG91bGQgc3VwcG9ydCBmdWxsIENPTExBREEgc3BlYy5cbiAgICBLZXkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKCBuZXh0S2V5LCB0aW1lICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRzWyBpIF0sXG4gICAgICAgICAgICAgICAgbmV4dFRhcmdldCA9IG5leHRLZXkuZ2V0VGFyZ2V0KCB0YXJnZXQuc2lkICksXG4gICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgaWYgKCB0YXJnZXQudHJhbnNmb3JtLnR5cGUgIT09ICdtYXRyaXgnICYmIG5leHRUYXJnZXQgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSAoIHRpbWUgLSB0aGlzLnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gdGhpcy50aW1lICksXG4gICAgICAgICAgICAgICAgICAgIG5leHREYXRhID0gbmV4dFRhcmdldC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwcmV2RGF0YSA9IHRhcmdldC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzY2FsZSA8IDAgKSBzY2FsZSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCBzY2FsZSA+IDEgKSBzY2FsZSA9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHByZXZEYXRhLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgcHJldkRhdGEubGVuZ3RoOyArKyBqICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWyBqIF0gPSBwcmV2RGF0YVsgaiBdICsgKCBuZXh0RGF0YVsgaiBdIC0gcHJldkRhdGFbIGogXSApICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcHJldkRhdGEgKyAoIG5leHREYXRhIC0gcHJldkRhdGEgKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRhcmdldC5kYXRhO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldC50cmFuc2Zvcm0udXBkYXRlKCBkYXRhLCB0YXJnZXQubWVtYmVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIENhbWVyYVxuICAgIGZ1bmN0aW9uIENhbWVyYSgpIHtcblxuICAgICAgICB0aGlzLmlkID0gXCJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZWNobmlxdWUgPSBcIlwiO1xuXG4gICAgfVxuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb3B0aWNzJzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlT3B0aWNzKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIENhbWVyYS5wcm90b3R5cGUucGFyc2VPcHRpY3MgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgICAgaWYgKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXS5ub2RlTmFtZSA9PT0gJ3RlY2huaXF1ZV9jb21tb24nICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRlY2huaXF1ZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgdGVjaG5pcXVlLmNoaWxkTm9kZXMubGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVjaG5pcXVlID0gdGVjaG5pcXVlLmNoaWxkTm9kZXNbIGogXS5ub2RlTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMudGVjaG5pcXVlID09PSAncGVyc3BlY3RpdmUnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc3BlY3RpdmUgPSB0ZWNobmlxdWUuY2hpbGROb2Rlc1sgaiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBwZXJzcGVjdGl2ZS5jaGlsZE5vZGVzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBlcnNwZWN0aXZlLmNoaWxkTm9kZXNbIGsgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIHBhcmFtLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3lmb3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55Zm92ID0gcGFyYW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneGZvdic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnhmb3YgPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd6bmVhcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpuZWFyID0gcGFyYW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnemZhcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpmYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhc3BlY3RfcmF0aW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3BlY3RfcmF0aW8gPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy50ZWNobmlxdWUgPT09ICdvcnRob2dyYXBoaWMnICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3J0aG9ncmFwaGljID0gdGVjaG5pcXVlLmNoaWxkTm9kZXNbIGogXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgb3J0aG9ncmFwaGljLmNoaWxkTm9kZXMubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gb3J0aG9ncmFwaGljLmNoaWxkTm9kZXNbIGsgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoIHBhcmFtLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3htYWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54bWFnID0gcGFyYW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneW1hZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnltYWcgPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd6bmVhcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpuZWFyID0gcGFyYW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnemZhcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpmYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhc3BlY3RfcmF0aW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3BlY3RfcmF0aW8gPSBwYXJhbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEluc3RhbmNlQ2FtZXJhKCkge1xuXG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcblxuICAgIH1cblxuICAgIEluc3RhbmNlQ2FtZXJhLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvLyBMaWdodFxuXG4gICAgZnVuY3Rpb24gTGlnaHQoKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IFwiXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMudGVjaG5pcXVlID0gXCJcIjtcblxuICAgIH1cblxuICAgIExpZ2h0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUNvbW1vbiggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0ZWNobmlxdWUnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUZWNobmlxdWUoIGNoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgTGlnaHQucHJvdG90eXBlLnBhcnNlQ29tbW9uID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0aW9uYWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdzcG90JzpcbiAgICAgICAgICAgICAgICBjYXNlICdhbWJpZW50JzpcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlY2huaXF1ZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWdodCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGxpZ2h0LmNoaWxkTm9kZXMubGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBsaWdodC5jaGlsZE5vZGVzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmdiYSA9IF9mbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3Iuc2V0UkdCKCByZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IuYSA9IHJnYmFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFsbG9mZl9hbmdsZSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWxsb2ZmX2FuZ2xlID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdxdWFkcmF0aWNfYXR0ZW51YXRpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBmID8gTWF0aC5zcXJ0KCAxIC8gZiApIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgTGlnaHQucHJvdG90eXBlLnBhcnNlVGVjaG5pcXVlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMucHJvZmlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAncHJvZmlsZScgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuICAgICAgICAgICAgc3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbnRlbnNpdHknOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gcGFyc2VGbG9hdChjaGlsZC50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEluc3RhbmNlTGlnaHQoKSB7XG5cbiAgICAgICAgdGhpcy51cmwgPSBcIlwiO1xuXG4gICAgfVxuXG4gICAgSW5zdGFuY2VMaWdodC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndXJsJykucmVwbGFjZSgvXiMvLCAnJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gS2luZW1hdGljc01vZGVsKCApIHtcblxuICAgICAgICB0aGlzLmlkID0gJyc7XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLmpvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmtzID0gW107XG5cbiAgICB9XG5cbiAgICBLaW5lbWF0aWNzTW9kZWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICB0aGlzLmpvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmtzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VDb21tb24oY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIEtpbmVtYXRpY3NNb2RlbC5wcm90b3R5cGUucGFyc2VDb21tb24gPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnam9pbnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmpvaW50cy5wdXNoKCAobmV3IEpvaW50KCkpLnBhcnNlKGNoaWxkKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtzLnB1c2goIChuZXcgTGluaygpKS5wYXJzZShjaGlsZCkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBKb2ludCggKSB7XG5cbiAgICAgICAgdGhpcy5zaWQgPSAnJztcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIHRoaXMuYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHRoaXMubGltaXRzID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICB0aGlzLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnplcm9Qb3NpdGlvbiA9IDAuMDtcbiAgICAgICAgdGhpcy5taWRkbGVQb3NpdGlvbiA9IDAuMDtcblxuICAgIH1cblxuICAgIEpvaW50LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMuc2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NpZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICB0aGlzLmF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmxpbWl0cyA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy56ZXJvUG9zaXRpb24gPSAwLjA7XG4gICAgICAgIHRoaXMubWlkZGxlUG9zaXRpb24gPSAwLjA7XG5cbiAgICAgICAgdmFyIGF4aXNFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdheGlzJyk7XG4gICAgICAgIHZhciBfYXhpcyA9IF9mbG9hdHMoYXhpc0VsZW1lbnQudGV4dENvbnRlbnQpO1xuICAgICAgICB0aGlzLmF4aXMgPSBnZXRDb252ZXJ0ZWRWZWMzKF9heGlzLCAwKTtcblxuICAgICAgICB2YXIgbWluID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaW1pdHMgbWluJykgPyBwYXJzZUZsb2F0KGVsZW1lbnQucXVlcnlTZWxlY3RvcignbGltaXRzIG1pbicpLnRleHRDb250ZW50KSA6IC0zNjA7XG4gICAgICAgIHZhciBtYXggPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbWl0cyBtYXgnKSA/IHBhcnNlRmxvYXQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaW1pdHMgbWF4JykudGV4dENvbnRlbnQpIDogMzYwO1xuXG4gICAgICAgIHRoaXMubGltaXRzID0ge1xuICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBqb2ludFR5cGVzID0gWyAncHJpc21hdGljJywgJ3Jldm9sdXRlJyBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpvaW50VHlwZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGpvaW50VHlwZXNbIGkgXTtcblxuICAgICAgICAgICAgdmFyIGpvaW50RWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcih0eXBlKTtcblxuICAgICAgICAgICAgaWYgKCBqb2ludEVsZW1lbnQgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBtaW4gaXMgZXF1YWwgdG8gb3Igc29tZWhvdyBncmVhdGVyIHRoYW4gdGhlIG1heCwgY29uc2lkZXIgdGhlIGpvaW50IHN0YXRpY1xuICAgICAgICBpZiAoIHRoaXMubGltaXRzLm1pbiA+PSB0aGlzLmxpbWl0cy5tYXggKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGljID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taWRkbGVQb3NpdGlvbiA9ICh0aGlzLmxpbWl0cy5taW4gKyB0aGlzLmxpbWl0cy5tYXgpIC8gMi4wO1xuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBMaW5rKCApIHtcblxuICAgICAgICB0aGlzLnNpZCA9ICcnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIHRoaXMuYXR0YWNobWVudHMgPSBbXTtcblxuICAgIH1cblxuICAgIExpbmsucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5zaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc2lkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaG1lbnRfZnVsbCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudHMucHVzaCggKG5ldyBBdHRhY2htZW50KCkpLnBhcnNlKGNoaWxkKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKCAobmV3IFRyYW5zZm9ybSgpKS5wYXJzZShjaGlsZCkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEF0dGFjaG1lbnQoICkge1xuXG4gICAgICAgIHRoaXMuam9pbnQgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcblxuICAgIH1cblxuICAgIEF0dGFjaG1lbnQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdGhpcy5qb2ludCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdqb2ludCcpLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIHRoaXMubGlua3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuICAgICAgICAgICAgaWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua3MucHVzaCggKG5ldyBMaW5rKCkpLnBhcnNlKGNoaWxkKSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKCAobmV3IFRyYW5zZm9ybSgpKS5wYXJzZShjaGlsZCkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9zb3VyY2UoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgdmFyIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblxuICAgICAgICBpZiAoIHNvdXJjZXNbIGlkIF0gIT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlc1sgaWQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlc1sgaWQgXSA9ICggbmV3IFNvdXJjZShpZCApKS5wYXJzZSggZWxlbWVudCApO1xuICAgICAgICByZXR1cm4gc291cmNlc1sgaWQgXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9uc1Jlc29sdmVyKCBuc1ByZWZpeCApIHtcblxuICAgICAgICBpZiAoIG5zUHJlZml4ID09PSBcImRhZVwiICkge1xuXG4gICAgICAgICAgICByZXR1cm4gXCJodHRwOi8vd3d3LmNvbGxhZGEub3JnLzIwMDUvMTEvQ09MTEFEQVNjaGVtYVwiO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9ib29scyggc3RyICkge1xuXG4gICAgICAgIHZhciByYXcgPSBfc3RyaW5ncyggc3RyICk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmF3Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIGRhdGEucHVzaCggKHJhd1tpXSA9PT0gJ3RydWUnIHx8IHJhd1tpXSA9PT0gJzEnKSA/IHRydWUgOiBmYWxzZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mbG9hdHMoIHN0ciApIHtcblxuICAgICAgICB2YXIgcmF3ID0gX3N0cmluZ3Moc3RyKTtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSByYXcubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICAgICAgZGF0YS5wdXNoKCBwYXJzZUZsb2F0KCByYXdbIGkgXSApICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ludHMoIHN0ciApIHtcblxuICAgICAgICB2YXIgcmF3ID0gX3N0cmluZ3MoIHN0ciApO1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHJhdy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgICAgICBkYXRhLnB1c2goIHBhcnNlSW50KCByYXdbIGkgXSwgMTAgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zdHJpbmdzKCBzdHIgKSB7XG5cbiAgICAgICAgcmV0dXJuICggc3RyLmxlbmd0aCA+IDAgKSA/IF90cmltU3RyaW5nKCBzdHIgKS5zcGxpdCggL1xccysvICkgOiBbXTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF90cmltU3RyaW5nKCBzdHIgKSB7XG5cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKCAvXlxccysvLCBcIlwiICkucmVwbGFjZSggL1xccyskLywgXCJcIiApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2F0dHJfYXNfZmxvYXQoIGVsZW1lbnQsIG5hbWUsIGRlZmF1bHRWYWx1ZSApIHtcblxuICAgICAgICBpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXR0cl9hc19pbnQoIGVsZW1lbnQsIG5hbWUsIGRlZmF1bHRWYWx1ZSApIHtcblxuICAgICAgICBpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoIG5hbWUgKSwgMTApIDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hdHRyX2FzX3N0cmluZyggZWxlbWVudCwgbmFtZSwgZGVmYXVsdFZhbHVlICkge1xuXG4gICAgICAgIGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIG5hbWUgKSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZm9ybWF0X2Zsb2F0KCBmLCBudW0gKSB7XG5cbiAgICAgICAgaWYgKCBmID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHZhciBzID0gJzAuJztcblxuICAgICAgICAgICAgd2hpbGUgKCBzLmxlbmd0aCA8IG51bSArIDIgKSB7XG5cbiAgICAgICAgICAgICAgICBzICs9ICcwJztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcztcblxuICAgICAgICB9XG5cbiAgICAgICAgbnVtID0gbnVtIHx8IDI7XG5cbiAgICAgICAgdmFyIHBhcnRzID0gZi50b1N0cmluZygpLnNwbGl0KCAnLicgKTtcbiAgICAgICAgcGFydHNbIDEgXSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sgMSBdLnN1YnN0ciggMCwgbnVtICkgOiBcIjBcIjtcblxuICAgICAgICB3aGlsZSAoIHBhcnRzWyAxIF0ubGVuZ3RoIDwgbnVtICkge1xuXG4gICAgICAgICAgICBwYXJ0c1sgMSBdICs9ICcwJztcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oICcuJyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZFRleHR1cmVJbWFnZSAoIHRleHR1cmUsIHVybCApIHtcblxuICAgICAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgfSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdERvdWJsZVNpZGVkKCBvYmosIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgb2JqLmRvdWJsZVNpZGVkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2V4dHJhIGRvdWJsZV9zaWRlZCcpWzBdO1xuXG4gICAgICAgIGlmICggbm9kZSApIHtcblxuICAgICAgICAgICAgaWYgKCBub2RlICYmIHBhcnNlSW50KCBub2RlLnRleHRDb250ZW50LCAxMCApID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgb2JqLmRvdWJsZVNpZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIFVwIGF4aXMgY29udmVyc2lvblxuXG4gICAgZnVuY3Rpb24gc2V0VXBDb252ZXJzaW9uKCkge1xuXG4gICAgICAgIGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICE9PSB0cnVlIHx8IGNvbGxhZGFVcCA9PT0gb3B0aW9ucy51cEF4aXMgKSB7XG5cbiAgICAgICAgICAgIHVwQ29udmVyc2lvbiA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc3dpdGNoICggY29sbGFkYVVwICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnWCc6XG5cbiAgICAgICAgICAgICAgICAgICAgdXBDb252ZXJzaW9uID0gb3B0aW9ucy51cEF4aXMgPT09ICdZJyA/ICdYdG9ZJyA6ICdYdG9aJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdZJzpcblxuICAgICAgICAgICAgICAgICAgICB1cENvbnZlcnNpb24gPSBvcHRpb25zLnVwQXhpcyA9PT0gJ1gnID8gJ1l0b1gnIDogJ1l0b1onO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuXG4gICAgICAgICAgICAgICAgICAgIHVwQ29udmVyc2lvbiA9IG9wdGlvbnMudXBBeGlzID09PSAnWCcgPyAnWnRvWCcgOiAnWnRvWSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4Q29vcmRzKCBkYXRhLCBzaWduICkge1xuXG4gICAgICAgIGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICE9PSB0cnVlIHx8IGNvbGxhZGFVcCA9PT0gb3B0aW9ucy51cEF4aXMgKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICggdXBDb252ZXJzaW9uICkge1xuXG4gICAgICAgICAgICBjYXNlICdYdG9ZJzpcblxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBkYXRhWyAwIF07XG4gICAgICAgICAgICAgICAgZGF0YVsgMCBdID0gc2lnbiAqIGRhdGFbIDEgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAxIF0gPSB0bXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1h0b1onOlxuXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGRhdGFbIDIgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAyIF0gPSBkYXRhWyAxIF07XG4gICAgICAgICAgICAgICAgZGF0YVsgMSBdID0gZGF0YVsgMCBdO1xuICAgICAgICAgICAgICAgIGRhdGFbIDAgXSA9IHRtcDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnWXRvWCc6XG5cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gZGF0YVsgMCBdO1xuICAgICAgICAgICAgICAgIGRhdGFbIDAgXSA9IGRhdGFbIDEgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAxIF0gPSBzaWduICogdG1wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdZdG9aJzpcblxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBkYXRhWyAxIF07XG4gICAgICAgICAgICAgICAgZGF0YVsgMSBdID0gc2lnbiAqIGRhdGFbIDIgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAyIF0gPSB0bXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1p0b1gnOlxuXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGRhdGFbIDAgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAwIF0gPSBkYXRhWyAxIF07XG4gICAgICAgICAgICAgICAgZGF0YVsgMSBdID0gZGF0YVsgMiBdO1xuICAgICAgICAgICAgICAgIGRhdGFbIDIgXSA9IHRtcDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnWnRvWSc6XG5cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gZGF0YVsgMSBdO1xuICAgICAgICAgICAgICAgIGRhdGFbIDEgXSA9IGRhdGFbIDIgXTtcbiAgICAgICAgICAgICAgICBkYXRhWyAyIF0gPSBzaWduICogdG1wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnZlcnRlZFRyYW5zbGF0aW9uKCBheGlzLCBkYXRhICkge1xuXG4gICAgICAgIGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICE9PSB0cnVlIHx8IGNvbGxhZGFVcCA9PT0gb3B0aW9ucy51cEF4aXMgKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKCBheGlzICkge1xuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVwQ29udmVyc2lvbiA9PT0gJ1h0b1knID8gZGF0YSAqIC0xIDogZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdZdG9aJyB8fCB1cENvbnZlcnNpb24gPT09ICdZdG9YJyA/IGRhdGEgKiAtMSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBkYXRhID0gdXBDb252ZXJzaW9uID09PSAnWnRvWScgPyBkYXRhICogLTEgOiBkYXRhIDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb252ZXJ0ZWRWZWMzKCBkYXRhLCBvZmZzZXQgKSB7XG5cbiAgICAgICAgdmFyIGFyciA9IFsgZGF0YVsgb2Zmc2V0IF0sIGRhdGFbIG9mZnNldCArIDEgXSwgZGF0YVsgb2Zmc2V0ICsgMiBdIF07XG4gICAgICAgIGZpeENvb3JkcyggYXJyLCAtMSApO1xuICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIGFyclsgMCBdLCBhcnJbIDEgXSwgYXJyWyAyIF0gKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnZlcnRlZE1hdDQoIGRhdGEgKSB7XG5cbiAgICAgICAgaWYgKCBvcHRpb25zLmNvbnZlcnRVcEF4aXMgKSB7XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGZpeCByb3RhdGlvbiBhbmQgc2NhbGVcblxuICAgICAgICAgICAgLy8gQ29sdW1ucyBmaXJzdFxuICAgICAgICAgICAgdmFyIGFyciA9IFsgZGF0YVsgMCBdLCBkYXRhWyA0IF0sIGRhdGFbIDggXSBdO1xuICAgICAgICAgICAgZml4Q29vcmRzKCBhcnIsIC0xICk7XG4gICAgICAgICAgICBkYXRhWyAwIF0gPSBhcnJbIDAgXTtcbiAgICAgICAgICAgIGRhdGFbIDQgXSA9IGFyclsgMSBdO1xuICAgICAgICAgICAgZGF0YVsgOCBdID0gYXJyWyAyIF07XG4gICAgICAgICAgICBhcnIgPSBbIGRhdGFbIDEgXSwgZGF0YVsgNSBdLCBkYXRhWyA5IF0gXTtcbiAgICAgICAgICAgIGZpeENvb3JkcyggYXJyLCAtMSApO1xuICAgICAgICAgICAgZGF0YVsgMSBdID0gYXJyWyAwIF07XG4gICAgICAgICAgICBkYXRhWyA1IF0gPSBhcnJbIDEgXTtcbiAgICAgICAgICAgIGRhdGFbIDkgXSA9IGFyclsgMiBdO1xuICAgICAgICAgICAgYXJyID0gWyBkYXRhWyAyIF0sIGRhdGFbIDYgXSwgZGF0YVsgMTAgXSBdO1xuICAgICAgICAgICAgZml4Q29vcmRzKCBhcnIsIC0xICk7XG4gICAgICAgICAgICBkYXRhWyAyIF0gPSBhcnJbIDAgXTtcbiAgICAgICAgICAgIGRhdGFbIDYgXSA9IGFyclsgMSBdO1xuICAgICAgICAgICAgZGF0YVsgMTAgXSA9IGFyclsgMiBdO1xuICAgICAgICAgICAgLy8gUm93cyBzZWNvbmRcbiAgICAgICAgICAgIGFyciA9IFsgZGF0YVsgMCBdLCBkYXRhWyAxIF0sIGRhdGFbIDIgXSBdO1xuICAgICAgICAgICAgZml4Q29vcmRzKCBhcnIsIC0xICk7XG4gICAgICAgICAgICBkYXRhWyAwIF0gPSBhcnJbIDAgXTtcbiAgICAgICAgICAgIGRhdGFbIDEgXSA9IGFyclsgMSBdO1xuICAgICAgICAgICAgZGF0YVsgMiBdID0gYXJyWyAyIF07XG4gICAgICAgICAgICBhcnIgPSBbIGRhdGFbIDQgXSwgZGF0YVsgNSBdLCBkYXRhWyA2IF0gXTtcbiAgICAgICAgICAgIGZpeENvb3JkcyggYXJyLCAtMSApO1xuICAgICAgICAgICAgZGF0YVsgNCBdID0gYXJyWyAwIF07XG4gICAgICAgICAgICBkYXRhWyA1IF0gPSBhcnJbIDEgXTtcbiAgICAgICAgICAgIGRhdGFbIDYgXSA9IGFyclsgMiBdO1xuICAgICAgICAgICAgYXJyID0gWyBkYXRhWyA4IF0sIGRhdGFbIDkgXSwgZGF0YVsgMTAgXSBdO1xuICAgICAgICAgICAgZml4Q29vcmRzKCBhcnIsIC0xICk7XG4gICAgICAgICAgICBkYXRhWyA4IF0gPSBhcnJbIDAgXTtcbiAgICAgICAgICAgIGRhdGFbIDkgXSA9IGFyclsgMSBdO1xuICAgICAgICAgICAgZGF0YVsgMTAgXSA9IGFyclsgMiBdO1xuXG4gICAgICAgICAgICAvLyBOb3cgZml4IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBhcnIgPSBbIGRhdGFbIDMgXSwgZGF0YVsgNyBdLCBkYXRhWyAxMSBdIF07XG4gICAgICAgICAgICBmaXhDb29yZHMoIGFyciwgLTEgKTtcbiAgICAgICAgICAgIGRhdGFbIDMgXSA9IGFyclsgMCBdO1xuICAgICAgICAgICAgZGF0YVsgNyBdID0gYXJyWyAxIF07XG4gICAgICAgICAgICBkYXRhWyAxMSBdID0gYXJyWyAyIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWF0cml4NCgpLnNldChcbiAgICAgICAgICAgIGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10sXG4gICAgICAgICAgICBkYXRhWzRdLCBkYXRhWzVdLCBkYXRhWzZdLCBkYXRhWzddLFxuICAgICAgICAgICAgZGF0YVs4XSwgZGF0YVs5XSwgZGF0YVsxMF0sIGRhdGFbMTFdLFxuICAgICAgICAgICAgZGF0YVsxMl0sIGRhdGFbMTNdLCBkYXRhWzE0XSwgZGF0YVsxNV1cbiAgICAgICAgICAgICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb252ZXJ0ZWRJbmRleCggaW5kZXggKSB7XG5cbiAgICAgICAgaWYgKCBpbmRleCA+IC0xICYmIGluZGV4IDwgMyApIHtcblxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSBbICdYJywgJ1knLCAnWicgXSxcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0geyBYOiAwLCBZOiAxLCBaOiAyIH07XG5cbiAgICAgICAgICAgIGluZGV4ID0gZ2V0Q29udmVydGVkTWVtYmVyKCBtZW1iZXJzWyBpbmRleCBdICk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGljZXNbIGluZGV4IF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnZlcnRlZE1lbWJlciggbWVtYmVyICkge1xuXG4gICAgICAgIGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBtZW1iZXIgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdYJzpcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB1cENvbnZlcnNpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1h0b1knOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWHRvWic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdZdG9YJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlciA9ICdZJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWnRvWCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSAnWic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnWSc6XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICggdXBDb252ZXJzaW9uICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdYdG9ZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1l0b1gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWnRvWCc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSAnWCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1h0b1onOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWXRvWic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdadG9ZJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlciA9ICdaJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdaJzpcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCB1cENvbnZlcnNpb24gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1h0b1onOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gJ1gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdZdG9aJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1p0b1gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWnRvWSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSAnWSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZW1iZXI7XG5cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIGxvYWQ6IGxvYWQsXG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgc2V0UHJlZmVycmVkU2hhZGluZzogc2V0UHJlZmVycmVkU2hhZGluZyxcbiAgICAgICAgYXBwbHlTa2luOiBhcHBseVNraW4sXG4gICAgICAgIGdlb21ldHJpZXMgOiBnZW9tZXRyaWVzLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG5cbiAgICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxhZGFMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGhyZWUtY29sbGFkYS1sb2FkZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nString.prototype.escapeHtml = function () {\n  return this.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n};\n\nString.prototype.paddingLeft = function (paddingValue) {\n  return String(paddingValue + this).slice(-paddingValue.length);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvdXRpbC9TdHJpbmdFeHRlbnNpb25zLmpzP2EwYzMiXSwic291cmNlc0NvbnRlbnQiOlsiU3RyaW5nLnByb3RvdHlwZS5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMDM5O1wiKTtcbn07XG5cblN0cmluZy5wcm90b3R5cGUucGFkZGluZ0xlZnQgPSBmdW5jdGlvbiAocGFkZGluZ1ZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcocGFkZGluZ1ZhbHVlICsgdGhpcylcbiAgICAuc2xpY2UoLXBhZGRpbmdWYWx1ZS5sZW5ndGgpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL3V0aWwvU3RyaW5nRXh0ZW5zaW9ucy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(124)();\n// imports\n\n\n// module\nexports.push([module.i, \"* {\\n    margin: 0;\\n    padding: 0;\\n}\\n\\nhtml, body {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n#camera-view canvas {\\n    display: block;\\n}\\n\\n#map-view canvas {\\n    display: block;\\n}\\n\\n#hud {\\n    position: absolute;\\n    top: 0px;\\n    left: 0px;\\n    height: 100%;\\n    opacity: 0.6;\\n    z-index: 100;\\n    display: flex;\\n    flex-direction: column;\\n    justify-content: space-around;\\n}\\n\\n.hud-overlay {\\n    flex: 0 1 auto;\\n    display: flex;\\n    flex-direction: column;\\n    border-radius: 10px;\\n    border-style: ridge;\\n    background-color: lightgray;\\n    padding-top: 5px;\\n    padding-bottom: 5px;\\n    padding-left: 10px;\\n    padding-right: 10px;\\n}\\n\\n.hud-overlay .title {\\n    flex: 1 1 auto;\\n    text-align: center;\\n}\\n\\n#warp {\\n    display: flex;\\n    flex-direction: row;\\n    margin-bottom: 3px;\\n}\\n\\n#warp-values {\\n    display: flex;\\n    flex-direction: row;\\n    flex: 0 1 auto;\\n}\\n\\n#warp-description {\\n    flex: 0 1 auto;\\n}\\n\\n#time {\\n    flex: 0 1 auto;\\n}\\n\\n.warp-enabled {\\n    width: 0;\\n    height: 0;\\n    border-top: 7px solid transparent;\\n    border-bottom: 7px solid transparent;\\n    border-left: 12.124px solid green;\\n    margin-right: 3px;\\n}\\n\\n.warp-disabled {\\n    width: 0;\\n    height: 0;\\n    border-top: 7px solid transparent;\\n    border-bottom: 7px solid transparent;\\n    border-left: 12.124px solid white;\\n    margin-right: 3px;\\n}\\n\\n.orbital-entry {\\n    flex: 0 1 auto;\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: space-between;\\n}\\n\\n.orbital-entry .label {\\n    flex: 0 1 auto;\\n    padding-right: 10px;\\n}\\n\\n.orbital-entry .value {\\n    flex: 0 1 auto;\\n}\\n\\n#orbital-name {\\n    text-transform: capitalize;\\n}\\n\\n#orbital-primary {\\n    text-transform: capitalize;\\n}\\n\\n.key-entry {\\n    flex: 0 1 auto;\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n}\\n\\n.key-entry .keys {\\n    flex: 0 1 auto;\\n    display: flex;\\n    flex-direction: row;\\n}\\n\\n.keys .key {\\n    flex: 0 1 auto;\\n    margin-top: 5px;\\n    margin-bottom: 5px;\\n    border: black;\\n    border-width: 3px;\\n    border-style: outset;\\n    border-color: lightgrey;\\n    background-color: white;\\n    padding-right: 3px;\\n    padding-left: 3px;\\n    font-size: x-large;\\n}\\n\\n.keys .key+.key {\\n    margin-left: 5px;\\n}\\n\\n.key-entry .description {\\n    flex: 1 1 auto;\\n    padding-left: 5px;\\n}\\n\\n#stats {\\n    text-align: center;\\n    opacity: 0.9;\\n}\\n\\n#stats-overlay {\\n    flex: 0 1 auto;\\n    border-radius: 0px;\\n    border-style: none;\\n    background-color: unset;\\n    opacity: 1.0;\\n}\\n\", \"\"]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy9zdHlsZXMuY3NzPzZiZmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5odG1sLCBib2R5IHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG59XFxuXFxuI2NhbWVyYS12aWV3IGNhbnZhcyB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4jbWFwLXZpZXcgY2FudmFzIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbiNodWQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwcHg7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgb3BhY2l0eTogMC42O1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbn1cXG5cXG4uaHVkLW92ZXJsYXkge1xcbiAgICBmbGV4OiAwIDEgYXV0bztcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgYm9yZGVyLXN0eWxlOiByaWRnZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmF5O1xcbiAgICBwYWRkaW5nLXRvcDogNXB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XFxufVxcblxcbi5odWQtb3ZlcmxheSAudGl0bGUge1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4jd2FycCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIG1hcmdpbi1ib3R0b206IDNweDtcXG59XFxuXFxuI3dhcnAtdmFsdWVzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgZmxleDogMCAxIGF1dG87XFxufVxcblxcbiN3YXJwLWRlc2NyaXB0aW9uIHtcXG4gICAgZmxleDogMCAxIGF1dG87XFxufVxcblxcbiN0aW1lIHtcXG4gICAgZmxleDogMCAxIGF1dG87XFxufVxcblxcbi53YXJwLWVuYWJsZWQge1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXItdG9wOiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1ib3R0b206IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLWxlZnQ6IDEyLjEyNHB4IHNvbGlkIGdyZWVuO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG59XFxuXFxuLndhcnAtZGlzYWJsZWQge1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXItdG9wOiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1ib3R0b206IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLWxlZnQ6IDEyLjEyNHB4IHNvbGlkIHdoaXRlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG59XFxuXFxuLm9yYml0YWwtZW50cnkge1xcbiAgICBmbGV4OiAwIDEgYXV0bztcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG5cXG4ub3JiaXRhbC1lbnRyeSAubGFiZWwge1xcbiAgICBmbGV4OiAwIDEgYXV0bztcXG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcXG59XFxuXFxuLm9yYml0YWwtZW50cnkgLnZhbHVlIHtcXG4gICAgZmxleDogMCAxIGF1dG87XFxufVxcblxcbiNvcmJpdGFsLW5hbWUge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG59XFxuXFxuI29yYml0YWwtcHJpbWFyeSB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbn1cXG5cXG4ua2V5LWVudHJ5IHtcXG4gICAgZmxleDogMCAxIGF1dG87XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5rZXktZW50cnkgLmtleXMge1xcbiAgICBmbGV4OiAwIDEgYXV0bztcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLmtleXMgLmtleSB7XFxuICAgIGZsZXg6IDAgMSBhdXRvO1xcbiAgICBtYXJnaW4tdG9wOiA1cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDVweDtcXG4gICAgYm9yZGVyOiBibGFjaztcXG4gICAgYm9yZGVyLXdpZHRoOiAzcHg7XFxuICAgIGJvcmRlci1zdHlsZTogb3V0c2V0O1xcbiAgICBib3JkZXItY29sb3I6IGxpZ2h0Z3JleTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDNweDtcXG4gICAgcGFkZGluZy1sZWZ0OiAzcHg7XFxuICAgIGZvbnQtc2l6ZTogeC1sYXJnZTtcXG59XFxuXFxuLmtleXMgLmtleSsua2V5IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDVweDtcXG59XFxuXFxuLmtleS1lbnRyeSAuZGVzY3JpcHRpb24ge1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gICAgcGFkZGluZy1sZWZ0OiA1cHg7XFxufVxcblxcbiNzdGF0cyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgb3BhY2l0eTogMC45O1xcbn1cXG5cXG4jc3RhdHMtb3ZlcmxheSB7XFxuICAgIGZsZXg6IDAgMSBhdXRvO1xcbiAgICBib3JkZXItcmFkaXVzOiAwcHg7XFxuICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdW5zZXQ7XFxuICAgIG9wYWNpdHk6IDEuMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvY3NzL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 124 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz9kYTA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 125 */
/***/ (function(module, exports) {

eval("module.exports = \"models/rock1/ArmGra05.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9yb2NrMS9Bcm1HcmEwNS5qcGc/NWFhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwibW9kZWxzL3JvY2sxL0FybUdyYTA1LmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21vZGVscy9yb2NrMS9Bcm1HcmEwNS5qcGdcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 126 */
/***/ (function(module, exports) {

eval("module.exports = \"img/earthbump.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9lYXJ0aGJ1bXAuanBnP2ZmMzQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImltZy9lYXJ0aGJ1bXAuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1nL2VhcnRoYnVtcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 127 */
/***/ (function(module, exports) {

eval("module.exports = \"img/earthmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9lYXJ0aG1hcC5qcGc/ZTQ3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiaW1nL2VhcnRobWFwLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ltZy9lYXJ0aG1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 128 */
/***/ (function(module, exports) {

eval("module.exports = \"img/earthspec.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9lYXJ0aHNwZWMuanBnPzdhZDAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImltZy9lYXJ0aHNwZWMuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1nL2VhcnRoc3BlYy5qcGdcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 129 */
/***/ (function(module, exports) {

eval("module.exports = \"img/jupitermap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9qdXBpdGVybWFwLmpwZz9jY2I1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJpbWcvanVwaXRlcm1hcC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWcvanVwaXRlcm1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 130 */
/***/ (function(module, exports) {

eval("module.exports = \"img/lensflare.png\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9sZW5zZmxhcmUucG5nPzQ4NzkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImltZy9sZW5zZmxhcmUucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1nL2xlbnNmbGFyZS5wbmdcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 131 */
/***/ (function(module, exports) {

eval("module.exports = \"img/marsmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9tYXJzbWFwLmpwZz9kMWVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJpbWcvbWFyc21hcC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWcvbWFyc21hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 132 */
/***/ (function(module, exports) {

eval("module.exports = \"img/mercurymap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9tZXJjdXJ5bWFwLmpwZz83NjYyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJpbWcvbWVyY3VyeW1hcC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWcvbWVyY3VyeW1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 133 */
/***/ (function(module, exports) {

eval("module.exports = \"img/moonmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9tb29ubWFwLmpwZz81NTA5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJpbWcvbW9vbm1hcC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWcvbW9vbm1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 134 */
/***/ (function(module, exports) {

eval("module.exports = \"img/neptunemap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9uZXB0dW5lbWFwLmpwZz9jY2FmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJpbWcvbmVwdHVuZW1hcC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbWcvbmVwdHVuZW1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 135 */
/***/ (function(module, exports) {

eval("module.exports = \"img/plutomap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9wbHV0b21hcC5qcGc/ZjU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiaW1nL3BsdXRvbWFwLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ltZy9wbHV0b21hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 136 */
/***/ (function(module, exports) {

eval("module.exports = \"img/saturnmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy9zYXR1cm5tYXAuanBnPzJjYWMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImltZy9zYXR1cm5tYXAuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1nL3NhdHVybm1hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 137 */
/***/ (function(module, exports) {

eval("module.exports = \"img/uranusmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy91cmFudXNtYXAuanBnPzY1YzUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImltZy91cmFudXNtYXAuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW1nL3VyYW51c21hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 138 */
/***/ (function(module, exports) {

eval("module.exports = \"img/venusmap.jpg\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ltZy92ZW51c21hcC5qcGc/YWE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiaW1nL3ZlbnVzbWFwLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2ltZy92ZW51c21hcC5qcGdcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 139 */
/***/ (function(module, exports) {

eval("module.exports = \"models/rock1.dae\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9yb2NrMS5kYWU/MzQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwibW9kZWxzL3JvY2sxLmRhZVwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21vZGVscy9yb2NrMS5kYWVcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 140 */,
/* 141 */
/***/ (function(module, exports) {

eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzP2I5ODAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 142 */,
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(120);\n\nvar _CommonState = __webpack_require__(115);\n\nvar _CommonState2 = _interopRequireDefault(_CommonState);\n\nvar _SolarSystem = __webpack_require__(118);\n\nvar _SolarSystem2 = _interopRequireDefault(_SolarSystem);\n\nvar _Simulation = __webpack_require__(117);\n\nvar _Simulation2 = _interopRequireDefault(_Simulation);\n\nvar _CameraViewRenderer = __webpack_require__(114);\n\nvar _CameraViewRenderer2 = _interopRequireDefault(_CameraViewRenderer);\n\nvar _OrbitalMapRenderer = __webpack_require__(116);\n\nvar _OrbitalMapRenderer2 = _interopRequireDefault(_OrbitalMapRenderer);\n\nvar _TestingRenderer = __webpack_require__(119);\n\nvar _TestingRenderer2 = _interopRequireDefault(_TestingRenderer);\n\nvar _stats = __webpack_require__(3);\n\nvar _stats2 = _interopRequireDefault(_stats);\n\nvar _three = __webpack_require__(1);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _threeColladaLoader = __webpack_require__(121);\n\nvar _threeColladaLoader2 = _interopRequireDefault(_threeColladaLoader);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar solarSystem = new _SolarSystem2.default();\n\nvar mapViewContainer = document.getElementById('map-view');\nvar cameraViewContainer = document.getElementById('camera-view');\nvar testingViewContainer = document.getElementById('testing-view');\n\nvar stats = new _stats2.default();\nstats.dom.id = 'stats';\nstats.dom.style = '';\n\ndocument.body.appendChild(mapViewContainer);\ndocument.body.appendChild(cameraViewContainer);\ndocument.getElementById('stats-overlay').appendChild(stats.dom);\n\nvar textureLoader = new THREE.TextureLoader();\nvar modelLoader = new _threeColladaLoader2.default();\nmodelLoader.options.convertUpAxis = true;\nmodelLoader.options.upAxis = 'Z';\n\nvar state = new _CommonState2.default();\nvar renderers = [new _OrbitalMapRenderer2.default(mapViewContainer, textureLoader, modelLoader, state), new _CameraViewRenderer2.default(cameraViewContainer, textureLoader, modelLoader, state)];\n\nvar simulation = new _Simulation2.default(solarSystem, renderers, state, stats);\nsimulation.initialize().then(function () {\n  simulation.run();\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9pbmRleC5qcz8xZmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9jc3Mvc3R5bGVzLmNzcyc7XG5pbXBvcnQgQ29tbW9uU3RhdGUgZnJvbSAnLi9hcHAvQ29tbW9uU3RhdGUnO1xuaW1wb3J0IFNvbGFyU3lzdGVtIGZyb20gJy4vYXBwL1NvbGFyU3lzdGVtJztcbmltcG9ydCBTaW11bGF0aW9uIGZyb20gJy4vYXBwL1NpbXVsYXRpb24nO1xuaW1wb3J0IENhbWVyYVZpZXdSZW5kZXJlciBmcm9tICcuL2FwcC9DYW1lcmFWaWV3UmVuZGVyZXInO1xuaW1wb3J0IE9yYml0YWxNYXBSZW5kZXJlciBmcm9tICcuL2FwcC9PcmJpdGFsTWFwUmVuZGVyZXInO1xuaW1wb3J0IFRlc3RpbmdSZW5kZXJlciBmcm9tICcuL2FwcC9UZXN0aW5nUmVuZGVyZXInO1xuaW1wb3J0IFN0YXRzIGZyb20gJ3N0YXRzLmpzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBDb2xsYWRhTG9hZGVyIGZyb20gJ3RocmVlLWNvbGxhZGEtbG9hZGVyJztcblxuY29uc3Qgc29sYXJTeXN0ZW0gPSBuZXcgU29sYXJTeXN0ZW0oKTtcblxubGV0IG1hcFZpZXdDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwLXZpZXcnKTtcbmxldCBjYW1lcmFWaWV3Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbWVyYS12aWV3Jyk7XG5sZXQgdGVzdGluZ1ZpZXdDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdGluZy12aWV3Jyk7XG5cbmxldCBzdGF0cyA9IG5ldyBTdGF0cygpO1xuc3RhdHMuZG9tLmlkID0gJ3N0YXRzJztcbnN0YXRzLmRvbS5zdHlsZSA9ICcnO1xuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hcFZpZXdDb250YWluZXIpO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW1lcmFWaWV3Q29udGFpbmVyKTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0cy1vdmVybGF5JylcbiAgLmFwcGVuZENoaWxkKHN0YXRzLmRvbSk7XG5cbmNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuY29uc3QgbW9kZWxMb2FkZXIgPSBuZXcgQ29sbGFkYUxvYWRlcigpO1xubW9kZWxMb2FkZXIub3B0aW9ucy5jb252ZXJ0VXBBeGlzID0gdHJ1ZTtcbm1vZGVsTG9hZGVyLm9wdGlvbnMudXBBeGlzID0gJ1onO1xuXG5jb25zdCBzdGF0ZSA9IG5ldyBDb21tb25TdGF0ZSgpO1xuY29uc3QgcmVuZGVyZXJzID0gW1xuICBuZXcgT3JiaXRhbE1hcFJlbmRlcmVyKG1hcFZpZXdDb250YWluZXIsIHRleHR1cmVMb2FkZXIsIG1vZGVsTG9hZGVyLCBzdGF0ZSksXG4gIG5ldyBDYW1lcmFWaWV3UmVuZGVyZXIoY2FtZXJhVmlld0NvbnRhaW5lciwgdGV4dHVyZUxvYWRlciwgbW9kZWxMb2FkZXIsIHN0YXRlKSxcbl07XG5cbmNvbnN0IHNpbXVsYXRpb24gPSBuZXcgU2ltdWxhdGlvbihzb2xhclN5c3RlbSwgcmVuZGVyZXJzLCBzdGF0ZSwgc3RhdHMpO1xuc2ltdWxhdGlvbi5pbml0aWFsaXplKClcbiAgLnRoZW4oKCkgPT4ge1xuICAgIHNpbXVsYXRpb24ucnVuKClcbiAgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
],[143]);